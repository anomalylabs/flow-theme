/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/bootstrap.native/dist/bootstrap-native-v4.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bootstrap.native/dist/bootstrap-native-v4.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Native Javascript for Bootstrap 4 v2.0.27 | Â© dnp_theme | MIT-License\n(function (root, factory) {\n  if (true) {\n    // AMD support:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var bsn; }\n}(this, function () {\n  \n  /* Native Javascript for Bootstrap 4 | Internal Utility Functions\n  ----------------------------------------------------------------*/\n  \"use strict\";\n  \n  // globals\n  var globalObject = typeof global !== 'undefined' ? global : this||window,\n    DOC = document, HTML = DOC.documentElement, body = 'body', // allow the library to be used in <head>\n  \n    // Native Javascript for Bootstrap Global Object\n    BSN = globalObject.BSN = {},\n    supports = BSN.supports = [],\n  \n    // function toggle attributes\n    dataToggle    = 'data-toggle',\n    dataDismiss   = 'data-dismiss',\n    dataSpy       = 'data-spy',\n    dataRide      = 'data-ride',\n  \n    // components\n    stringAlert     = 'Alert',\n    stringButton    = 'Button',\n    stringCarousel  = 'Carousel',\n    stringCollapse  = 'Collapse',\n    stringDropdown  = 'Dropdown',\n    stringModal     = 'Modal',\n    stringPopover   = 'Popover',\n    stringScrollSpy = 'ScrollSpy',\n    stringTab       = 'Tab',\n    stringTooltip   = 'Tooltip',\n    stringToast     = 'Toast',\n  \n    // options DATA API\n    dataAutohide      = 'data-autohide',\n    databackdrop      = 'data-backdrop',\n    dataKeyboard      = 'data-keyboard',\n    dataTarget        = 'data-target',\n    dataInterval      = 'data-interval',\n    dataHeight        = 'data-height',\n    dataPause         = 'data-pause',\n    dataTitle         = 'data-title',\n    dataOriginalTitle = 'data-original-title',\n    dataDismissible   = 'data-dismissible',\n    dataTrigger       = 'data-trigger',\n    dataAnimation     = 'data-animation',\n    dataContainer     = 'data-container',\n    dataPlacement     = 'data-placement',\n    dataDelay         = 'data-delay',\n  \n    // option keys\n    backdrop = 'backdrop', keyboard = 'keyboard', delay = 'delay',\n    content = 'content', target = 'target', currentTarget = 'currentTarget',\n    interval = 'interval', pause = 'pause', animation = 'animation',\n    placement = 'placement', container = 'container',\n  \n    // box model\n    offsetTop    = 'offsetTop',      offsetBottom   = 'offsetBottom',\n    offsetLeft   = 'offsetLeft',\n    scrollTop    = 'scrollTop',      scrollLeft     = 'scrollLeft',\n    clientWidth  = 'clientWidth',    clientHeight   = 'clientHeight',\n    offsetWidth  = 'offsetWidth',    offsetHeight   = 'offsetHeight',\n    innerWidth   = 'innerWidth',     innerHeight    = 'innerHeight',\n    scrollHeight = 'scrollHeight',   scrollWidth    = 'scrollWidth',\n    height         = 'height',\n  \n    // aria\n    ariaExpanded = 'aria-expanded',\n    ariaHidden   = 'aria-hidden',\n    ariaSelected = 'aria-selected',\n  \n    // event names\n    clickEvent    = 'click',\n    focusEvent    = 'focus',\n    hoverEvent    = 'hover',\n    keydownEvent  = 'keydown',\n    keyupEvent    = 'keyup',\n    resizeEvent   = 'resize', // passive\n    scrollEvent   = 'scroll', // passive\n    mouseHover = ('onmouseleave' in DOC) ? [ 'mouseenter', 'mouseleave'] : [ 'mouseover', 'mouseout' ],\n    // touch since 2.0.26\n    touchEvents = { start: 'touchstart', end: 'touchend', move:'touchmove' }, // passive\n    // originalEvents\n    showEvent     = 'show',\n    shownEvent    = 'shown',\n    hideEvent     = 'hide',\n    hiddenEvent   = 'hidden',\n    closeEvent    = 'close',\n    closedEvent   = 'closed',\n    slidEvent     = 'slid',\n    slideEvent    = 'slide',\n    changeEvent   = 'change',\n  \n    // other\n    getAttribute           = 'getAttribute',\n    setAttribute           = 'setAttribute',\n    hasAttribute           = 'hasAttribute',\n    createElement          = 'createElement',\n    appendChild            = 'appendChild',\n    innerHTML              = 'innerHTML',\n    getElementsByTagName   = 'getElementsByTagName',\n    preventDefault         = 'preventDefault',\n    getBoundingClientRect  = 'getBoundingClientRect',\n    querySelectorAll       = 'querySelectorAll',\n    getElementsByCLASSNAME = 'getElementsByClassName',\n    getComputedStyle       = 'getComputedStyle',  \n  \n    indexOf      = 'indexOf',\n    parentNode   = 'parentNode',\n    length       = 'length',\n    toLowerCase  = 'toLowerCase',\n    Transition   = 'Transition',\n    Duration     = 'Duration',\n    Webkit       = 'Webkit',\n    style        = 'style',\n    push         = 'push',\n    tabindex     = 'tabindex',\n    contains     = 'contains',\n  \n    active     = 'active',\n    showClass  = 'show',\n    collapsing = 'collapsing',\n    disabled   = 'disabled',\n    loading    = 'loading',\n    left       = 'left',\n    right      = 'right',\n    top        = 'top',\n    bottom     = 'bottom',\n  \n    // tooltip / popover\n    tipPositions = /\\b(top|bottom|left|right)+/,\n  \n    // modal\n    modalOverlay = 0,\n    fixedTop = 'fixed-top',\n    fixedBottom = 'fixed-bottom',\n  \n    // transitionEnd since 2.0.4\n    supportTransitions = Webkit+Transition in HTML[style] || Transition[toLowerCase]() in HTML[style],\n    transitionEndEvent = Webkit+Transition in HTML[style] ? Webkit[toLowerCase]()+Transition+'End' : Transition[toLowerCase]()+'end',\n    transitionDuration = Webkit+Duration in HTML[style] ? Webkit[toLowerCase]()+Transition+Duration : Transition[toLowerCase]()+Duration,\n  \n    // set new focus element since 2.0.3\n    setFocus = function(element){\n      element.focus ? element.focus() : element.setActive();\n    },\n  \n    // class manipulation, since 2.0.0 requires polyfill.js\n    addClass = function(element,classNAME) {\n      element.classList.add(classNAME);\n    },\n    removeClass = function(element,classNAME) {\n      element.classList.remove(classNAME);\n    },\n    hasClass = function(element,classNAME){ // since 2.0.0\n      return element.classList[contains](classNAME);\n    },\n  \n    // selection methods\n    getElementsByClassName = function(element,classNAME) { // returns Array\n      return [].slice.call(element[getElementsByCLASSNAME]( classNAME ));\n    },\n    queryElement = function (selector, parent) {\n      var lookUp = parent ? parent : DOC;\n      return typeof selector === 'object' ? selector : lookUp.querySelector(selector);\n    },\n    getClosest = function (element, selector) { //element is the element and selector is for the closest parent element to find\n      // source http://gomakethings.com/climbing-up-and-down-the-dom-tree-with-vanilla-javascript/\n      var firstChar = selector.charAt(0), selectorSubstring = selector.substr(1);\n      if ( firstChar === '.' ) {// If selector is a class\n        for ( ; element && element !== DOC; element = element[parentNode] ) { // Get closest match\n          if ( queryElement(selector,element[parentNode]) !== null && hasClass(element,selectorSubstring) ) { return element; }\n        }\n      } else if ( firstChar === '#' ) { // If selector is an ID\n        for ( ; element && element !== DOC; element = element[parentNode] ) { // Get closest match\n          if ( element.id === selectorSubstring ) { return element; }\n        }\n      }\n      return false;\n    },\n  \n    // event attach jQuery style / trigger  since 1.2.0\n    on = function (element, event, handler, options) {\n      options = options || false;\n      element.addEventListener(event, handler, options);\n    },\n    off = function(element, event, handler, options) {\n      options = options || false;\n      element.removeEventListener(event, handler, options);\n    },\n    one = function (element, event, handler, options) { // one since 2.0.4\n      on(element, event, function handlerWrapper(e){\n        handler(e);\n        off(element, event, handlerWrapper, options);\n      }, options);\n    },\n    // determine support for passive events\n    supportPassive = (function(){\n      // Test via a getter in the options object to see if the passive property is accessed\n      var result = false;\n      try {\n        var opts = Object.defineProperty({}, 'passive', {\n          get: function() {\n            result = true;\n          }\n        });\n        one(globalObject, 'testPassive', null, opts);\n      } catch (e) {}\n  \n      return result;\n    }()),\n    // event options\n    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n    passiveHandler = supportPassive ? { passive: true } : false,\n    // transitions\n    getTransitionDurationFromElement = function(element) {\n      var duration = supportTransitions ? globalObject[getComputedStyle](element)[transitionDuration] : 0;\n      duration = parseFloat(duration);\n      duration = typeof duration === 'number' && !isNaN(duration) ? duration * 1000 : 0;\n      return duration; // we take a short offset to make sure we fire on the next frame after animation\n    },\n    emulateTransitionEnd = function(element,handler){ // emulateTransitionEnd since 2.0.4\n      var called = 0, duration = getTransitionDurationFromElement(element);\n      duration ? one(element, transitionEndEvent, function(e){ !called && handler(e), called = 1; })\n               : setTimeout(function() { !called && handler(), called = 1; }, 17);\n    },\n    bootstrapCustomEvent = function (eventName, componentName, related) {\n      var OriginalCustomEvent = new CustomEvent( eventName + '.bs.' + componentName);\n      OriginalCustomEvent.relatedTarget = related;\n      this.dispatchEvent(OriginalCustomEvent);\n    },\n  \n    // tooltip / popover stuff\n    getScroll = function() { // also Affix and ScrollSpy uses it\n      return {\n        y : globalObject.pageYOffset || HTML[scrollTop],\n        x : globalObject.pageXOffset || HTML[scrollLeft]\n      }\n    },\n    styleTip = function(link,element,position,parent) { // both popovers and tooltips (target,tooltip,placement,elementToAppendTo)\n      var elementDimensions = { w : element[offsetWidth], h: element[offsetHeight] },\n          windowWidth = (HTML[clientWidth] || DOC[body][clientWidth]),\n          windowHeight = (HTML[clientHeight] || DOC[body][clientHeight]),\n          rect = link[getBoundingClientRect](),\n          scroll = parent === DOC[body] ? getScroll() : { x: parent[offsetLeft] + parent[scrollLeft], y: parent[offsetTop] + parent[scrollTop] },\n          linkDimensions = { w: rect[right] - rect[left], h: rect[bottom] - rect[top] },\n          isPopover = hasClass(element,'popover'),\n          topPosition, leftPosition,\n  \n          arrow = queryElement('.arrow',element),\n          arrowTop, arrowLeft, arrowWidth, arrowHeight,\n  \n          halfTopExceed = rect[top] + linkDimensions.h/2 - elementDimensions.h/2 < 0,\n          halfLeftExceed = rect[left] + linkDimensions.w/2 - elementDimensions.w/2 < 0,\n          halfRightExceed = rect[left] + elementDimensions.w/2 + linkDimensions.w/2 >= windowWidth,\n          halfBottomExceed = rect[top] + elementDimensions.h/2 + linkDimensions.h/2 >= windowHeight,\n          topExceed = rect[top] - elementDimensions.h < 0,\n          leftExceed = rect[left] - elementDimensions.w < 0,\n          bottomExceed = rect[top] + elementDimensions.h + linkDimensions.h >= windowHeight,\n          rightExceed = rect[left] + elementDimensions.w + linkDimensions.w >= windowWidth;\n  \n      // recompute position\n      position = (position === left || position === right) && leftExceed && rightExceed ? top : position; // first, when both left and right limits are exceeded, we fall back to top|bottom\n      position = position === top && topExceed ? bottom : position;\n      position = position === bottom && bottomExceed ? top : position;\n      position = position === left && leftExceed ? right : position;\n      position = position === right && rightExceed ? left : position;\n  \n      // update tooltip/popover class\n      element.className[indexOf](position) === -1 && (element.className = element.className.replace(tipPositions,position));\n  \n      // we check the computed width & height and update here\n      arrowWidth = arrow[offsetWidth]; arrowHeight = arrow[offsetHeight];\n  \n      // apply styling to tooltip or popover\n      if ( position === left || position === right ) { // secondary|side positions\n        if ( position === left ) { // LEFT\n          leftPosition = rect[left] + scroll.x - elementDimensions.w - ( isPopover ? arrowWidth : 0 );\n        } else { // RIGHT\n          leftPosition = rect[left] + scroll.x + linkDimensions.w;\n        }\n  \n        // adjust top and arrow\n        if (halfTopExceed) {\n          topPosition = rect[top] + scroll.y;\n          arrowTop = linkDimensions.h/2 - arrowWidth;\n        } else if (halfBottomExceed) {\n          topPosition = rect[top] + scroll.y - elementDimensions.h + linkDimensions.h;\n          arrowTop = elementDimensions.h - linkDimensions.h/2 - arrowWidth;\n        } else {\n          topPosition = rect[top] + scroll.y - elementDimensions.h/2 + linkDimensions.h/2;\n          arrowTop = elementDimensions.h/2 - (isPopover ? arrowHeight*0.9 : arrowHeight/2);\n        }\n      } else if ( position === top || position === bottom ) { // primary|vertical positions\n        if ( position === top) { // TOP\n          topPosition =  rect[top] + scroll.y - elementDimensions.h - ( isPopover ? arrowHeight : 0 );\n        } else { // BOTTOM\n          topPosition = rect[top] + scroll.y + linkDimensions.h;\n        }\n        // adjust left | right and also the arrow\n        if (halfLeftExceed) {\n          leftPosition = 0;\n          arrowLeft = rect[left] + linkDimensions.w/2 - arrowWidth;\n        } else if (halfRightExceed) {\n          leftPosition = windowWidth - elementDimensions.w*1.01;\n          arrowLeft = elementDimensions.w - ( windowWidth - rect[left] ) + linkDimensions.w/2 - arrowWidth/2;\n        } else {\n          leftPosition = rect[left] + scroll.x - elementDimensions.w/2 + linkDimensions.w/2;\n          arrowLeft = elementDimensions.w/2 - ( isPopover ? arrowWidth : arrowWidth/2 );\n        }\n      }\n  \n      // apply style to tooltip/popover and its arrow\n      element[style][top] = topPosition + 'px';\n      element[style][left] = leftPosition + 'px';\n  \n      arrowTop && (arrow[style][top] = arrowTop + 'px');\n      arrowLeft && (arrow[style][left] = arrowLeft + 'px');\n    };\n  \n  BSN.version = '2.0.27';\n  \n  /* Native Javascript for Bootstrap 4 | Alert\n  -------------------------------------------*/\n  \n  // ALERT DEFINITION\n  // ================\n  var Alert = function( element ) {\n    \n    // initialization element\n    element = queryElement(element);\n  \n    // bind, target alert, duration and stuff\n    var self = this, component = 'alert',\n      alert = getClosest(element,'.'+component),\n      triggerHandler = function(){ hasClass(alert,'fade') ? emulateTransitionEnd(alert,transitionEndHandler) : transitionEndHandler(); },\n      // handlers\n      clickHandler = function(e){\n        alert = getClosest(e[target],'.'+component);\n        element = queryElement('['+dataDismiss+'=\"'+component+'\"]',alert);\n        element && alert && (element === e[target] || element[contains](e[target])) && self.close();\n      },\n      transitionEndHandler = function(){\n        bootstrapCustomEvent.call(alert, closedEvent, component);\n        off(element, clickEvent, clickHandler); // detach it's listener\n        alert[parentNode].removeChild(alert);\n      };\n    \n    // public method\n    this.close = function() {\n      if ( alert && element && hasClass(alert,showClass) ) {\n        bootstrapCustomEvent.call(alert, closeEvent, component);\n        removeClass(alert,showClass);\n        alert && triggerHandler();\n      }\n    };\n  \n    // init\n    if ( !(stringAlert in element ) ) { // prevent adding event handlers twice\n      on(element, clickEvent, clickHandler);\n    }\n    element[stringAlert] = self;\n  };\n  \n  // ALERT DATA API\n  // ==============\n  supports[push]([stringAlert, Alert, '['+dataDismiss+'=\"alert\"]']);\n  \n  \n  /* Native Javascript for Bootstrap 4 | Button\n  ---------------------------------------------*/\n  \n  // BUTTON DEFINITION\n  // ===================\n  var Button = function( element ) {\n  \n    // initialization element\n    element = queryElement(element);\n  \n    // constant\n    var toggled = false, // toggled makes sure to prevent triggering twice the change.bs.button events\n  \n        // strings\n        component = 'button',\n        checked = 'checked',\n        LABEL = 'LABEL',\n        INPUT = 'INPUT',\n  \n      // private methods\n      keyHandler = function(e){ \n        var key = e.which || e.keyCode;\n        key === 32 && e[target] === DOC.activeElement && toggle(e);\n      },\n      preventScroll = function(e){ \n        var key = e.which || e.keyCode;\n        key === 32 && e[preventDefault]();\n      },\n      toggle = function(e) {\n        var label = e[target].tagName === LABEL ? e[target] : e[target][parentNode].tagName === LABEL ? e[target][parentNode] : null; // the .btn label\n        \n        if ( !label ) return; //react if a label or its immediate child is clicked\n  \n        var labels = getElementsByClassName(label[parentNode],'btn'), // all the button group buttons\n          input = label[getElementsByTagName](INPUT)[0];\n  \n        if ( !input ) return; // return if no input found\n  \n        // manage the dom manipulation\n        if ( input.type === 'checkbox' ) { //checkboxes\n          if ( !input[checked] ) {\n            addClass(label,active);\n            input[getAttribute](checked);\n            input[setAttribute](checked,checked);\n            input[checked] = true;\n          } else {\n            removeClass(label,active);\n            input[getAttribute](checked);\n            input.removeAttribute(checked);\n            input[checked] = false;\n          }\n  \n          if (!toggled) { // prevent triggering the event twice\n            toggled = true;\n            bootstrapCustomEvent.call(input, changeEvent, component); //trigger the change for the input\n            bootstrapCustomEvent.call(element, changeEvent, component); //trigger the change for the btn-group\n          }\n        }\n  \n        if ( input.type === 'radio' && !toggled ) { // radio buttons\n          // don't trigger if already active (the OR condition is a hack to check if the buttons were selected with key press and NOT mouse click)\n          if ( !input[checked] || (e.screenX === 0 && e.screenY == 0) ) {\n            addClass(label,active);\n            addClass(label,focusEvent);\n            input[setAttribute](checked,checked);\n            input[checked] = true;\n            bootstrapCustomEvent.call(input, changeEvent, component); //trigger the change for the input\n            bootstrapCustomEvent.call(element, changeEvent, component); //trigger the change for the btn-group\n  \n            toggled = true;\n            for (var i = 0, ll = labels[length]; i<ll; i++) {\n              var otherLabel = labels[i], otherInput = otherLabel[getElementsByTagName](INPUT)[0];\n              if ( otherLabel !== label && hasClass(otherLabel,active) )  {\n                removeClass(otherLabel,active);\n                otherInput.removeAttribute(checked);\n                otherInput[checked] = false;\n                bootstrapCustomEvent.call(otherInput, changeEvent, component); // trigger the change\n              }\n            }\n          }\n        }\n        setTimeout( function() { toggled = false; }, 50 );\n      },\n      focusHandler = function(e) {\n        addClass(e[target][parentNode],focusEvent);\n      },\n      blurHandler = function(e) {\n        removeClass(e[target][parentNode],focusEvent);\n      };\n  \n    // init\n    if ( !( stringButton in element ) ) { // prevent adding event handlers twice\n      on( element, clickEvent, toggle );\n      on( element, keyupEvent, keyHandler ), on( element, keydownEvent, preventScroll );\n  \n      var allBtns = getElementsByClassName(element, 'btn');\n      for (var i=0; i<allBtns.length; i++) {\n        var input = allBtns[i][getElementsByTagName](INPUT)[0];\n        on( input, focusEvent, focusHandler), on( input, 'blur', blurHandler);\n      }    \n    }\n  \n    // activate items on load\n    var labelsToACtivate = getElementsByClassName(element, 'btn'), lbll = labelsToACtivate[length];\n    for (var i=0; i<lbll; i++) {\n      !hasClass(labelsToACtivate[i],active) && queryElement('input:checked',labelsToACtivate[i]) \n                                            && addClass(labelsToACtivate[i],active);\n    }\n    element[stringButton] = this;\n  };\n  \n  // BUTTON DATA API\n  // =================\n  supports[push]( [ stringButton, Button, '['+dataToggle+'=\"buttons\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Carousel\n  ----------------------------------------------*/\n  \n  // CAROUSEL DEFINITION\n  // ===================\n  var Carousel = function( element, options ) {\n  \n    // initialization element\n    element = queryElement( element );\n  \n    // set options\n    options = options || {};\n  \n    // DATA API\n    var intervalAttribute = element[getAttribute](dataInterval),\n        intervalOption = options[interval],\n        intervalData = intervalAttribute === 'false' ? 0 : parseInt(intervalAttribute),  \n        pauseData = element[getAttribute](dataPause) === hoverEvent || false,\n        keyboardData = element[getAttribute](dataKeyboard) === 'true' || false,\n      \n        // strings\n        component = 'carousel',\n        paused = 'paused',\n        direction = 'direction',\n        carouselItem = 'carousel-item',\n        dataSlideTo = 'data-slide-to'; \n  \n    this[keyboard] = options[keyboard] === true || keyboardData;\n    this[pause] = (options[pause] === hoverEvent || pauseData) ? hoverEvent : false; // false / hover\n  \n    this[interval] = typeof intervalOption === 'number' ? intervalOption\n                   : intervalOption === false || intervalData === 0 || intervalData === false ? 0\n                   : isNaN(intervalData) ? 5000 // bootstrap carousel default interval\n                   : intervalData;\n  \n    // bind, event targets\n    var self = this, index = element.index = 0, timer = element.timer = 0, \n      isSliding = false, // isSliding prevents click event handlers when animation is running\n      isTouch = false, startXPosition = null, currentXPosition = null, endXPosition = null, // touch and event coordinates\n      slides = getElementsByClassName(element,carouselItem), total = slides[length],\n      slideDirection = this[direction] = left,\n      leftArrow = getElementsByClassName(element,component+'-control-prev')[0], \n      rightArrow = getElementsByClassName(element,component+'-control-next')[0],\n      indicator = queryElement( '.'+component+'-indicators', element ),\n      indicators = indicator && indicator[getElementsByTagName]( \"LI\" ) || [];\n  \n    // invalidate when not enough items\n    if (total < 2) { return; }\n  \n    // handlers\n    var pauseHandler = function () {\n        if ( self[interval] !==false && !hasClass(element,paused) ) {\n          addClass(element,paused);\n          !isSliding && ( clearInterval(timer), timer = null );\n        }\n      },\n      resumeHandler = function() {\n        if ( self[interval] !== false && hasClass(element,paused) ) {\n          removeClass(element,paused);\n          !isSliding && ( clearInterval(timer), timer = null );\n          !isSliding && self.cycle();\n        }\n      },\n      indicatorHandler = function(e) {\n        e[preventDefault]();\n        if (isSliding) return;\n  \n        var eventTarget = e[target]; // event target | the current active item\n  \n        if ( eventTarget && !hasClass(eventTarget,active) && eventTarget[getAttribute](dataSlideTo) ) {\n          index = parseInt( eventTarget[getAttribute](dataSlideTo), 10 );\n        } else { return false; }\n  \n        self.slideTo( index ); //Do the slide\n      },\n      controlsHandler = function (e) {\n        e[preventDefault]();\n        if (isSliding) return;\n  \n        var eventTarget = e.currentTarget || e.srcElement;\n  \n        if ( eventTarget === rightArrow ) {\n          index++;\n        } else if ( eventTarget === leftArrow ) {\n          index--;\n        }\n  \n        self.slideTo( index ); //Do the slide\n      },\n      keyHandler = function (e) {\n        if (isSliding) return;\n        switch (e.which) {\n          case 39:\n            index++;\n            break;\n          case 37:\n            index--;\n            break;\n          default: return;\n        }\n        self.slideTo( index ); //Do the slide\n      },\n      // touch events\n      toggleTouchEvents = function(toggle){\n        toggle( element, touchEvents.move, touchMoveHandler, passiveHandler );\n        toggle( element, touchEvents.end, touchEndHandler, passiveHandler );\n    },  \n      touchDownHandler = function(e) {\n        if ( isTouch ) { return; } \n          \n        startXPosition = parseInt(e.touches[0].pageX);\n  \n        if ( element.contains(e[target]) ) {\n          isTouch = true;\n          toggleTouchEvents(on);\n        }\n      },\n      touchMoveHandler = function(e) {\n        if ( !isTouch ) { e.preventDefault(); return; }\n  \n        currentXPosition = parseInt(e.touches[0].pageX);\n        \n        //cancel touch if more than one touches detected\n        if ( e.type === 'touchmove' && e.touches[length] > 1 ) {\n          e.preventDefault();\n          return false;\n        }\n      },\n      touchEndHandler = function(e) {\n        if ( !isTouch || isSliding ) { return }\n        \n        endXPosition = currentXPosition || parseInt( e.touches[0].pageX );\n  \n        if ( isTouch ) {\n          if ( (!element.contains(e[target]) || !element.contains(e.relatedTarget) ) && Math.abs(startXPosition - endXPosition) < 75 ) {\n            return false;\n          } else {\n            if ( currentXPosition < startXPosition ) {\n              index++;\n            } else if ( currentXPosition > startXPosition ) {\n              index--;        \n            }\n            isTouch = false;\n            self.slideTo(index);\n          }\n          toggleTouchEvents(off);            \n        }\n      },\n  \n      // private methods\n      isElementInScrollRange = function () {\n        var rect = element[getBoundingClientRect](),\n          viewportHeight = globalObject[innerHeight] || HTML[clientHeight]\n        return rect[top] <= viewportHeight && rect[bottom] >= 0; // bottom && top\n      },    \n      setActivePage = function( pageIndex ) { //indicators\n        for ( var i = 0, icl = indicators[length]; i < icl; i++ ) {\n          removeClass(indicators[i],active);\n        }\n        if (indicators[pageIndex]) addClass(indicators[pageIndex], active);\n      };\n  \n  \n    // public methods\n    this.cycle = function() {\n      if (timer) {\n        clearInterval(timer);\n        timer = null;\n      }\n  \n      timer = setInterval(function() {\n        isElementInScrollRange() && (index++, self.slideTo( index ) );\n      }, this[interval]);\n    };\n    this.slideTo = function( next ) {\n      if (isSliding) return; // when controled via methods, make sure to check again      \n      \n      var activeItem = this.getActiveIndex(), // the current active\n          orientation;\n      \n      // first return if we're on the same item #227\n      if ( activeItem === next ) {\n        return;\n      // or determine slideDirection\n      } else if  ( (activeItem < next ) || (activeItem === 0 && next === total -1 ) ) {\n        slideDirection = self[direction] = left; // next\n      } else if  ( (activeItem > next) || (activeItem === total - 1 && next === 0 ) ) {\n        slideDirection = self[direction] = right; // prev\n      }\n  \n      // find the right next index \n      if ( next < 0 ) { next = total - 1; } \n      else if ( next >= total ){ next = 0; }\n  \n      // update index\n      index = next;\n  \n      orientation = slideDirection === left ? 'next' : 'prev'; //determine type\n      bootstrapCustomEvent.call(element, slideEvent, component, slides[next]); // here we go with the slide\n  \n      isSliding = true;\n      clearInterval(timer);\n      timer = null;\n      setActivePage( next );\n  \n      if ( supportTransitions && hasClass(element,'slide') ) {\n  \n        addClass(slides[next],carouselItem +'-'+ orientation);\n        slides[next][offsetWidth];\n        addClass(slides[next],carouselItem +'-'+ slideDirection);\n        addClass(slides[activeItem],carouselItem +'-'+ slideDirection);\n  \n        emulateTransitionEnd(slides[next], function(e) {\n          var timeout = e && e[target] !== slides[next] ? e.elapsedTime*1000+100 : 20;\n          \n          isSliding && setTimeout(function(){\n            isSliding = false;\n  \n            addClass(slides[next],active);\n            removeClass(slides[activeItem],active);\n  \n            removeClass(slides[next],carouselItem +'-'+ orientation);\n            removeClass(slides[next],carouselItem +'-'+ slideDirection);\n            removeClass(slides[activeItem],carouselItem +'-'+ slideDirection);\n  \n            bootstrapCustomEvent.call(element, slidEvent, component, slides[next]);\n  \n            if ( !DOC.hidden && self[interval] && !hasClass(element,paused) ) {\n              self.cycle();\n            }\n          }, timeout);\n        });\n  \n      } else {\n        addClass(slides[next],active);\n        slides[next][offsetWidth];\n        removeClass(slides[activeItem],active);\n        setTimeout(function() {\n          isSliding = false;\n          if ( self[interval] && !hasClass(element,paused) ) {\n            self.cycle();\n          }\n          bootstrapCustomEvent.call(element, slidEvent, component, slides[next]);\n        }, 100 );\n      }\n    };\n    this.getActiveIndex = function () {\n      return slides[indexOf](getElementsByClassName(element,carouselItem+' active')[0]) || 0;\n    };\n  \n    // init\n    if ( !(stringCarousel in element ) ) { // prevent adding event handlers twice\n  \n      if ( self[pause] && self[interval] ) {\n        on( element, mouseHover[0], pauseHandler );\n        on( element, mouseHover[1], resumeHandler );\n        on( element, touchEvents.start, pauseHandler, passiveHandler );\n        on( element, touchEvents.end, resumeHandler, passiveHandler );\n      }\n    \n      slides[length] > 1 && on( element, touchEvents.start, touchDownHandler, passiveHandler );\n  \n      rightArrow && on( rightArrow, clickEvent, controlsHandler );\n      leftArrow && on( leftArrow, clickEvent, controlsHandler );\n    \n      indicator && on( indicator, clickEvent, indicatorHandler );\n      self[keyboard] && on( globalObject, keydownEvent, keyHandler );\n  \n    }\n    if (self.getActiveIndex()<0) {\n      slides[length] && addClass(slides[0],active);\n      indicators[length] && setActivePage(0);\n    }\n  \n    if ( self[interval] ){ self.cycle(); }\n    element[stringCarousel] = self;\n  };\n  \n  // CAROUSEL DATA API\n  // =================\n  supports[push]( [ stringCarousel, Carousel, '['+dataRide+'=\"carousel\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Collapse\n  -----------------------------------------------*/\n  \n  // COLLAPSE DEFINITION\n  // ===================\n  var Collapse = function( element, options ) {\n  \n    // initialization element\n    element = queryElement(element);\n  \n    // set options\n    options = options || {};\n  \n    // event targets and constants\n    var accordion = null, collapse = null, self = this, \n      accordionData = element[getAttribute]('data-parent'),\n      activeCollapse, activeElement,\n  \n      // component strings\n      component = 'collapse',\n      collapsed = 'collapsed',\n      isAnimating = 'isAnimating',\n  \n      // private methods\n      openAction = function(collapseElement,toggle) {\n        bootstrapCustomEvent.call(collapseElement, showEvent, component);\n        collapseElement[isAnimating] = true;\n        addClass(collapseElement,collapsing);\n        removeClass(collapseElement,component);\n        collapseElement[style][height] = collapseElement[scrollHeight] + 'px';\n        \n        emulateTransitionEnd(collapseElement, function() {\n          collapseElement[isAnimating] = false;\n          collapseElement[setAttribute](ariaExpanded,'true');\n          toggle[setAttribute](ariaExpanded,'true');\n          removeClass(collapseElement,collapsing);\n          addClass(collapseElement, component);\n          addClass(collapseElement,showClass);\n          collapseElement[style][height] = '';\n          bootstrapCustomEvent.call(collapseElement, shownEvent, component);\n        });\n      },\n      closeAction = function(collapseElement,toggle) {\n        bootstrapCustomEvent.call(collapseElement, hideEvent, component);\n        collapseElement[isAnimating] = true;\n        collapseElement[style][height] = collapseElement[scrollHeight] + 'px'; // set height first\n        removeClass(collapseElement,component);\n        removeClass(collapseElement,showClass);\n        addClass(collapseElement,collapsing);\n        collapseElement[offsetWidth]; // force reflow to enable transition\n        collapseElement[style][height] = '0px';\n        \n        emulateTransitionEnd(collapseElement, function() {\n          collapseElement[isAnimating] = false;\n          collapseElement[setAttribute](ariaExpanded,'false');\n          toggle[setAttribute](ariaExpanded,'false');\n          removeClass(collapseElement,collapsing);\n          addClass(collapseElement,component);\n          collapseElement[style][height] = '';\n          bootstrapCustomEvent.call(collapseElement, hiddenEvent, component);\n        });\n      },\n      getTarget = function() {\n        var href = element.href && element[getAttribute]('href'),\n          parent = element[getAttribute](dataTarget),\n          id = href || ( parent && parent.charAt(0) === '#' ) && parent;\n        return id && queryElement(id);\n      };\n    \n    // public methods\n    this.toggle = function(e) {\n      e[preventDefault]();\n      if (!hasClass(collapse,showClass)) { self.show(); } \n      else { self.hide(); }\n    };\n    this.hide = function() {\n      if ( collapse[isAnimating] ) return;    \n      closeAction(collapse,element);\n      addClass(element,collapsed);\n    };\n    this.show = function() {\n      if ( accordion ) {\n        activeCollapse = queryElement('.'+component+'.'+showClass,accordion);\n        activeElement = activeCollapse && (queryElement('['+dataTarget+'=\"#'+activeCollapse.id+'\"]',accordion)\n                      || queryElement('[href=\"#'+activeCollapse.id+'\"]',accordion) );\n      }\n  \n      if ( !collapse[isAnimating] || activeCollapse && !activeCollapse[isAnimating] ) {\n        if ( activeElement && activeCollapse !== collapse ) {\n          closeAction(activeCollapse,activeElement); \n          addClass(activeElement,collapsed);\n        }\n        openAction(collapse,element);\n        removeClass(element,collapsed);\n      }\n    };\n  \n    // init\n    if ( !(stringCollapse in element ) ) { // prevent adding event handlers twice\n      on(element, clickEvent, self.toggle);\n    }\n    collapse = getTarget();\n    collapse[isAnimating] = false;  // when true it will prevent click handlers  \n    accordion = queryElement(options.parent) || accordionData && getClosest(element, accordionData);\n    element[stringCollapse] = self;\n  };\n  \n  // COLLAPSE DATA API\n  // =================\n  supports[push]( [ stringCollapse, Collapse, '['+dataToggle+'=\"collapse\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Dropdown\n  ----------------------------------------------*/\n  \n  // DROPDOWN DEFINITION\n  // ===================\n  var Dropdown = function( element, option ) {\n      \n    // initialization element\n    element = queryElement(element);\n  \n    // set option\n    this.persist = option === true || element[getAttribute]('data-persist') === 'true' || false;\n  \n    // constants, event targets, strings\n    var self = this, children = 'children',\n      parent = element[parentNode],\n      component = 'dropdown', open = 'open',\n      relatedTarget = null,\n      menu = queryElement('.dropdown-menu', parent),\n      menuItems = (function(){\n        var set = menu[children], newSet = [];\n        for ( var i=0; i<set[length]; i++ ){\n          set[i][children][length] && (set[i][children][0].tagName === 'A' && newSet[push](set[i][children][0]));\n          set[i].tagName === 'A' && newSet[push](set[i]);\n        }\n        return newSet;\n      })(),\n  \n      // preventDefault on empty anchor links\n      preventEmptyAnchor = function(anchor){\n        (anchor.href && anchor.href.slice(-1) === '#' || anchor[parentNode] && anchor[parentNode].href \n          && anchor[parentNode].href.slice(-1) === '#') && this[preventDefault]();    \n      },\n  \n      // toggle dismissible events\n      toggleDismiss = function(){\n        var type = element[open] ? on : off;\n        type(DOC, clickEvent, dismissHandler); \n        type(DOC, keydownEvent, preventScroll);\n        type(DOC, keyupEvent, keyHandler);\n        type(DOC, focusEvent, dismissHandler, true);\n      },\n  \n      // handlers\n      dismissHandler = function(e) {\n        var eventTarget = e[target], hasData = eventTarget && (eventTarget[getAttribute](dataToggle) \n                              || eventTarget[parentNode] && getAttribute in eventTarget[parentNode] \n                              && eventTarget[parentNode][getAttribute](dataToggle));\n        if ( e.type === focusEvent && (eventTarget === element || eventTarget === menu || menu[contains](eventTarget) ) ) {\n          return;\n        }\n        if ( (eventTarget === menu || menu[contains](eventTarget)) && (self.persist || hasData) ) { return; }\n        else {\n          relatedTarget = eventTarget === element || element[contains](eventTarget) ? element : null;\n          hide();\n        }\n        preventEmptyAnchor.call(e,eventTarget);\n      },\n      clickHandler = function(e) {\n        relatedTarget = element;\n        show();\n        preventEmptyAnchor.call(e,e[target]);\n      },\n      preventScroll = function(e){\n        var key = e.which || e.keyCode;\n        if( key === 38 || key === 40 ) { e[preventDefault](); }\n      },\n      keyHandler = function(e){\n        var key = e.which || e.keyCode,\n          activeItem = DOC.activeElement,\n          idx = menuItems[indexOf](activeItem),\n          isSameElement = activeItem === element,\n          isInsideMenu = menu[contains](activeItem),\n          isMenuItem = activeItem[parentNode] === menu || activeItem[parentNode][parentNode] === menu;          \n  \n        if ( isMenuItem ) { // navigate up | down\n          idx = isSameElement ? 0 \n                              : key === 38 ? (idx>1?idx-1:0)\n                              : key === 40 ? (idx<menuItems[length]-1?idx+1:idx) : idx;\n          menuItems[idx] && setFocus(menuItems[idx]);\n        }\n        if ( (menuItems[length] && isMenuItem // menu has items\n              || !menuItems[length] && (isInsideMenu || isSameElement)  // menu might be a form\n              || !isInsideMenu ) // or the focused element is not in the menu at all\n              && element[open] && key === 27  // menu must be open\n        ) {\n          self.toggle();\n          relatedTarget = null;\n        }\n      },\n  \n      // private methods\n      show = function() {\n        bootstrapCustomEvent.call(parent, showEvent, component, relatedTarget);\n        addClass(menu,showClass);\n        addClass(parent,showClass);\n        element[setAttribute](ariaExpanded,true);\n        bootstrapCustomEvent.call(parent, shownEvent, component, relatedTarget);\n        element[open] = true;\n        off(element, clickEvent, clickHandler);\n        setTimeout(function(){\n          setFocus( menu[getElementsByTagName]('INPUT')[0] || element ); // focus the first input item | element\n          toggleDismiss();\n        },1);\n      },\n      hide = function() {\n        bootstrapCustomEvent.call(parent, hideEvent, component, relatedTarget);\n        removeClass(menu,showClass);\n        removeClass(parent,showClass);\n        element[setAttribute](ariaExpanded,false);\n        bootstrapCustomEvent.call(parent, hiddenEvent, component, relatedTarget);\n        element[open] = false;\n        toggleDismiss();\n        setFocus(element);\n        setTimeout(function(){ on(element, clickEvent, clickHandler); },1);\n      };\n  \n    // set initial state to closed\n    element[open] = false;\n  \n    // public methods\n    this.toggle = function() {\n      if (hasClass(parent,showClass) && element[open]) { hide(); } \n      else { show(); }\n    };\n  \n    // init\n    if ( !(stringDropdown in element) ) { // prevent adding event handlers twice\n      !tabindex in menu && menu[setAttribute](tabindex, '0'); // Fix onblur on Chrome | Safari\n      on(element, clickEvent, clickHandler);\n    }\n  \n    element[stringDropdown] = self;\n  };\n  \n  // DROPDOWN DATA API\n  // =================\n  supports[push]( [stringDropdown, Dropdown, '['+dataToggle+'=\"dropdown\"]'] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Modal\n  -------------------------------------------*/\n  \n  // MODAL DEFINITION\n  // ===============\n  var Modal = function(element, options) { // element can be the modal/triggering button\n  \n    // the modal (both JavaScript / DATA API init) / triggering button element (DATA API)\n    element = queryElement(element);\n  \n      // strings\n      var component = 'modal',\n        staticString = 'static',\n        modalTrigger = 'modalTrigger',\n        paddingRight = 'paddingRight',\n        modalBackdropString = 'modal-backdrop',\n        isAnimating = 'isAnimating',\n        // determine modal, triggering element\n        btnCheck = element[getAttribute](dataTarget)||element[getAttribute]('href'),\n        checkModal = queryElement( btnCheck ),\n        modal = hasClass(element,component) ? element : checkModal;\n  \n      if ( hasClass(element, component) ) { element = null; } // modal is now independent of it's triggering element\n  \n    if ( !modal ) { return; } // invalidate\n  \n    // set options\n    options = options || {};\n  \n    this[keyboard] = options[keyboard] === false || modal[getAttribute](dataKeyboard) === 'false' ? false : true;\n    this[backdrop] = options[backdrop] === staticString || modal[getAttribute](databackdrop) === staticString ? staticString : true;\n    this[backdrop] = options[backdrop] === false || modal[getAttribute](databackdrop) === 'false' ? false : this[backdrop];\n    this[animation] = hasClass(modal, 'fade') ? true : false;\n    this[content]  = options[content]; // JavaScript only\n  \n    // set an initial state of the modal\n    modal[isAnimating] = false;\n    \n    // bind, constants, event targets and other vars\n    var self = this, relatedTarget = null,\n      bodyIsOverflowing, scrollBarWidth, overlay, overlayDelay, modalTimer,\n  \n      // also find fixed-top / fixed-bottom items\n      fixedItems = getElementsByClassName(HTML,fixedTop).concat(getElementsByClassName(HTML,fixedBottom)),\n  \n      // private methods\n      getWindowWidth = function() {\n        var htmlRect = HTML[getBoundingClientRect]();\n        return globalObject[innerWidth] || (htmlRect[right] - Math.abs(htmlRect[left]));\n      },\n      setScrollbar = function () {\n        var bodyStyle = globalObject[getComputedStyle](DOC[body]),\n            bodyPad = parseInt((bodyStyle[paddingRight]), 10), itemPad;\n        if (bodyIsOverflowing) {\n          DOC[body][style][paddingRight] = (bodyPad + scrollBarWidth) + 'px';\n          modal[style][paddingRight] = scrollBarWidth+'px';\n          if (fixedItems[length]){\n            for (var i = 0; i < fixedItems[length]; i++) {\n              itemPad = globalObject[getComputedStyle](fixedItems[i])[paddingRight];\n              fixedItems[i][style][paddingRight] = ( parseInt(itemPad) + scrollBarWidth) + 'px';\n            }\n          }\n        }\n      },\n      resetScrollbar = function () {\n        DOC[body][style][paddingRight] = '';\n        modal[style][paddingRight] = '';\n        if (fixedItems[length]){\n          for (var i = 0; i < fixedItems[length]; i++) {\n            fixedItems[i][style][paddingRight] = '';\n          }\n        }\n      },\n      measureScrollbar = function () { // thx walsh\n        var scrollDiv = DOC[createElement]('div'), widthValue;\n        scrollDiv.className = component+'-scrollbar-measure'; // this is here to stay\n        DOC[body][appendChild](scrollDiv);\n        widthValue = scrollDiv[offsetWidth] - scrollDiv[clientWidth];\n        DOC[body].removeChild(scrollDiv);\n        return widthValue;\n      },\n      checkScrollbar = function () {\n        bodyIsOverflowing = DOC[body][clientWidth] < getWindowWidth();\n        scrollBarWidth = measureScrollbar();\n      },\n      createOverlay = function() {\n        var newOverlay = DOC[createElement]('div');\n        overlay = queryElement('.'+modalBackdropString);\n  \n        if ( overlay === null ) {\n          newOverlay[setAttribute]('class', modalBackdropString + (self[animation] ? ' fade' : ''));\n          overlay = newOverlay;\n          DOC[body][appendChild](overlay);\n        }\n        modalOverlay = 1;\n      },\n      removeOverlay = function() {\n        overlay = queryElement('.'+modalBackdropString);\n        if ( overlay && overlay !== null && typeof overlay === 'object' ) {\n          modalOverlay = 0;\n          DOC[body].removeChild(overlay); overlay = null;\n        }\n      },\n      // triggers\n      triggerShow = function() {\n        setFocus(modal);\n        modal[isAnimating] = false;\n        bootstrapCustomEvent.call(modal, shownEvent, component, relatedTarget);\n  \n        on(globalObject, resizeEvent, self.update, passiveHandler);\n        on(modal, clickEvent, dismissHandler);\n        on(DOC, keydownEvent, keyHandler);      \n      },\n      triggerHide = function() {\n        modal[style].display = '';\n        element && (setFocus(element));\n        bootstrapCustomEvent.call(modal, hiddenEvent, component);\n  \n        (function(){\n          if (!getElementsByClassName(DOC,component+' '+showClass)[0]) {\n            resetScrollbar();\n            removeClass(DOC[body],component+'-open');\n            overlay && hasClass(overlay,'fade') ? (removeClass(overlay,showClass), emulateTransitionEnd(overlay,removeOverlay))\n            : removeOverlay();\n  \n            off(globalObject, resizeEvent, self.update, passiveHandler);\n            off(modal, clickEvent, dismissHandler);\n            off(DOC, keydownEvent, keyHandler);\n          }\n        }());\n        modal[isAnimating] = false;\n      },\n      // handlers\n      clickHandler = function(e) {\n        if ( modal[isAnimating] ) return;\n  \n        var clickTarget = e[target];\n        clickTarget = clickTarget[hasAttribute](dataTarget) || clickTarget[hasAttribute]('href') ? clickTarget : clickTarget[parentNode];\n        if ( clickTarget === element && !hasClass(modal,showClass) ) {\n          modal[modalTrigger] = element;\n          relatedTarget = element;\n          self.show();\n          e[preventDefault]();\n        }\n      },\n      keyHandler = function(e) {\n        if ( modal[isAnimating] ) return;\n  \n        if (self[keyboard] && e.which == 27 && hasClass(modal,showClass) ) {\n          self.hide();\n        }\n      },\n      dismissHandler = function(e) {\n        if ( modal[isAnimating] ) return;\n        var clickTarget = e[target];\n  \n        if ( hasClass(modal,showClass) && ( clickTarget[parentNode][getAttribute](dataDismiss) === component\n            || clickTarget[getAttribute](dataDismiss) === component\n            || clickTarget === modal && self[backdrop] !== staticString ) ) {\n          self.hide(); relatedTarget = null;\n          e[preventDefault]();\n        }\n      };\n  \n    // public methods\n    this.toggle = function() {\n      if ( hasClass(modal,showClass) ) {this.hide();} else {this.show();}\n    };\n    this.show = function() {\n      if ( hasClass(modal,showClass) || modal[isAnimating] ) {return}\n  \n      clearTimeout(modalTimer);\n      modalTimer = setTimeout(function(){\n        modal[isAnimating] = true;\n        bootstrapCustomEvent.call(modal, showEvent, component, relatedTarget);\n  \n        // we elegantly hide any opened modal\n        var currentOpen = getElementsByClassName(DOC,component+' '+showClass)[0];\n        if (currentOpen && currentOpen !== modal) {\n          modalTrigger in currentOpen && currentOpen[modalTrigger][stringModal].hide();\n          stringModal in currentOpen && currentOpen[stringModal].hide();\n        }\n  \n        if ( self[backdrop] ) {\n          !modalOverlay && !overlay && createOverlay();\n        }\n  \n        if ( overlay && !hasClass(overlay,showClass) ) {\n          overlay[offsetWidth]; // force reflow to enable trasition\n          overlayDelay = getTransitionDurationFromElement(overlay);\n          addClass(overlay, showClass);\n        }\n  \n        setTimeout( function() {\n          modal[style].display = 'block';\n  \n          checkScrollbar();\n          setScrollbar();\n  \n          addClass(DOC[body],component+'-open');\n          addClass(modal,showClass);\n          modal[setAttribute](ariaHidden, false);\n  \n          hasClass(modal,'fade') ? emulateTransitionEnd(modal, triggerShow) : triggerShow();\n        }, supportTransitions && overlay && overlayDelay ? overlayDelay : 1);\n      },1);\n    };\n    this.hide = function() {\n      if ( modal[isAnimating] || !hasClass(modal,showClass) ) {return}\n  \n      clearTimeout(modalTimer);\n      modalTimer = setTimeout(function(){\n        modal[isAnimating] = true;    \n        bootstrapCustomEvent.call(modal, hideEvent, component);\n        overlay = queryElement('.'+modalBackdropString);\n        overlayDelay = overlay && getTransitionDurationFromElement(overlay);\n  \n        removeClass(modal,showClass);\n        modal[setAttribute](ariaHidden, true);\n  \n        setTimeout(function(){\n          hasClass(modal,'fade') ? emulateTransitionEnd(modal, triggerHide) : triggerHide();\n        }, supportTransitions && overlay && overlayDelay ? overlayDelay : 2);\n      },2)\n    };\n    this.setContent = function( content ) {\n      queryElement('.'+component+'-content',modal)[innerHTML] = content;\n    };\n    this.update = function() {\n      if (hasClass(modal,showClass)) {\n        checkScrollbar();\n        setScrollbar();\n      }\n    };\n  \n    // init\n    // prevent adding event handlers over and over\n    // modal is independent of a triggering element\n    if ( !!element && !(stringModal in element) ) {\n      on(element, clickEvent, clickHandler);\n    }\n    if ( !!self[content] ) { self.setContent( self[content] ); }\n    if (element) { element[stringModal] = self; modal[modalTrigger] = element; }\n    else { modal[stringModal] = self; }\n  };\n  \n  // DATA API\n  supports[push]( [ stringModal, Modal, '['+dataToggle+'=\"modal\"]' ] );\n  \n  /* Native Javascript for Bootstrap 4 | Popover\n  ----------------------------------------------*/\n  \n  // POPOVER DEFINITION\n  // ==================\n  var Popover = function( element, options ) {\n  \n    // initialization element\n    element = queryElement(element);\n  \n    // set options\n    options = options || {};\n  \n    // DATA API\n    var triggerData = element[getAttribute](dataTrigger), // click / hover / focus\n        animationData = element[getAttribute](dataAnimation), // true / false\n        placementData = element[getAttribute](dataPlacement),\n        dismissibleData = element[getAttribute](dataDismissible),\n        delayData = element[getAttribute](dataDelay),\n        containerData = element[getAttribute](dataContainer),\n  \n        // internal strings\n        component = 'popover',\n        template = 'template',\n        trigger = 'trigger',\n        classString = 'class',\n        div = 'div',\n        fade = 'fade',\n        dataContent = 'data-content',\n        dismissible = 'dismissible',\n        closeBtn = '<button type=\"button\" class=\"close\">Ã</button>',\n  \n        // check container\n        containerElement = queryElement(options[container]),\n        containerDataElement = queryElement(containerData),       \n        \n        // maybe the element is inside a modal\n        modal = getClosest(element,'.modal'),\n        \n        // maybe the element is inside a fixed navbar\n        navbarFixedTop = getClosest(element,'.'+fixedTop),\n        navbarFixedBottom = getClosest(element,'.'+fixedBottom);\n  \n    // set instance options\n    this[template] = options[template] ? options[template] : null; // JavaScript only\n    this[trigger] = options[trigger] ? options[trigger] : triggerData || hoverEvent;\n    this[animation] = options[animation] && options[animation] !== fade ? options[animation] : animationData || fade;\n    this[placement] = options[placement] ? options[placement] : placementData || top;\n    this[delay] = parseInt(options[delay] || delayData) || 200;\n    this[dismissible] = options[dismissible] || dismissibleData === 'true' ? true : false;\n    this[container] = containerElement ? containerElement \n                    : containerDataElement ? containerDataElement \n                    : navbarFixedTop ? navbarFixedTop\n                    : navbarFixedBottom ? navbarFixedBottom\n                    : modal ? modal : DOC[body];\n    \n    // bind, content\n    var self = this, \n        titleString = options.title || element[getAttribute](dataTitle) || null,\n        contentString = options.content || element[getAttribute](dataContent) || null;\n  \n    if ( !contentString && !this[template] ) return; // invalidate\n  \n    // constants, vars\n    var popover = null, timer = 0, placementSetting = this[placement],\n      \n      // handlers\n      dismissibleHandler = function(e) {\n        if (popover !== null && e[target] === queryElement('.close',popover)) {\n          self.hide();\n        }\n      },\n  \n      // private methods\n      removePopover = function() {\n        self[container].removeChild(popover);\n        timer = null; popover = null; \n      },\n      createPopover = function() {\n        titleString = options.title || element[getAttribute](dataTitle);\n        contentString = options.content || element[getAttribute](dataContent);\n        // fixing https://github.com/thednp/bootstrap.native/issues/233\n        contentString = !!contentString ? contentString.trim() : null;\n  \n        popover = DOC[createElement](div);\n  \n        // popover arrow\n        var popoverArrow = DOC[createElement](div);\n        popoverArrow[setAttribute](classString,'arrow');\n        popover[appendChild](popoverArrow);\n  \n        if ( contentString !== null && self[template] === null ) { //create the popover from data attributes\n  \n          popover[setAttribute]('role','tooltip');     \n  \n          if (titleString !== null) {\n            var popoverTitle = DOC[createElement]('h3');\n            popoverTitle[setAttribute](classString,component+'-header');\n  \n            popoverTitle[innerHTML] = self[dismissible] ? titleString + closeBtn : titleString;\n            popover[appendChild](popoverTitle);\n          }\n  \n          //set popover content\n          var popoverContent = DOC[createElement](div);\n          popoverContent[setAttribute](classString,component+'-body');\n          popoverContent[innerHTML] = self[dismissible] && titleString === null ? contentString + closeBtn : contentString;\n          popover[appendChild](popoverContent);\n  \n        } else {  // or create the popover from template\n          var popoverTemplate = DOC[createElement](div);\n          self[template] = self[template].trim();\n          popoverTemplate[innerHTML] = self[template];\n          popover[innerHTML] = popoverTemplate.firstChild[innerHTML];\n        }\n  \n        //append to the container\n        self[container][appendChild](popover);\n        popover[style].display = 'block';\n        popover[setAttribute](classString, component+ ' bs-' + component+'-'+placementSetting + ' ' + self[animation]);\n      },\n      showPopover = function () {\n        !hasClass(popover,showClass) && ( addClass(popover,showClass) );\n      },\n      updatePopover = function() {\n        styleTip(element, popover, placementSetting, self[container]);\n      },\n  \n      // event toggle\n      dismissHandlerToggle = function(type){\n        if (clickEvent == self[trigger] || 'focus' == self[trigger]) {\n          !self[dismissible] && type( element, 'blur', self.hide );\n        }\n        self[dismissible] && type( DOC, clickEvent, dismissibleHandler );     \n        type( globalObject, resizeEvent, self.hide, passiveHandler );\n      },\n  \n      // triggers\n      showTrigger = function() {\n        dismissHandlerToggle(on);\n        bootstrapCustomEvent.call(element, shownEvent, component);\n      },\n      hideTrigger = function() {\n        dismissHandlerToggle(off);\n        removePopover();\n        bootstrapCustomEvent.call(element, hiddenEvent, component);\n      };\n  \n    // public methods / handlers\n    this.toggle = function() {\n      if (popover === null) { self.show(); } \n      else { self.hide(); }\n    };\n    this.show = function() {\n      clearTimeout(timer);\n      timer = setTimeout( function() {\n        if (popover === null) {\n          placementSetting = self[placement]; // we reset placement in all cases\n          createPopover();\n          updatePopover();\n          showPopover();\n          bootstrapCustomEvent.call(element, showEvent, component);\n          !!self[animation] ? emulateTransitionEnd(popover, showTrigger) : showTrigger();\n        }\n      }, 20 );\n    };\n    this.hide = function() {\n      clearTimeout(timer);\n      timer = setTimeout( function() {\n        if (popover && popover !== null && hasClass(popover,showClass)) {\n          bootstrapCustomEvent.call(element, hideEvent, component);\n          removeClass(popover,showClass);\n          !!self[animation] ? emulateTransitionEnd(popover, hideTrigger) : hideTrigger();\n        }\n      }, self[delay] );\n    };\n  \n    // init\n    if ( !(stringPopover in element) ) { // prevent adding event handlers twice\n      if (self[trigger] === hoverEvent) {\n        on( element, mouseHover[0], self.show );\n        if (!self[dismissible]) { on( element, mouseHover[1], self.hide ); }\n      } else if (clickEvent == self[trigger] || 'focus' == self[trigger]) {\n        on( element, self[trigger], self.toggle );\n      }\n    }\n    element[stringPopover] = self;\n  };\n  \n  // POPOVER DATA API\n  // ================\n  supports[push]( [ stringPopover, Popover, '['+dataToggle+'=\"popover\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | ScrollSpy\n  -----------------------------------------------*/\n  \n  // SCROLLSPY DEFINITION\n  // ====================\n  var ScrollSpy = function(element, options) {\n  \n    // initialization element, the element we spy on\n    element = queryElement(element); \n  \n    // DATA API\n    var targetData = queryElement(element[getAttribute](dataTarget)),\n        offsetData = element[getAttribute]('data-offset');\n  \n    // set options\n    options = options || {};\n  \n    // invalidate\n    if ( !options[target] && !targetData ) { return; } \n  \n    // event targets, constants\n    var self = this, spyTarget = options[target] && queryElement(options[target]) || targetData,\n        links = spyTarget && spyTarget[getElementsByTagName]('A'),\n        offset = parseInt(options['offset'] || offsetData) || 10,      \n        items = [], targetItems = [], scrollOffset,\n        scrollTarget = element[offsetHeight] < element[scrollHeight] ? element : globalObject, // determine which is the real scrollTarget\n        isWindow = scrollTarget === globalObject;  \n  \n    // populate items and targets\n    for (var i=0, il=links[length]; i<il; i++) {\n      var href = links[i][getAttribute]('href'), \n          targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#' && queryElement(href);\n      if ( !!targetItem ) {\n        items[push](links[i]);\n        targetItems[push](targetItem);\n      }\n    }\n  \n    // private methods\n    var updateItem = function(index) {\n        var item = items[index],\n          targetItem = targetItems[index], // the menu item targets this element\n          dropdown = item[parentNode][parentNode],\n          dropdownLink = hasClass(dropdown,'dropdown') && dropdown[getElementsByTagName]('A')[0],\n          targetRect = isWindow && targetItem[getBoundingClientRect](),\n  \n          isActive = hasClass(item,active) || false,\n  \n          topEdge = (isWindow ? targetRect[top] + scrollOffset : targetItem[offsetTop]) - offset,\n          bottomEdge = isWindow ? targetRect[bottom] + scrollOffset - offset : targetItems[index+1] ? targetItems[index+1][offsetTop] - offset : element[scrollHeight],\n  \n          inside = scrollOffset >= topEdge && bottomEdge > scrollOffset;\n  \n        if ( !isActive && inside ) {\n          if ( !hasClass(item,active) ) {\n            addClass(item,active);\n            if (dropdownLink && !hasClass(dropdownLink,active) ) {\n              addClass(dropdownLink,active);\n            }\n            bootstrapCustomEvent.call(element, 'activate', 'scrollspy', items[index]);\n          }\n        } else if ( !inside ) {\n          if ( hasClass(item,active) ) {\n            removeClass(item,active);\n            if (dropdownLink && hasClass(dropdownLink,active) && !getElementsByClassName(item[parentNode],active).length  ) {\n              removeClass(dropdownLink,active);\n            }\n          }\n        } else if ( !inside && !isActive || isActive && inside ) {\n          return;\n        }\n      },\n      updateItems = function(){\n        scrollOffset = isWindow ? getScroll().y : element[scrollTop];\n        for (var index=0, itl=items[length]; index<itl; index++) {\n          updateItem(index)\n        }\n      };\n  \n    // public method\n    this.refresh = function () {\n      updateItems();\n    }\n  \n    // init\n    if ( !(stringScrollSpy in element) ) { // prevent adding event handlers twice\n      on( scrollTarget, scrollEvent, self.refresh, passiveHandler );\n      on( globalObject, resizeEvent, self.refresh, passiveHandler );\n    }\n    self.refresh();\n    element[stringScrollSpy] = self;\n  };\n  \n  // SCROLLSPY DATA API\n  // ==================\n  supports[push]( [ stringScrollSpy, ScrollSpy, '['+dataSpy+'=\"scroll\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Tab\n  -----------------------------------------*/\n  \n  // TAB DEFINITION\n  // ==============\n  var Tab = function( element, options ) {\n  \n    // initialization element\n    element = queryElement(element);\n  \n    // DATA API\n    var heightData = element[getAttribute](dataHeight),\n      \n        // strings\n        component = 'tab', height = 'height', float = 'float', isAnimating = 'isAnimating';\n        \n    // set options\n    options = options || {};\n    this[height] = supportTransitions ? (options[height] || heightData === 'true') : false;\n  \n    // bind, event targets\n    var self = this, next,\n      tabs = getClosest(element,'.nav'),\n      tabsContentContainer = false,\n      dropdown = tabs && queryElement('.dropdown-toggle',tabs),\n      activeTab, activeContent, nextContent, containerHeight, equalContents, nextHeight,\n      \n      // trigger\n      triggerEnd = function(){\n        tabsContentContainer[style][height] = '';\n        removeClass(tabsContentContainer,collapsing);\n        tabs[isAnimating] = false;\n      },\n      triggerShow = function() {\n        if (tabsContentContainer) { // height animation\n          if ( equalContents ) {\n            triggerEnd();\n          } else {\n            setTimeout(function(){ // enables height animation\n              tabsContentContainer[style][height] = nextHeight + 'px'; // height animation\n              tabsContentContainer[offsetWidth];\n              emulateTransitionEnd(tabsContentContainer, triggerEnd);\n            },50);\n          }\n        } else {\n          tabs[isAnimating] = false; \n        }\n        bootstrapCustomEvent.call(next, shownEvent, component, activeTab);\n      },\n      triggerHide = function() {\n        if (tabsContentContainer) {\n          activeContent[style][float] = left;\n          nextContent[style][float] = left;        \n          containerHeight = activeContent[scrollHeight];\n        }\n          \n        addClass(nextContent,active);\n        bootstrapCustomEvent.call(next, showEvent, component, activeTab);\n  \n        removeClass(activeContent,active);\n        bootstrapCustomEvent.call(activeTab, hiddenEvent, component, next);\n        \n        if (tabsContentContainer) {\n          nextHeight = nextContent[scrollHeight];\n          equalContents = nextHeight === containerHeight;\n          addClass(tabsContentContainer,collapsing);\n          tabsContentContainer[style][height] = containerHeight + 'px'; // height animation\n          tabsContentContainer[offsetHeight];\n          activeContent[style][float] = '';\n          nextContent[style][float] = '';\n        }\n  \n        if ( hasClass(nextContent, 'fade') ) {\n          setTimeout(function(){\n            addClass(nextContent,showClass);\n            emulateTransitionEnd(nextContent,triggerShow);\n          },20);\n        } else { triggerShow(); }        \n      };\n  \n    if (!tabs) return; // invalidate\n  \n    // set default animation state\n    tabs[isAnimating] = false;    \n          \n    // private methods\n    var getActiveTab = function() {\n        var activeTabs = getElementsByClassName(tabs,active), activeTab;\n        if ( activeTabs[length] === 1 && !hasClass(activeTabs[0][parentNode],'dropdown') ) {\n          activeTab = activeTabs[0];\n        } else if ( activeTabs[length] > 1 ) {\n          activeTab = activeTabs[activeTabs[length]-1];\n        }\n        return activeTab;\n      },\n      getActiveContent = function() {\n        return queryElement(getActiveTab()[getAttribute]('href'));\n      },\n      // handler \n      clickHandler = function(e) {\n        e[preventDefault]();\n        next = e[currentTarget];\n        !tabs[isAnimating] && !hasClass(next,active) && self.show();\n      };\n  \n    // public method\n    this.show = function() { // the tab we clicked is now the next tab\n      next = next || element;\n      nextContent = queryElement(next[getAttribute]('href')); //this is the actual object, the next tab content to activate\n      activeTab = getActiveTab(); \n      activeContent = getActiveContent();\n      \n      tabs[isAnimating] = true;\n      removeClass(activeTab,active);\n      activeTab[setAttribute](ariaSelected,'false');\n      addClass(next,active);\n      next[setAttribute](ariaSelected,'true');    \n  \n      if ( dropdown ) {\n        if ( !hasClass(element[parentNode],'dropdown-menu') ) {\n          if (hasClass(dropdown,active)) removeClass(dropdown,active);\n        } else {\n          if (!hasClass(dropdown,active)) addClass(dropdown,active);\n        }\n      }\n      \n      bootstrapCustomEvent.call(activeTab, hideEvent, component, next);\n  \n      if (hasClass(activeContent, 'fade')) {\n        removeClass(activeContent,showClass);\n        emulateTransitionEnd(activeContent, triggerHide);\n      } else { triggerHide(); }\n    };\n  \n    // init\n    if ( !(stringTab in element) ) { // prevent adding event handlers twice\n      on(element, clickEvent, clickHandler);\n    }\n    if (self[height]) { tabsContentContainer = getActiveContent()[parentNode]; }\n    element[stringTab] = self;\n  };\n  \n  // TAB DATA API\n  // ============\n  supports[push]( [ stringTab, Tab, '['+dataToggle+'=\"tab\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Toast\n  ---------------------------------------------*/\n  \n  // TOAST DEFINITION\n  // ==================\n  var Toast = function( element,options ) {\n  \n    // initialization element\n    element = queryElement(element);\n  \n    // set options\n    options = options || {};\n  \n    // DATA API\n    var animationData = element[getAttribute](dataAnimation),\n        autohideData = element[getAttribute](dataAutohide),\n        delayData = element[getAttribute](dataDelay),\n        \n        // strings\n        component = 'toast',\n        autohide = 'autohide',\n        animation = 'animation',\n        showing = 'showing',\n        hide = 'hide',\n        fade = 'fade';\n  \n    // set instance options\n    this[animation] = options[animation] === false || animationData === 'false' ? 0 : 1; // true by default\n    this[autohide] = options[autohide] === false || autohideData === 'false' ? 0 : 1; // true by default\n    this[delay] = parseInt(options[delay] || delayData) || 500; // 500ms default\n  \n    // bind,toast and timer\n    var self = this, timer = 0,\n        // get the toast element\n        toast = getClosest(element,'.toast');\n  \n    // private methods\n    // animation complete\n    var showComplete = function() {\n        removeClass( toast, showing );\n        addClass( toast, showClass );\n        bootstrapCustomEvent.call(toast, shownEvent, component);\n        if (self[autohide]) { self.hide(); }\n      },\n      hideComplete = function() {\n        addClass( toast, hide );\n        bootstrapCustomEvent.call(toast, hiddenEvent, component);\n      },\n      close = function() {\n        removeClass( toast,showClass );\n        self[animation] ? emulateTransitionEnd(toast, hideComplete) : hideComplete();\n      },\n      disposeComplete = function(){\n        clearTimeout(timer); timer = null;\n        addClass( toast, hide );\n        off(element, clickEvent, self.hide);\n        element[stringToast] = null;\n        element = null;\n        toast = null;\n      };\n  \n    // public methods\n    this.show = function() {\n      if (toast) {\n        bootstrapCustomEvent.call(toast, showEvent, component);\n        self[animation] && addClass( toast,fade );\n        removeClass( toast,hide );\n        addClass( toast,showing );\n  \n        self[animation] ? emulateTransitionEnd(toast, showComplete) : showComplete();\n      }\n    };\n    this.hide = function(noTimer) {\n      if (toast && hasClass(toast,showClass)) {\n        bootstrapCustomEvent.call(toast, hideEvent, component);\n  \n        if (noTimer) {\n          close();\n        } else {\n          timer = setTimeout( close, self[delay]);\n        }\n      }\n    };\n    this.dispose = function() {\n      if ( toast && hasClass(toast,showClass) ) {\n        removeClass( toast,showClass );\n        self[animation] ? emulateTransitionEnd(toast, disposeComplete) : disposeComplete();\n      }\n    };\n  \n    // init\n    if ( !(stringToast in element) ) { // prevent adding event handlers twice\n      on(element, clickEvent, self.hide);\n    }\n    element[stringToast] = self;\n  };\n  \n  // TOAST DATA API\n  // =================\n  supports[push]( [ stringToast, Toast, '['+dataDismiss+'=\"toast\"]' ] );\n  \n  \n  /* Native Javascript for Bootstrap 4 | Tooltip\n  ---------------------------------------------*/\n  \n  // TOOLTIP DEFINITION\n  // ==================\n  var Tooltip = function( element,options ) {\n  \n    // initialization element\n    element = queryElement(element);\n  \n    // set options\n    options = options || {};\n  \n    // DATA API\n    var animationData = element[getAttribute](dataAnimation),\n        placementData = element[getAttribute](dataPlacement),\n        delayData = element[getAttribute](dataDelay),\n        containerData = element[getAttribute](dataContainer),\n        \n        // strings\n        component = 'tooltip',\n        classString = 'class',\n        title = 'title',\n        fade = 'fade',\n        div = 'div',\n  \n        // check container\n        containerElement = queryElement(options[container]),\n        containerDataElement = queryElement(containerData),      \n  \n        // maybe the element is inside a modal\n        modal = getClosest(element,'.modal'),\n        \n        // maybe the element is inside a fixed navbar\n        navbarFixedTop = getClosest(element,'.'+fixedTop),\n        navbarFixedBottom = getClosest(element,'.'+fixedBottom);\n  \n    // set instance options\n    this[animation] = options[animation] && options[animation] !== fade ? options[animation] : animationData || fade;\n    this[placement] = options[placement] ? options[placement] : placementData || top;\n    this[delay] = parseInt(options[delay] || delayData) || 200;\n    this[container] = containerElement ? containerElement \n                    : containerDataElement ? containerDataElement\n                    : navbarFixedTop ? navbarFixedTop\n                    : navbarFixedBottom ? navbarFixedBottom\n                    : modal ? modal : DOC[body];\n  \n    // bind, event targets, title and constants\n    var self = this, timer = 0, placementSetting = this[placement], tooltip = null,\n        titleString = element[getAttribute](title) || element[getAttribute](dataTitle) || element[getAttribute](dataOriginalTitle);\n  \n    if ( !titleString || titleString == \"\" ) return; // invalidate\n  \n    // private methods\n    var removeToolTip = function() {\n        self[container].removeChild(tooltip);\n        tooltip = null; timer = null;\n      },\n      createToolTip = function() {\n        titleString = element[getAttribute](title) || element[getAttribute](dataTitle) || element[getAttribute](dataOriginalTitle); // read the title again\n  \n        if ( titleString && titleString !== \"\" ) { // invalidate, maybe markup changed\n          tooltip = DOC[createElement](div);\n          tooltip[setAttribute]('role',component);\n          tooltip[style][left] = '0';\n          tooltip[style][top] = '0';        \n  \n          // tooltip arrow\n          var tooltipArrow = DOC[createElement](div);\n          tooltipArrow[setAttribute](classString,'arrow');\n          tooltip[appendChild](tooltipArrow);\n      \n          var tooltipInner = DOC[createElement](div);\n          tooltipInner[setAttribute](classString,component+'-inner');\n          tooltip[appendChild](tooltipInner);\n          tooltipInner[innerHTML] = titleString;\n  \n          self[container][appendChild](tooltip);\n          tooltip[setAttribute](classString, component + ' bs-' + component+'-'+placementSetting + ' ' + self[animation]);\n        }\n      },\n      updateTooltip = function () {\n        styleTip(element, tooltip, placementSetting, self[container]);\n      },\n      showTooltip = function () {\n        !hasClass(tooltip,showClass) && ( addClass(tooltip,showClass) );\n      },\n      // triggers\n      showTrigger = function() {\n        on( globalObject, resizeEvent, self.hide, passiveHandler );\n        bootstrapCustomEvent.call(element, shownEvent, component);\n      },\n      hideTrigger = function() {\n        off( globalObject, resizeEvent, self.hide, passiveHandler );\n        removeToolTip();\n        bootstrapCustomEvent.call(element, hiddenEvent, component);\n      };\n  \n    // public methods\n    this.show = function() {\n      clearTimeout(timer);\n      timer = setTimeout( function() {\n        if (tooltip === null) {\n          placementSetting = self[placement]; // we reset placement in all cases\n          // if(createToolTip() == false) return;\n          if(createToolTip() !== false) {\n            updateTooltip();\n            showTooltip();\n            bootstrapCustomEvent.call(element, showEvent, component);\n            !!self[animation] ? emulateTransitionEnd(tooltip, showTrigger) : showTrigger();          \n          }\n        }\n      }, 20 );\n    };\n    this.hide = function() {\n      clearTimeout(timer);\n      timer = setTimeout( function() {\n        if (tooltip && hasClass(tooltip,showClass)) {\n          bootstrapCustomEvent.call(element, hideEvent, component);\n          removeClass(tooltip,showClass);\n          !!self[animation] ? emulateTransitionEnd(tooltip, hideTrigger) : hideTrigger();\n        }\n      }, self[delay]);\n    };\n    this.toggle = function() {\n      if (!tooltip) { self.show(); } \n      else { self.hide(); }\n    };\n  \n    // init\n    if ( !(stringTooltip in element) ) { // prevent adding event handlers twice\n      element[setAttribute](dataOriginalTitle,titleString);\n      element.removeAttribute(title);\n      on(element, mouseHover[0], self.show);\n      on(element, mouseHover[1], self.hide);\n    }\n    element[stringTooltip] = self;\n  };\n  \n  // TOOLTIP DATA API\n  // =================\n  supports[push]( [ stringTooltip, Tooltip, '['+dataToggle+'=\"tooltip\"]' ] );\n  \n  \n  \r\n  /* Native Javascript for Bootstrap | Initialize Data API\r\n  --------------------------------------------------------*/\r\n  var initializeDataAPI = function( constructor, collection ){\r\n      for (var i=0, l=collection[length]; i<l; i++) {\r\n        new constructor(collection[i]);\r\n      }\r\n    },\r\n    initCallback = BSN.initCallback = function(lookUp){\r\n      lookUp = lookUp || DOC;\r\n      for (var i=0, l=supports[length]; i<l; i++) {\r\n        initializeDataAPI( supports[i][1], lookUp[querySelectorAll] (supports[i][2]) );\r\n      }\r\n    };\r\n  \r\n  // bulk initialize all components\r\n  DOC[body] ? initCallback() : on( DOC, 'DOMContentLoaded', function(){ initCallback(); } );\r\n  \n  return {\n    Alert: Alert,\n    Button: Button,\n    Carousel: Carousel,\n    Collapse: Collapse,\n    Dropdown: Dropdown,\n    Modal: Modal,\n    Popover: Popover,\n    ScrollSpy: ScrollSpy,\n    Tab: Tab,\n    Toast: Toast,\n    Tooltip: Tooltip\n  };\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLm5hdGl2ZS9kaXN0L2Jvb3RzdHJhcC1uYXRpdmUtdjQuanM/MzE4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sRUFBRSxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQ3ZCLEdBQUcsTUFBTSxZQWlCTjtBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5REFBeUQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYSxFO0FBQ2xDLFlBQVksYUFBYTtBQUN6Qjs7QUFFQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSztBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUUsZ0JBQWdCLEVBQUU7O0FBRXpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ib290c3RyYXAubmF0aXZlL2Rpc3QvYm9vdHN0cmFwLW5hdGl2ZS12NC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB2Mi4wLjI3IHwgwqkgZG5wX3RoZW1lIHwgTUlULUxpY2Vuc2VcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1EIHN1cHBvcnQ6XG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIENvbW1vbkpTLWxpa2U6XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICB2YXIgYnNuID0gZmFjdG9yeSgpO1xuICAgIHJvb3QuQWxlcnQgPSBic24uQWxlcnQ7XG4gICAgcm9vdC5CdXR0b24gPSBic24uQnV0dG9uO1xuICAgIHJvb3QuQ2Fyb3VzZWwgPSBic24uQ2Fyb3VzZWw7XG4gICAgcm9vdC5Db2xsYXBzZSA9IGJzbi5Db2xsYXBzZTtcbiAgICByb290LkRyb3Bkb3duID0gYnNuLkRyb3Bkb3duO1xuICAgIHJvb3QuTW9kYWwgPSBic24uTW9kYWw7XG4gICAgcm9vdC5Qb3BvdmVyID0gYnNuLlBvcG92ZXI7XG4gICAgcm9vdC5TY3JvbGxTcHkgPSBic24uU2Nyb2xsU3B5O1xuICAgIHJvb3QuVGFiID0gYnNuLlRhYjtcbiAgICByb290LlRvYXN0ID0gYnNuLlRvYXN0O1xuICAgIHJvb3QuVG9vbHRpcCA9IGJzbi5Ub29sdGlwO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IEludGVybmFsIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBcInVzZSBzdHJpY3RcIjtcbiAgXG4gIC8vIGdsb2JhbHNcbiAgdmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdGhpc3x8d2luZG93LFxuICAgIERPQyA9IGRvY3VtZW50LCBIVE1MID0gRE9DLmRvY3VtZW50RWxlbWVudCwgYm9keSA9ICdib2R5JywgLy8gYWxsb3cgdGhlIGxpYnJhcnkgdG8gYmUgdXNlZCBpbiA8aGVhZD5cbiAgXG4gICAgLy8gTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCBHbG9iYWwgT2JqZWN0XG4gICAgQlNOID0gZ2xvYmFsT2JqZWN0LkJTTiA9IHt9LFxuICAgIHN1cHBvcnRzID0gQlNOLnN1cHBvcnRzID0gW10sXG4gIFxuICAgIC8vIGZ1bmN0aW9uIHRvZ2dsZSBhdHRyaWJ1dGVzXG4gICAgZGF0YVRvZ2dsZSAgICA9ICdkYXRhLXRvZ2dsZScsXG4gICAgZGF0YURpc21pc3MgICA9ICdkYXRhLWRpc21pc3MnLFxuICAgIGRhdGFTcHkgICAgICAgPSAnZGF0YS1zcHknLFxuICAgIGRhdGFSaWRlICAgICAgPSAnZGF0YS1yaWRlJyxcbiAgXG4gICAgLy8gY29tcG9uZW50c1xuICAgIHN0cmluZ0FsZXJ0ICAgICA9ICdBbGVydCcsXG4gICAgc3RyaW5nQnV0dG9uICAgID0gJ0J1dHRvbicsXG4gICAgc3RyaW5nQ2Fyb3VzZWwgID0gJ0Nhcm91c2VsJyxcbiAgICBzdHJpbmdDb2xsYXBzZSAgPSAnQ29sbGFwc2UnLFxuICAgIHN0cmluZ0Ryb3Bkb3duICA9ICdEcm9wZG93bicsXG4gICAgc3RyaW5nTW9kYWwgICAgID0gJ01vZGFsJyxcbiAgICBzdHJpbmdQb3BvdmVyICAgPSAnUG9wb3ZlcicsXG4gICAgc3RyaW5nU2Nyb2xsU3B5ID0gJ1Njcm9sbFNweScsXG4gICAgc3RyaW5nVGFiICAgICAgID0gJ1RhYicsXG4gICAgc3RyaW5nVG9vbHRpcCAgID0gJ1Rvb2x0aXAnLFxuICAgIHN0cmluZ1RvYXN0ICAgICA9ICdUb2FzdCcsXG4gIFxuICAgIC8vIG9wdGlvbnMgREFUQSBBUElcbiAgICBkYXRhQXV0b2hpZGUgICAgICA9ICdkYXRhLWF1dG9oaWRlJyxcbiAgICBkYXRhYmFja2Ryb3AgICAgICA9ICdkYXRhLWJhY2tkcm9wJyxcbiAgICBkYXRhS2V5Ym9hcmQgICAgICA9ICdkYXRhLWtleWJvYXJkJyxcbiAgICBkYXRhVGFyZ2V0ICAgICAgICA9ICdkYXRhLXRhcmdldCcsXG4gICAgZGF0YUludGVydmFsICAgICAgPSAnZGF0YS1pbnRlcnZhbCcsXG4gICAgZGF0YUhlaWdodCAgICAgICAgPSAnZGF0YS1oZWlnaHQnLFxuICAgIGRhdGFQYXVzZSAgICAgICAgID0gJ2RhdGEtcGF1c2UnLFxuICAgIGRhdGFUaXRsZSAgICAgICAgID0gJ2RhdGEtdGl0bGUnLFxuICAgIGRhdGFPcmlnaW5hbFRpdGxlID0gJ2RhdGEtb3JpZ2luYWwtdGl0bGUnLFxuICAgIGRhdGFEaXNtaXNzaWJsZSAgID0gJ2RhdGEtZGlzbWlzc2libGUnLFxuICAgIGRhdGFUcmlnZ2VyICAgICAgID0gJ2RhdGEtdHJpZ2dlcicsXG4gICAgZGF0YUFuaW1hdGlvbiAgICAgPSAnZGF0YS1hbmltYXRpb24nLFxuICAgIGRhdGFDb250YWluZXIgICAgID0gJ2RhdGEtY29udGFpbmVyJyxcbiAgICBkYXRhUGxhY2VtZW50ICAgICA9ICdkYXRhLXBsYWNlbWVudCcsXG4gICAgZGF0YURlbGF5ICAgICAgICAgPSAnZGF0YS1kZWxheScsXG4gIFxuICAgIC8vIG9wdGlvbiBrZXlzXG4gICAgYmFja2Ryb3AgPSAnYmFja2Ryb3AnLCBrZXlib2FyZCA9ICdrZXlib2FyZCcsIGRlbGF5ID0gJ2RlbGF5JyxcbiAgICBjb250ZW50ID0gJ2NvbnRlbnQnLCB0YXJnZXQgPSAndGFyZ2V0JywgY3VycmVudFRhcmdldCA9ICdjdXJyZW50VGFyZ2V0JyxcbiAgICBpbnRlcnZhbCA9ICdpbnRlcnZhbCcsIHBhdXNlID0gJ3BhdXNlJywgYW5pbWF0aW9uID0gJ2FuaW1hdGlvbicsXG4gICAgcGxhY2VtZW50ID0gJ3BsYWNlbWVudCcsIGNvbnRhaW5lciA9ICdjb250YWluZXInLFxuICBcbiAgICAvLyBib3ggbW9kZWxcbiAgICBvZmZzZXRUb3AgICAgPSAnb2Zmc2V0VG9wJywgICAgICBvZmZzZXRCb3R0b20gICA9ICdvZmZzZXRCb3R0b20nLFxuICAgIG9mZnNldExlZnQgICA9ICdvZmZzZXRMZWZ0JyxcbiAgICBzY3JvbGxUb3AgICAgPSAnc2Nyb2xsVG9wJywgICAgICBzY3JvbGxMZWZ0ICAgICA9ICdzY3JvbGxMZWZ0JyxcbiAgICBjbGllbnRXaWR0aCAgPSAnY2xpZW50V2lkdGgnLCAgICBjbGllbnRIZWlnaHQgICA9ICdjbGllbnRIZWlnaHQnLFxuICAgIG9mZnNldFdpZHRoICA9ICdvZmZzZXRXaWR0aCcsICAgIG9mZnNldEhlaWdodCAgID0gJ29mZnNldEhlaWdodCcsXG4gICAgaW5uZXJXaWR0aCAgID0gJ2lubmVyV2lkdGgnLCAgICAgaW5uZXJIZWlnaHQgICAgPSAnaW5uZXJIZWlnaHQnLFxuICAgIHNjcm9sbEhlaWdodCA9ICdzY3JvbGxIZWlnaHQnLCAgIHNjcm9sbFdpZHRoICAgID0gJ3Njcm9sbFdpZHRoJyxcbiAgICBoZWlnaHQgICAgICAgICA9ICdoZWlnaHQnLFxuICBcbiAgICAvLyBhcmlhXG4gICAgYXJpYUV4cGFuZGVkID0gJ2FyaWEtZXhwYW5kZWQnLFxuICAgIGFyaWFIaWRkZW4gICA9ICdhcmlhLWhpZGRlbicsXG4gICAgYXJpYVNlbGVjdGVkID0gJ2FyaWEtc2VsZWN0ZWQnLFxuICBcbiAgICAvLyBldmVudCBuYW1lc1xuICAgIGNsaWNrRXZlbnQgICAgPSAnY2xpY2snLFxuICAgIGZvY3VzRXZlbnQgICAgPSAnZm9jdXMnLFxuICAgIGhvdmVyRXZlbnQgICAgPSAnaG92ZXInLFxuICAgIGtleWRvd25FdmVudCAgPSAna2V5ZG93bicsXG4gICAga2V5dXBFdmVudCAgICA9ICdrZXl1cCcsXG4gICAgcmVzaXplRXZlbnQgICA9ICdyZXNpemUnLCAvLyBwYXNzaXZlXG4gICAgc2Nyb2xsRXZlbnQgICA9ICdzY3JvbGwnLCAvLyBwYXNzaXZlXG4gICAgbW91c2VIb3ZlciA9ICgnb25tb3VzZWxlYXZlJyBpbiBET0MpID8gWyAnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJ10gOiBbICdtb3VzZW92ZXInLCAnbW91c2VvdXQnIF0sXG4gICAgLy8gdG91Y2ggc2luY2UgMi4wLjI2XG4gICAgdG91Y2hFdmVudHMgPSB7IHN0YXJ0OiAndG91Y2hzdGFydCcsIGVuZDogJ3RvdWNoZW5kJywgbW92ZTondG91Y2htb3ZlJyB9LCAvLyBwYXNzaXZlXG4gICAgLy8gb3JpZ2luYWxFdmVudHNcbiAgICBzaG93RXZlbnQgICAgID0gJ3Nob3cnLFxuICAgIHNob3duRXZlbnQgICAgPSAnc2hvd24nLFxuICAgIGhpZGVFdmVudCAgICAgPSAnaGlkZScsXG4gICAgaGlkZGVuRXZlbnQgICA9ICdoaWRkZW4nLFxuICAgIGNsb3NlRXZlbnQgICAgPSAnY2xvc2UnLFxuICAgIGNsb3NlZEV2ZW50ICAgPSAnY2xvc2VkJyxcbiAgICBzbGlkRXZlbnQgICAgID0gJ3NsaWQnLFxuICAgIHNsaWRlRXZlbnQgICAgPSAnc2xpZGUnLFxuICAgIGNoYW5nZUV2ZW50ICAgPSAnY2hhbmdlJyxcbiAgXG4gICAgLy8gb3RoZXJcbiAgICBnZXRBdHRyaWJ1dGUgICAgICAgICAgID0gJ2dldEF0dHJpYnV0ZScsXG4gICAgc2V0QXR0cmlidXRlICAgICAgICAgICA9ICdzZXRBdHRyaWJ1dGUnLFxuICAgIGhhc0F0dHJpYnV0ZSAgICAgICAgICAgPSAnaGFzQXR0cmlidXRlJyxcbiAgICBjcmVhdGVFbGVtZW50ICAgICAgICAgID0gJ2NyZWF0ZUVsZW1lbnQnLFxuICAgIGFwcGVuZENoaWxkICAgICAgICAgICAgPSAnYXBwZW5kQ2hpbGQnLFxuICAgIGlubmVySFRNTCAgICAgICAgICAgICAgPSAnaW5uZXJIVE1MJyxcbiAgICBnZXRFbGVtZW50c0J5VGFnTmFtZSAgID0gJ2dldEVsZW1lbnRzQnlUYWdOYW1lJyxcbiAgICBwcmV2ZW50RGVmYXVsdCAgICAgICAgID0gJ3ByZXZlbnREZWZhdWx0JyxcbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QgID0gJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCcsXG4gICAgcXVlcnlTZWxlY3RvckFsbCAgICAgICA9ICdxdWVyeVNlbGVjdG9yQWxsJyxcbiAgICBnZXRFbGVtZW50c0J5Q0xBU1NOQU1FID0gJ2dldEVsZW1lbnRzQnlDbGFzc05hbWUnLFxuICAgIGdldENvbXB1dGVkU3R5bGUgICAgICAgPSAnZ2V0Q29tcHV0ZWRTdHlsZScsICBcbiAgXG4gICAgaW5kZXhPZiAgICAgID0gJ2luZGV4T2YnLFxuICAgIHBhcmVudE5vZGUgICA9ICdwYXJlbnROb2RlJyxcbiAgICBsZW5ndGggICAgICAgPSAnbGVuZ3RoJyxcbiAgICB0b0xvd2VyQ2FzZSAgPSAndG9Mb3dlckNhc2UnLFxuICAgIFRyYW5zaXRpb24gICA9ICdUcmFuc2l0aW9uJyxcbiAgICBEdXJhdGlvbiAgICAgPSAnRHVyYXRpb24nLFxuICAgIFdlYmtpdCAgICAgICA9ICdXZWJraXQnLFxuICAgIHN0eWxlICAgICAgICA9ICdzdHlsZScsXG4gICAgcHVzaCAgICAgICAgID0gJ3B1c2gnLFxuICAgIHRhYmluZGV4ICAgICA9ICd0YWJpbmRleCcsXG4gICAgY29udGFpbnMgICAgID0gJ2NvbnRhaW5zJyxcbiAgXG4gICAgYWN0aXZlICAgICA9ICdhY3RpdmUnLFxuICAgIHNob3dDbGFzcyAgPSAnc2hvdycsXG4gICAgY29sbGFwc2luZyA9ICdjb2xsYXBzaW5nJyxcbiAgICBkaXNhYmxlZCAgID0gJ2Rpc2FibGVkJyxcbiAgICBsb2FkaW5nICAgID0gJ2xvYWRpbmcnLFxuICAgIGxlZnQgICAgICAgPSAnbGVmdCcsXG4gICAgcmlnaHQgICAgICA9ICdyaWdodCcsXG4gICAgdG9wICAgICAgICA9ICd0b3AnLFxuICAgIGJvdHRvbSAgICAgPSAnYm90dG9tJyxcbiAgXG4gICAgLy8gdG9vbHRpcCAvIHBvcG92ZXJcbiAgICB0aXBQb3NpdGlvbnMgPSAvXFxiKHRvcHxib3R0b218bGVmdHxyaWdodCkrLyxcbiAgXG4gICAgLy8gbW9kYWxcbiAgICBtb2RhbE92ZXJsYXkgPSAwLFxuICAgIGZpeGVkVG9wID0gJ2ZpeGVkLXRvcCcsXG4gICAgZml4ZWRCb3R0b20gPSAnZml4ZWQtYm90dG9tJyxcbiAgXG4gICAgLy8gdHJhbnNpdGlvbkVuZCBzaW5jZSAyLjAuNFxuICAgIHN1cHBvcnRUcmFuc2l0aW9ucyA9IFdlYmtpdCtUcmFuc2l0aW9uIGluIEhUTUxbc3R5bGVdIHx8IFRyYW5zaXRpb25bdG9Mb3dlckNhc2VdKCkgaW4gSFRNTFtzdHlsZV0sXG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gV2Via2l0K1RyYW5zaXRpb24gaW4gSFRNTFtzdHlsZV0gPyBXZWJraXRbdG9Mb3dlckNhc2VdKCkrVHJhbnNpdGlvbisnRW5kJyA6IFRyYW5zaXRpb25bdG9Mb3dlckNhc2VdKCkrJ2VuZCcsXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gV2Via2l0K0R1cmF0aW9uIGluIEhUTUxbc3R5bGVdID8gV2Via2l0W3RvTG93ZXJDYXNlXSgpK1RyYW5zaXRpb24rRHVyYXRpb24gOiBUcmFuc2l0aW9uW3RvTG93ZXJDYXNlXSgpK0R1cmF0aW9uLFxuICBcbiAgICAvLyBzZXQgbmV3IGZvY3VzIGVsZW1lbnQgc2luY2UgMi4wLjNcbiAgICBzZXRGb2N1cyA9IGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgICAgZWxlbWVudC5mb2N1cyA/IGVsZW1lbnQuZm9jdXMoKSA6IGVsZW1lbnQuc2V0QWN0aXZlKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gY2xhc3MgbWFuaXB1bGF0aW9uLCBzaW5jZSAyLjAuMCByZXF1aXJlcyBwb2x5ZmlsbC5qc1xuICAgIGFkZENsYXNzID0gZnVuY3Rpb24oZWxlbWVudCxjbGFzc05BTUUpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05BTUUpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbihlbGVtZW50LGNsYXNzTkFNRSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTkFNRSk7XG4gICAgfSxcbiAgICBoYXNDbGFzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsY2xhc3NOQU1FKXsgLy8gc2luY2UgMi4wLjBcbiAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdFtjb250YWluc10oY2xhc3NOQU1FKTtcbiAgICB9LFxuICBcbiAgICAvLyBzZWxlY3Rpb24gbWV0aG9kc1xuICAgIGdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBmdW5jdGlvbihlbGVtZW50LGNsYXNzTkFNRSkgeyAvLyByZXR1cm5zIEFycmF5XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChlbGVtZW50W2dldEVsZW1lbnRzQnlDTEFTU05BTUVdKCBjbGFzc05BTUUgKSk7XG4gICAgfSxcbiAgICBxdWVyeUVsZW1lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHBhcmVudCkge1xuICAgICAgdmFyIGxvb2tVcCA9IHBhcmVudCA/IHBhcmVudCA6IERPQztcbiAgICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdvYmplY3QnID8gc2VsZWN0b3IgOiBsb29rVXAucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgfSxcbiAgICBnZXRDbG9zZXN0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7IC8vZWxlbWVudCBpcyB0aGUgZWxlbWVudCBhbmQgc2VsZWN0b3IgaXMgZm9yIHRoZSBjbG9zZXN0IHBhcmVudCBlbGVtZW50IHRvIGZpbmRcbiAgICAgIC8vIHNvdXJjZSBodHRwOi8vZ29tYWtldGhpbmdzLmNvbS9jbGltYmluZy11cC1hbmQtZG93bi10aGUtZG9tLXRyZWUtd2l0aC12YW5pbGxhLWphdmFzY3JpcHQvXG4gICAgICB2YXIgZmlyc3RDaGFyID0gc2VsZWN0b3IuY2hhckF0KDApLCBzZWxlY3RvclN1YnN0cmluZyA9IHNlbGVjdG9yLnN1YnN0cigxKTtcbiAgICAgIGlmICggZmlyc3RDaGFyID09PSAnLicgKSB7Ly8gSWYgc2VsZWN0b3IgaXMgYSBjbGFzc1xuICAgICAgICBmb3IgKCA7IGVsZW1lbnQgJiYgZWxlbWVudCAhPT0gRE9DOyBlbGVtZW50ID0gZWxlbWVudFtwYXJlbnROb2RlXSApIHsgLy8gR2V0IGNsb3Nlc3QgbWF0Y2hcbiAgICAgICAgICBpZiAoIHF1ZXJ5RWxlbWVudChzZWxlY3RvcixlbGVtZW50W3BhcmVudE5vZGVdKSAhPT0gbnVsbCAmJiBoYXNDbGFzcyhlbGVtZW50LHNlbGVjdG9yU3Vic3RyaW5nKSApIHsgcmV0dXJuIGVsZW1lbnQ7IH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICggZmlyc3RDaGFyID09PSAnIycgKSB7IC8vIElmIHNlbGVjdG9yIGlzIGFuIElEXG4gICAgICAgIGZvciAoIDsgZWxlbWVudCAmJiBlbGVtZW50ICE9PSBET0M7IGVsZW1lbnQgPSBlbGVtZW50W3BhcmVudE5vZGVdICkgeyAvLyBHZXQgY2xvc2VzdCBtYXRjaFxuICAgICAgICAgIGlmICggZWxlbWVudC5pZCA9PT0gc2VsZWN0b3JTdWJzdHJpbmcgKSB7IHJldHVybiBlbGVtZW50OyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICBcbiAgICAvLyBldmVudCBhdHRhY2ggalF1ZXJ5IHN0eWxlIC8gdHJpZ2dlciAgc2luY2UgMS4yLjBcbiAgICBvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZmFsc2U7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgb2ZmID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IGZhbHNlO1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIG9uZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykgeyAvLyBvbmUgc2luY2UgMi4wLjRcbiAgICAgIG9uKGVsZW1lbnQsIGV2ZW50LCBmdW5jdGlvbiBoYW5kbGVyV3JhcHBlcihlKXtcbiAgICAgICAgaGFuZGxlcihlKTtcbiAgICAgICAgb2ZmKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyV3JhcHBlciwgb3B0aW9ucyk7XG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIC8vIGRldGVybWluZSBzdXBwb3J0IGZvciBwYXNzaXZlIGV2ZW50c1xuICAgIHN1cHBvcnRQYXNzaXZlID0gKGZ1bmN0aW9uKCl7XG4gICAgICAvLyBUZXN0IHZpYSBhIGdldHRlciBpbiB0aGUgb3B0aW9ucyBvYmplY3QgdG8gc2VlIGlmIHRoZSBwYXNzaXZlIHByb3BlcnR5IGlzIGFjY2Vzc2VkXG4gICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb25lKGdsb2JhbE9iamVjdCwgJ3Rlc3RQYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSgpKSxcbiAgICAvLyBldmVudCBvcHRpb25zXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWQjZmVhdHVyZS1kZXRlY3Rpb25cbiAgICBwYXNzaXZlSGFuZGxlciA9IHN1cHBvcnRQYXNzaXZlID8geyBwYXNzaXZlOiB0cnVlIH0gOiBmYWxzZSxcbiAgICAvLyB0cmFuc2l0aW9uc1xuICAgIGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdmFyIGR1cmF0aW9uID0gc3VwcG9ydFRyYW5zaXRpb25zID8gZ2xvYmFsT2JqZWN0W2dldENvbXB1dGVkU3R5bGVdKGVsZW1lbnQpW3RyYW5zaXRpb25EdXJhdGlvbl0gOiAwO1xuICAgICAgZHVyYXRpb24gPSBwYXJzZUZsb2F0KGR1cmF0aW9uKTtcbiAgICAgIGR1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oZHVyYXRpb24pID8gZHVyYXRpb24gKiAxMDAwIDogMDtcbiAgICAgIHJldHVybiBkdXJhdGlvbjsgLy8gd2UgdGFrZSBhIHNob3J0IG9mZnNldCB0byBtYWtlIHN1cmUgd2UgZmlyZSBvbiB0aGUgbmV4dCBmcmFtZSBhZnRlciBhbmltYXRpb25cbiAgICB9LFxuICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oZWxlbWVudCxoYW5kbGVyKXsgLy8gZW11bGF0ZVRyYW5zaXRpb25FbmQgc2luY2UgMi4wLjRcbiAgICAgIHZhciBjYWxsZWQgPSAwLCBkdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgZHVyYXRpb24gPyBvbmUoZWxlbWVudCwgdHJhbnNpdGlvbkVuZEV2ZW50LCBmdW5jdGlvbihlKXsgIWNhbGxlZCAmJiBoYW5kbGVyKGUpLCBjYWxsZWQgPSAxOyB9KVxuICAgICAgICAgICAgICAgOiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyAhY2FsbGVkICYmIGhhbmRsZXIoKSwgY2FsbGVkID0gMTsgfSwgMTcpO1xuICAgIH0sXG4gICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjb21wb25lbnROYW1lLCByZWxhdGVkKSB7XG4gICAgICB2YXIgT3JpZ2luYWxDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudCggZXZlbnROYW1lICsgJy5icy4nICsgY29tcG9uZW50TmFtZSk7XG4gICAgICBPcmlnaW5hbEN1c3RvbUV2ZW50LnJlbGF0ZWRUYXJnZXQgPSByZWxhdGVkO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KE9yaWdpbmFsQ3VzdG9tRXZlbnQpO1xuICAgIH0sXG4gIFxuICAgIC8vIHRvb2x0aXAgLyBwb3BvdmVyIHN0dWZmXG4gICAgZ2V0U2Nyb2xsID0gZnVuY3Rpb24oKSB7IC8vIGFsc28gQWZmaXggYW5kIFNjcm9sbFNweSB1c2VzIGl0XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5IDogZ2xvYmFsT2JqZWN0LnBhZ2VZT2Zmc2V0IHx8IEhUTUxbc2Nyb2xsVG9wXSxcbiAgICAgICAgeCA6IGdsb2JhbE9iamVjdC5wYWdlWE9mZnNldCB8fCBIVE1MW3Njcm9sbExlZnRdXG4gICAgICB9XG4gICAgfSxcbiAgICBzdHlsZVRpcCA9IGZ1bmN0aW9uKGxpbmssZWxlbWVudCxwb3NpdGlvbixwYXJlbnQpIHsgLy8gYm90aCBwb3BvdmVycyBhbmQgdG9vbHRpcHMgKHRhcmdldCx0b29sdGlwLHBsYWNlbWVudCxlbGVtZW50VG9BcHBlbmRUbylcbiAgICAgIHZhciBlbGVtZW50RGltZW5zaW9ucyA9IHsgdyA6IGVsZW1lbnRbb2Zmc2V0V2lkdGhdLCBoOiBlbGVtZW50W29mZnNldEhlaWdodF0gfSxcbiAgICAgICAgICB3aW5kb3dXaWR0aCA9IChIVE1MW2NsaWVudFdpZHRoXSB8fCBET0NbYm9keV1bY2xpZW50V2lkdGhdKSxcbiAgICAgICAgICB3aW5kb3dIZWlnaHQgPSAoSFRNTFtjbGllbnRIZWlnaHRdIHx8IERPQ1tib2R5XVtjbGllbnRIZWlnaHRdKSxcbiAgICAgICAgICByZWN0ID0gbGlua1tnZXRCb3VuZGluZ0NsaWVudFJlY3RdKCksXG4gICAgICAgICAgc2Nyb2xsID0gcGFyZW50ID09PSBET0NbYm9keV0gPyBnZXRTY3JvbGwoKSA6IHsgeDogcGFyZW50W29mZnNldExlZnRdICsgcGFyZW50W3Njcm9sbExlZnRdLCB5OiBwYXJlbnRbb2Zmc2V0VG9wXSArIHBhcmVudFtzY3JvbGxUb3BdIH0sXG4gICAgICAgICAgbGlua0RpbWVuc2lvbnMgPSB7IHc6IHJlY3RbcmlnaHRdIC0gcmVjdFtsZWZ0XSwgaDogcmVjdFtib3R0b21dIC0gcmVjdFt0b3BdIH0sXG4gICAgICAgICAgaXNQb3BvdmVyID0gaGFzQ2xhc3MoZWxlbWVudCwncG9wb3ZlcicpLFxuICAgICAgICAgIHRvcFBvc2l0aW9uLCBsZWZ0UG9zaXRpb24sXG4gIFxuICAgICAgICAgIGFycm93ID0gcXVlcnlFbGVtZW50KCcuYXJyb3cnLGVsZW1lbnQpLFxuICAgICAgICAgIGFycm93VG9wLCBhcnJvd0xlZnQsIGFycm93V2lkdGgsIGFycm93SGVpZ2h0LFxuICBcbiAgICAgICAgICBoYWxmVG9wRXhjZWVkID0gcmVjdFt0b3BdICsgbGlua0RpbWVuc2lvbnMuaC8yIC0gZWxlbWVudERpbWVuc2lvbnMuaC8yIDwgMCxcbiAgICAgICAgICBoYWxmTGVmdEV4Y2VlZCA9IHJlY3RbbGVmdF0gKyBsaW5rRGltZW5zaW9ucy53LzIgLSBlbGVtZW50RGltZW5zaW9ucy53LzIgPCAwLFxuICAgICAgICAgIGhhbGZSaWdodEV4Y2VlZCA9IHJlY3RbbGVmdF0gKyBlbGVtZW50RGltZW5zaW9ucy53LzIgKyBsaW5rRGltZW5zaW9ucy53LzIgPj0gd2luZG93V2lkdGgsXG4gICAgICAgICAgaGFsZkJvdHRvbUV4Y2VlZCA9IHJlY3RbdG9wXSArIGVsZW1lbnREaW1lbnNpb25zLmgvMiArIGxpbmtEaW1lbnNpb25zLmgvMiA+PSB3aW5kb3dIZWlnaHQsXG4gICAgICAgICAgdG9wRXhjZWVkID0gcmVjdFt0b3BdIC0gZWxlbWVudERpbWVuc2lvbnMuaCA8IDAsXG4gICAgICAgICAgbGVmdEV4Y2VlZCA9IHJlY3RbbGVmdF0gLSBlbGVtZW50RGltZW5zaW9ucy53IDwgMCxcbiAgICAgICAgICBib3R0b21FeGNlZWQgPSByZWN0W3RvcF0gKyBlbGVtZW50RGltZW5zaW9ucy5oICsgbGlua0RpbWVuc2lvbnMuaCA+PSB3aW5kb3dIZWlnaHQsXG4gICAgICAgICAgcmlnaHRFeGNlZWQgPSByZWN0W2xlZnRdICsgZWxlbWVudERpbWVuc2lvbnMudyArIGxpbmtEaW1lbnNpb25zLncgPj0gd2luZG93V2lkdGg7XG4gIFxuICAgICAgLy8gcmVjb21wdXRlIHBvc2l0aW9uXG4gICAgICBwb3NpdGlvbiA9IChwb3NpdGlvbiA9PT0gbGVmdCB8fCBwb3NpdGlvbiA9PT0gcmlnaHQpICYmIGxlZnRFeGNlZWQgJiYgcmlnaHRFeGNlZWQgPyB0b3AgOiBwb3NpdGlvbjsgLy8gZmlyc3QsIHdoZW4gYm90aCBsZWZ0IGFuZCByaWdodCBsaW1pdHMgYXJlIGV4Y2VlZGVkLCB3ZSBmYWxsIGJhY2sgdG8gdG9wfGJvdHRvbVxuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdG9wICYmIHRvcEV4Y2VlZCA/IGJvdHRvbSA6IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gYm90dG9tICYmIGJvdHRvbUV4Y2VlZCA/IHRvcCA6IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gbGVmdCAmJiBsZWZ0RXhjZWVkID8gcmlnaHQgOiBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHJpZ2h0ICYmIHJpZ2h0RXhjZWVkID8gbGVmdCA6IHBvc2l0aW9uO1xuICBcbiAgICAgIC8vIHVwZGF0ZSB0b29sdGlwL3BvcG92ZXIgY2xhc3NcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lW2luZGV4T2ZdKHBvc2l0aW9uKSA9PT0gLTEgJiYgKGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZSh0aXBQb3NpdGlvbnMscG9zaXRpb24pKTtcbiAgXG4gICAgICAvLyB3ZSBjaGVjayB0aGUgY29tcHV0ZWQgd2lkdGggJiBoZWlnaHQgYW5kIHVwZGF0ZSBoZXJlXG4gICAgICBhcnJvd1dpZHRoID0gYXJyb3dbb2Zmc2V0V2lkdGhdOyBhcnJvd0hlaWdodCA9IGFycm93W29mZnNldEhlaWdodF07XG4gIFxuICAgICAgLy8gYXBwbHkgc3R5bGluZyB0byB0b29sdGlwIG9yIHBvcG92ZXJcbiAgICAgIGlmICggcG9zaXRpb24gPT09IGxlZnQgfHwgcG9zaXRpb24gPT09IHJpZ2h0ICkgeyAvLyBzZWNvbmRhcnl8c2lkZSBwb3NpdGlvbnNcbiAgICAgICAgaWYgKCBwb3NpdGlvbiA9PT0gbGVmdCApIHsgLy8gTEVGVFxuICAgICAgICAgIGxlZnRQb3NpdGlvbiA9IHJlY3RbbGVmdF0gKyBzY3JvbGwueCAtIGVsZW1lbnREaW1lbnNpb25zLncgLSAoIGlzUG9wb3ZlciA/IGFycm93V2lkdGggOiAwICk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFJJR0hUXG4gICAgICAgICAgbGVmdFBvc2l0aW9uID0gcmVjdFtsZWZ0XSArIHNjcm9sbC54ICsgbGlua0RpbWVuc2lvbnMudztcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gYWRqdXN0IHRvcCBhbmQgYXJyb3dcbiAgICAgICAgaWYgKGhhbGZUb3BFeGNlZWQpIHtcbiAgICAgICAgICB0b3BQb3NpdGlvbiA9IHJlY3RbdG9wXSArIHNjcm9sbC55O1xuICAgICAgICAgIGFycm93VG9wID0gbGlua0RpbWVuc2lvbnMuaC8yIC0gYXJyb3dXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChoYWxmQm90dG9tRXhjZWVkKSB7XG4gICAgICAgICAgdG9wUG9zaXRpb24gPSByZWN0W3RvcF0gKyBzY3JvbGwueSAtIGVsZW1lbnREaW1lbnNpb25zLmggKyBsaW5rRGltZW5zaW9ucy5oO1xuICAgICAgICAgIGFycm93VG9wID0gZWxlbWVudERpbWVuc2lvbnMuaCAtIGxpbmtEaW1lbnNpb25zLmgvMiAtIGFycm93V2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9wUG9zaXRpb24gPSByZWN0W3RvcF0gKyBzY3JvbGwueSAtIGVsZW1lbnREaW1lbnNpb25zLmgvMiArIGxpbmtEaW1lbnNpb25zLmgvMjtcbiAgICAgICAgICBhcnJvd1RvcCA9IGVsZW1lbnREaW1lbnNpb25zLmgvMiAtIChpc1BvcG92ZXIgPyBhcnJvd0hlaWdodCowLjkgOiBhcnJvd0hlaWdodC8yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICggcG9zaXRpb24gPT09IHRvcCB8fCBwb3NpdGlvbiA9PT0gYm90dG9tICkgeyAvLyBwcmltYXJ5fHZlcnRpY2FsIHBvc2l0aW9uc1xuICAgICAgICBpZiAoIHBvc2l0aW9uID09PSB0b3ApIHsgLy8gVE9QXG4gICAgICAgICAgdG9wUG9zaXRpb24gPSAgcmVjdFt0b3BdICsgc2Nyb2xsLnkgLSBlbGVtZW50RGltZW5zaW9ucy5oIC0gKCBpc1BvcG92ZXIgPyBhcnJvd0hlaWdodCA6IDAgKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gQk9UVE9NXG4gICAgICAgICAgdG9wUG9zaXRpb24gPSByZWN0W3RvcF0gKyBzY3JvbGwueSArIGxpbmtEaW1lbnNpb25zLmg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRqdXN0IGxlZnQgfCByaWdodCBhbmQgYWxzbyB0aGUgYXJyb3dcbiAgICAgICAgaWYgKGhhbGZMZWZ0RXhjZWVkKSB7XG4gICAgICAgICAgbGVmdFBvc2l0aW9uID0gMDtcbiAgICAgICAgICBhcnJvd0xlZnQgPSByZWN0W2xlZnRdICsgbGlua0RpbWVuc2lvbnMudy8yIC0gYXJyb3dXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChoYWxmUmlnaHRFeGNlZWQpIHtcbiAgICAgICAgICBsZWZ0UG9zaXRpb24gPSB3aW5kb3dXaWR0aCAtIGVsZW1lbnREaW1lbnNpb25zLncqMS4wMTtcbiAgICAgICAgICBhcnJvd0xlZnQgPSBlbGVtZW50RGltZW5zaW9ucy53IC0gKCB3aW5kb3dXaWR0aCAtIHJlY3RbbGVmdF0gKSArIGxpbmtEaW1lbnNpb25zLncvMiAtIGFycm93V2lkdGgvMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZWZ0UG9zaXRpb24gPSByZWN0W2xlZnRdICsgc2Nyb2xsLnggLSBlbGVtZW50RGltZW5zaW9ucy53LzIgKyBsaW5rRGltZW5zaW9ucy53LzI7XG4gICAgICAgICAgYXJyb3dMZWZ0ID0gZWxlbWVudERpbWVuc2lvbnMudy8yIC0gKCBpc1BvcG92ZXIgPyBhcnJvd1dpZHRoIDogYXJyb3dXaWR0aC8yICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgXG4gICAgICAvLyBhcHBseSBzdHlsZSB0byB0b29sdGlwL3BvcG92ZXIgYW5kIGl0cyBhcnJvd1xuICAgICAgZWxlbWVudFtzdHlsZV1bdG9wXSA9IHRvcFBvc2l0aW9uICsgJ3B4JztcbiAgICAgIGVsZW1lbnRbc3R5bGVdW2xlZnRdID0gbGVmdFBvc2l0aW9uICsgJ3B4JztcbiAgXG4gICAgICBhcnJvd1RvcCAmJiAoYXJyb3dbc3R5bGVdW3RvcF0gPSBhcnJvd1RvcCArICdweCcpO1xuICAgICAgYXJyb3dMZWZ0ICYmIChhcnJvd1tzdHlsZV1bbGVmdF0gPSBhcnJvd0xlZnQgKyAncHgnKTtcbiAgICB9O1xuICBcbiAgQlNOLnZlcnNpb24gPSAnMi4wLjI3JztcbiAgXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IEFsZXJ0XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBcbiAgLy8gQUxFUlQgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09XG4gIHZhciBBbGVydCA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgIFxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBcbiAgICAvLyBiaW5kLCB0YXJnZXQgYWxlcnQsIGR1cmF0aW9uIGFuZCBzdHVmZlxuICAgIHZhciBzZWxmID0gdGhpcywgY29tcG9uZW50ID0gJ2FsZXJ0JyxcbiAgICAgIGFsZXJ0ID0gZ2V0Q2xvc2VzdChlbGVtZW50LCcuJytjb21wb25lbnQpLFxuICAgICAgdHJpZ2dlckhhbmRsZXIgPSBmdW5jdGlvbigpeyBoYXNDbGFzcyhhbGVydCwnZmFkZScpID8gZW11bGF0ZVRyYW5zaXRpb25FbmQoYWxlcnQsdHJhbnNpdGlvbkVuZEhhbmRsZXIpIDogdHJhbnNpdGlvbkVuZEhhbmRsZXIoKTsgfSxcbiAgICAgIC8vIGhhbmRsZXJzXG4gICAgICBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgYWxlcnQgPSBnZXRDbG9zZXN0KGVbdGFyZ2V0XSwnLicrY29tcG9uZW50KTtcbiAgICAgICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudCgnWycrZGF0YURpc21pc3MrJz1cIicrY29tcG9uZW50KydcIl0nLGFsZXJ0KTtcbiAgICAgICAgZWxlbWVudCAmJiBhbGVydCAmJiAoZWxlbWVudCA9PT0gZVt0YXJnZXRdIHx8IGVsZW1lbnRbY29udGFpbnNdKGVbdGFyZ2V0XSkpICYmIHNlbGYuY2xvc2UoKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2l0aW9uRW5kSGFuZGxlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoYWxlcnQsIGNsb3NlZEV2ZW50LCBjb21wb25lbnQpO1xuICAgICAgICBvZmYoZWxlbWVudCwgY2xpY2tFdmVudCwgY2xpY2tIYW5kbGVyKTsgLy8gZGV0YWNoIGl0J3MgbGlzdGVuZXJcbiAgICAgICAgYWxlcnRbcGFyZW50Tm9kZV0ucmVtb3ZlQ2hpbGQoYWxlcnQpO1xuICAgICAgfTtcbiAgICBcbiAgICAvLyBwdWJsaWMgbWV0aG9kXG4gICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCBhbGVydCAmJiBlbGVtZW50ICYmIGhhc0NsYXNzKGFsZXJ0LHNob3dDbGFzcykgKSB7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoYWxlcnQsIGNsb3NlRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIHJlbW92ZUNsYXNzKGFsZXJ0LHNob3dDbGFzcyk7XG4gICAgICAgIGFsZXJ0ICYmIHRyaWdnZXJIYW5kbGVyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgXG4gICAgLy8gaW5pdFxuICAgIGlmICggIShzdHJpbmdBbGVydCBpbiBlbGVtZW50ICkgKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgICBvbihlbGVtZW50LCBjbGlja0V2ZW50LCBjbGlja0hhbmRsZXIpO1xuICAgIH1cbiAgICBlbGVtZW50W3N0cmluZ0FsZXJ0XSA9IHNlbGY7XG4gIH07XG4gIFxuICAvLyBBTEVSVCBEQVRBIEFQSVxuICAvLyA9PT09PT09PT09PT09PVxuICBzdXBwb3J0c1twdXNoXShbc3RyaW5nQWxlcnQsIEFsZXJ0LCAnWycrZGF0YURpc21pc3MrJz1cImFsZXJ0XCJdJ10pO1xuICBcbiAgXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IEJ1dHRvblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBcbiAgLy8gQlVUVE9OIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuICB2YXIgQnV0dG9uID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gIFxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBcbiAgICAvLyBjb25zdGFudFxuICAgIHZhciB0b2dnbGVkID0gZmFsc2UsIC8vIHRvZ2dsZWQgbWFrZXMgc3VyZSB0byBwcmV2ZW50IHRyaWdnZXJpbmcgdHdpY2UgdGhlIGNoYW5nZS5icy5idXR0b24gZXZlbnRzXG4gIFxuICAgICAgICAvLyBzdHJpbmdzXG4gICAgICAgIGNvbXBvbmVudCA9ICdidXR0b24nLFxuICAgICAgICBjaGVja2VkID0gJ2NoZWNrZWQnLFxuICAgICAgICBMQUJFTCA9ICdMQUJFTCcsXG4gICAgICAgIElOUFVUID0gJ0lOUFVUJyxcbiAgXG4gICAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICAgIGtleUhhbmRsZXIgPSBmdW5jdGlvbihlKXsgXG4gICAgICAgIHZhciBrZXkgPSBlLndoaWNoIHx8IGUua2V5Q29kZTtcbiAgICAgICAga2V5ID09PSAzMiAmJiBlW3RhcmdldF0gPT09IERPQy5hY3RpdmVFbGVtZW50ICYmIHRvZ2dsZShlKTtcbiAgICAgIH0sXG4gICAgICBwcmV2ZW50U2Nyb2xsID0gZnVuY3Rpb24oZSl7IFxuICAgICAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAgICAgIGtleSA9PT0gMzIgJiYgZVtwcmV2ZW50RGVmYXVsdF0oKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGVbdGFyZ2V0XS50YWdOYW1lID09PSBMQUJFTCA/IGVbdGFyZ2V0XSA6IGVbdGFyZ2V0XVtwYXJlbnROb2RlXS50YWdOYW1lID09PSBMQUJFTCA/IGVbdGFyZ2V0XVtwYXJlbnROb2RlXSA6IG51bGw7IC8vIHRoZSAuYnRuIGxhYmVsXG4gICAgICAgIFxuICAgICAgICBpZiAoICFsYWJlbCApIHJldHVybjsgLy9yZWFjdCBpZiBhIGxhYmVsIG9yIGl0cyBpbW1lZGlhdGUgY2hpbGQgaXMgY2xpY2tlZFxuICBcbiAgICAgICAgdmFyIGxhYmVscyA9IGdldEVsZW1lbnRzQnlDbGFzc05hbWUobGFiZWxbcGFyZW50Tm9kZV0sJ2J0bicpLCAvLyBhbGwgdGhlIGJ1dHRvbiBncm91cCBidXR0b25zXG4gICAgICAgICAgaW5wdXQgPSBsYWJlbFtnZXRFbGVtZW50c0J5VGFnTmFtZV0oSU5QVVQpWzBdO1xuICBcbiAgICAgICAgaWYgKCAhaW5wdXQgKSByZXR1cm47IC8vIHJldHVybiBpZiBubyBpbnB1dCBmb3VuZFxuICBcbiAgICAgICAgLy8gbWFuYWdlIHRoZSBkb20gbWFuaXB1bGF0aW9uXG4gICAgICAgIGlmICggaW5wdXQudHlwZSA9PT0gJ2NoZWNrYm94JyApIHsgLy9jaGVja2JveGVzXG4gICAgICAgICAgaWYgKCAhaW5wdXRbY2hlY2tlZF0gKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhsYWJlbCxhY3RpdmUpO1xuICAgICAgICAgICAgaW5wdXRbZ2V0QXR0cmlidXRlXShjaGVja2VkKTtcbiAgICAgICAgICAgIGlucHV0W3NldEF0dHJpYnV0ZV0oY2hlY2tlZCxjaGVja2VkKTtcbiAgICAgICAgICAgIGlucHV0W2NoZWNrZWRdID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MobGFiZWwsYWN0aXZlKTtcbiAgICAgICAgICAgIGlucHV0W2dldEF0dHJpYnV0ZV0oY2hlY2tlZCk7XG4gICAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoY2hlY2tlZCk7XG4gICAgICAgICAgICBpbnB1dFtjaGVja2VkXSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgaWYgKCF0b2dnbGVkKSB7IC8vIHByZXZlbnQgdHJpZ2dlcmluZyB0aGUgZXZlbnQgdHdpY2VcbiAgICAgICAgICAgIHRvZ2dsZWQgPSB0cnVlO1xuICAgICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChpbnB1dCwgY2hhbmdlRXZlbnQsIGNvbXBvbmVudCk7IC8vdHJpZ2dlciB0aGUgY2hhbmdlIGZvciB0aGUgaW5wdXRcbiAgICAgICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgY2hhbmdlRXZlbnQsIGNvbXBvbmVudCk7IC8vdHJpZ2dlciB0aGUgY2hhbmdlIGZvciB0aGUgYnRuLWdyb3VwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gIFxuICAgICAgICBpZiAoIGlucHV0LnR5cGUgPT09ICdyYWRpbycgJiYgIXRvZ2dsZWQgKSB7IC8vIHJhZGlvIGJ1dHRvbnNcbiAgICAgICAgICAvLyBkb24ndCB0cmlnZ2VyIGlmIGFscmVhZHkgYWN0aXZlICh0aGUgT1IgY29uZGl0aW9uIGlzIGEgaGFjayB0byBjaGVjayBpZiB0aGUgYnV0dG9ucyB3ZXJlIHNlbGVjdGVkIHdpdGgga2V5IHByZXNzIGFuZCBOT1QgbW91c2UgY2xpY2spXG4gICAgICAgICAgaWYgKCAhaW5wdXRbY2hlY2tlZF0gfHwgKGUuc2NyZWVuWCA9PT0gMCAmJiBlLnNjcmVlblkgPT0gMCkgKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhsYWJlbCxhY3RpdmUpO1xuICAgICAgICAgICAgYWRkQ2xhc3MobGFiZWwsZm9jdXNFdmVudCk7XG4gICAgICAgICAgICBpbnB1dFtzZXRBdHRyaWJ1dGVdKGNoZWNrZWQsY2hlY2tlZCk7XG4gICAgICAgICAgICBpbnB1dFtjaGVja2VkXSA9IHRydWU7XG4gICAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGlucHV0LCBjaGFuZ2VFdmVudCwgY29tcG9uZW50KTsgLy90cmlnZ2VyIHRoZSBjaGFuZ2UgZm9yIHRoZSBpbnB1dFxuICAgICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBjaGFuZ2VFdmVudCwgY29tcG9uZW50KTsgLy90cmlnZ2VyIHRoZSBjaGFuZ2UgZm9yIHRoZSBidG4tZ3JvdXBcbiAgXG4gICAgICAgICAgICB0b2dnbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsbCA9IGxhYmVsc1tsZW5ndGhdOyBpPGxsOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIG90aGVyTGFiZWwgPSBsYWJlbHNbaV0sIG90aGVySW5wdXQgPSBvdGhlckxhYmVsW2dldEVsZW1lbnRzQnlUYWdOYW1lXShJTlBVVClbMF07XG4gICAgICAgICAgICAgIGlmICggb3RoZXJMYWJlbCAhPT0gbGFiZWwgJiYgaGFzQ2xhc3Mob3RoZXJMYWJlbCxhY3RpdmUpICkgIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhvdGhlckxhYmVsLGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgb3RoZXJJbnB1dC5yZW1vdmVBdHRyaWJ1dGUoY2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgb3RoZXJJbnB1dFtjaGVja2VkXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwob3RoZXJJbnB1dCwgY2hhbmdlRXZlbnQsIGNvbXBvbmVudCk7IC8vIHRyaWdnZXIgdGhlIGNoYW5nZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkgeyB0b2dnbGVkID0gZmFsc2U7IH0sIDUwICk7XG4gICAgICB9LFxuICAgICAgZm9jdXNIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBhZGRDbGFzcyhlW3RhcmdldF1bcGFyZW50Tm9kZV0sZm9jdXNFdmVudCk7XG4gICAgICB9LFxuICAgICAgYmx1ckhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGVbdGFyZ2V0XVtwYXJlbnROb2RlXSxmb2N1c0V2ZW50KTtcbiAgICAgIH07XG4gIFxuICAgIC8vIGluaXRcbiAgICBpZiAoICEoIHN0cmluZ0J1dHRvbiBpbiBlbGVtZW50ICkgKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgICBvbiggZWxlbWVudCwgY2xpY2tFdmVudCwgdG9nZ2xlICk7XG4gICAgICBvbiggZWxlbWVudCwga2V5dXBFdmVudCwga2V5SGFuZGxlciApLCBvbiggZWxlbWVudCwga2V5ZG93bkV2ZW50LCBwcmV2ZW50U2Nyb2xsICk7XG4gIFxuICAgICAgdmFyIGFsbEJ0bnMgPSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGVsZW1lbnQsICdidG4nKTtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxhbGxCdG5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGFsbEJ0bnNbaV1bZ2V0RWxlbWVudHNCeVRhZ05hbWVdKElOUFVUKVswXTtcbiAgICAgICAgb24oIGlucHV0LCBmb2N1c0V2ZW50LCBmb2N1c0hhbmRsZXIpLCBvbiggaW5wdXQsICdibHVyJywgYmx1ckhhbmRsZXIpO1xuICAgICAgfSAgICBcbiAgICB9XG4gIFxuICAgIC8vIGFjdGl2YXRlIGl0ZW1zIG9uIGxvYWRcbiAgICB2YXIgbGFiZWxzVG9BQ3RpdmF0ZSA9IGdldEVsZW1lbnRzQnlDbGFzc05hbWUoZWxlbWVudCwgJ2J0bicpLCBsYmxsID0gbGFiZWxzVG9BQ3RpdmF0ZVtsZW5ndGhdO1xuICAgIGZvciAodmFyIGk9MDsgaTxsYmxsOyBpKyspIHtcbiAgICAgICFoYXNDbGFzcyhsYWJlbHNUb0FDdGl2YXRlW2ldLGFjdGl2ZSkgJiYgcXVlcnlFbGVtZW50KCdpbnB1dDpjaGVja2VkJyxsYWJlbHNUb0FDdGl2YXRlW2ldKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYWRkQ2xhc3MobGFiZWxzVG9BQ3RpdmF0ZVtpXSxhY3RpdmUpO1xuICAgIH1cbiAgICBlbGVtZW50W3N0cmluZ0J1dHRvbl0gPSB0aGlzO1xuICB9O1xuICBcbiAgLy8gQlVUVE9OIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKCBbIHN0cmluZ0J1dHRvbiwgQnV0dG9uLCAnWycrZGF0YVRvZ2dsZSsnPVwiYnV0dG9uc1wiXScgXSApO1xuICBcbiAgXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IENhcm91c2VsXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBcbiAgLy8gQ0FST1VTRUwgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09XG4gIHZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uKCBlbGVtZW50LCBvcHRpb25zICkge1xuICBcbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudCggZWxlbWVudCApO1xuICBcbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciBpbnRlcnZhbEF0dHJpYnV0ZSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhSW50ZXJ2YWwpLFxuICAgICAgICBpbnRlcnZhbE9wdGlvbiA9IG9wdGlvbnNbaW50ZXJ2YWxdLFxuICAgICAgICBpbnRlcnZhbERhdGEgPSBpbnRlcnZhbEF0dHJpYnV0ZSA9PT0gJ2ZhbHNlJyA/IDAgOiBwYXJzZUludChpbnRlcnZhbEF0dHJpYnV0ZSksICBcbiAgICAgICAgcGF1c2VEYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFQYXVzZSkgPT09IGhvdmVyRXZlbnQgfHwgZmFsc2UsXG4gICAgICAgIGtleWJvYXJkRGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhS2V5Ym9hcmQpID09PSAndHJ1ZScgfHwgZmFsc2UsXG4gICAgICBcbiAgICAgICAgLy8gc3RyaW5nc1xuICAgICAgICBjb21wb25lbnQgPSAnY2Fyb3VzZWwnLFxuICAgICAgICBwYXVzZWQgPSAncGF1c2VkJyxcbiAgICAgICAgZGlyZWN0aW9uID0gJ2RpcmVjdGlvbicsXG4gICAgICAgIGNhcm91c2VsSXRlbSA9ICdjYXJvdXNlbC1pdGVtJyxcbiAgICAgICAgZGF0YVNsaWRlVG8gPSAnZGF0YS1zbGlkZS10byc7IFxuICBcbiAgICB0aGlzW2tleWJvYXJkXSA9IG9wdGlvbnNba2V5Ym9hcmRdID09PSB0cnVlIHx8IGtleWJvYXJkRGF0YTtcbiAgICB0aGlzW3BhdXNlXSA9IChvcHRpb25zW3BhdXNlXSA9PT0gaG92ZXJFdmVudCB8fCBwYXVzZURhdGEpID8gaG92ZXJFdmVudCA6IGZhbHNlOyAvLyBmYWxzZSAvIGhvdmVyXG4gIFxuICAgIHRoaXNbaW50ZXJ2YWxdID0gdHlwZW9mIGludGVydmFsT3B0aW9uID09PSAnbnVtYmVyJyA/IGludGVydmFsT3B0aW9uXG4gICAgICAgICAgICAgICAgICAgOiBpbnRlcnZhbE9wdGlvbiA9PT0gZmFsc2UgfHwgaW50ZXJ2YWxEYXRhID09PSAwIHx8IGludGVydmFsRGF0YSA9PT0gZmFsc2UgPyAwXG4gICAgICAgICAgICAgICAgICAgOiBpc05hTihpbnRlcnZhbERhdGEpID8gNTAwMCAvLyBib290c3RyYXAgY2Fyb3VzZWwgZGVmYXVsdCBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgIDogaW50ZXJ2YWxEYXRhO1xuICBcbiAgICAvLyBiaW5kLCBldmVudCB0YXJnZXRzXG4gICAgdmFyIHNlbGYgPSB0aGlzLCBpbmRleCA9IGVsZW1lbnQuaW5kZXggPSAwLCB0aW1lciA9IGVsZW1lbnQudGltZXIgPSAwLCBcbiAgICAgIGlzU2xpZGluZyA9IGZhbHNlLCAvLyBpc1NsaWRpbmcgcHJldmVudHMgY2xpY2sgZXZlbnQgaGFuZGxlcnMgd2hlbiBhbmltYXRpb24gaXMgcnVubmluZ1xuICAgICAgaXNUb3VjaCA9IGZhbHNlLCBzdGFydFhQb3NpdGlvbiA9IG51bGwsIGN1cnJlbnRYUG9zaXRpb24gPSBudWxsLCBlbmRYUG9zaXRpb24gPSBudWxsLCAvLyB0b3VjaCBhbmQgZXZlbnQgY29vcmRpbmF0ZXNcbiAgICAgIHNsaWRlcyA9IGdldEVsZW1lbnRzQnlDbGFzc05hbWUoZWxlbWVudCxjYXJvdXNlbEl0ZW0pLCB0b3RhbCA9IHNsaWRlc1tsZW5ndGhdLFxuICAgICAgc2xpZGVEaXJlY3Rpb24gPSB0aGlzW2RpcmVjdGlvbl0gPSBsZWZ0LFxuICAgICAgbGVmdEFycm93ID0gZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShlbGVtZW50LGNvbXBvbmVudCsnLWNvbnRyb2wtcHJldicpWzBdLCBcbiAgICAgIHJpZ2h0QXJyb3cgPSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGVsZW1lbnQsY29tcG9uZW50KyctY29udHJvbC1uZXh0JylbMF0sXG4gICAgICBpbmRpY2F0b3IgPSBxdWVyeUVsZW1lbnQoICcuJytjb21wb25lbnQrJy1pbmRpY2F0b3JzJywgZWxlbWVudCApLFxuICAgICAgaW5kaWNhdG9ycyA9IGluZGljYXRvciAmJiBpbmRpY2F0b3JbZ2V0RWxlbWVudHNCeVRhZ05hbWVdKCBcIkxJXCIgKSB8fCBbXTtcbiAgXG4gICAgLy8gaW52YWxpZGF0ZSB3aGVuIG5vdCBlbm91Z2ggaXRlbXNcbiAgICBpZiAodG90YWwgPCAyKSB7IHJldHVybjsgfVxuICBcbiAgICAvLyBoYW5kbGVyc1xuICAgIHZhciBwYXVzZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICggc2VsZltpbnRlcnZhbF0gIT09ZmFsc2UgJiYgIWhhc0NsYXNzKGVsZW1lbnQscGF1c2VkKSApIHtcbiAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LHBhdXNlZCk7XG4gICAgICAgICAgIWlzU2xpZGluZyAmJiAoIGNsZWFySW50ZXJ2YWwodGltZXIpLCB0aW1lciA9IG51bGwgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3VtZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCBzZWxmW2ludGVydmFsXSAhPT0gZmFsc2UgJiYgaGFzQ2xhc3MoZWxlbWVudCxwYXVzZWQpICkge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQscGF1c2VkKTtcbiAgICAgICAgICAhaXNTbGlkaW5nICYmICggY2xlYXJJbnRlcnZhbCh0aW1lciksIHRpbWVyID0gbnVsbCApO1xuICAgICAgICAgICFpc1NsaWRpbmcgJiYgc2VsZi5jeWNsZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5kaWNhdG9ySGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZVtwcmV2ZW50RGVmYXVsdF0oKTtcbiAgICAgICAgaWYgKGlzU2xpZGluZykgcmV0dXJuO1xuICBcbiAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZVt0YXJnZXRdOyAvLyBldmVudCB0YXJnZXQgfCB0aGUgY3VycmVudCBhY3RpdmUgaXRlbVxuICBcbiAgICAgICAgaWYgKCBldmVudFRhcmdldCAmJiAhaGFzQ2xhc3MoZXZlbnRUYXJnZXQsYWN0aXZlKSAmJiBldmVudFRhcmdldFtnZXRBdHRyaWJ1dGVdKGRhdGFTbGlkZVRvKSApIHtcbiAgICAgICAgICBpbmRleCA9IHBhcnNlSW50KCBldmVudFRhcmdldFtnZXRBdHRyaWJ1dGVdKGRhdGFTbGlkZVRvKSwgMTAgKTtcbiAgICAgICAgfSBlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XG4gIFxuICAgICAgICBzZWxmLnNsaWRlVG8oIGluZGV4ICk7IC8vRG8gdGhlIHNsaWRlXG4gICAgICB9LFxuICAgICAgY29udHJvbHNIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZVtwcmV2ZW50RGVmYXVsdF0oKTtcbiAgICAgICAgaWYgKGlzU2xpZGluZykgcmV0dXJuO1xuICBcbiAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgXG4gICAgICAgIGlmICggZXZlbnRUYXJnZXQgPT09IHJpZ2h0QXJyb3cgKSB7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfSBlbHNlIGlmICggZXZlbnRUYXJnZXQgPT09IGxlZnRBcnJvdyApIHtcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG4gIFxuICAgICAgICBzZWxmLnNsaWRlVG8oIGluZGV4ICk7IC8vRG8gdGhlIHNsaWRlXG4gICAgICB9LFxuICAgICAga2V5SGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChpc1NsaWRpbmcpIHJldHVybjtcbiAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnNsaWRlVG8oIGluZGV4ICk7IC8vRG8gdGhlIHNsaWRlXG4gICAgICB9LFxuICAgICAgLy8gdG91Y2ggZXZlbnRzXG4gICAgICB0b2dnbGVUb3VjaEV2ZW50cyA9IGZ1bmN0aW9uKHRvZ2dsZSl7XG4gICAgICAgIHRvZ2dsZSggZWxlbWVudCwgdG91Y2hFdmVudHMubW92ZSwgdG91Y2hNb3ZlSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgICAgICAgdG9nZ2xlKCBlbGVtZW50LCB0b3VjaEV2ZW50cy5lbmQsIHRvdWNoRW5kSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgICB9LCAgXG4gICAgICB0b3VjaERvd25IYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIGlzVG91Y2ggKSB7IHJldHVybjsgfSBcbiAgICAgICAgICBcbiAgICAgICAgc3RhcnRYUG9zaXRpb24gPSBwYXJzZUludChlLnRvdWNoZXNbMF0ucGFnZVgpO1xuICBcbiAgICAgICAgaWYgKCBlbGVtZW50LmNvbnRhaW5zKGVbdGFyZ2V0XSkgKSB7XG4gICAgICAgICAgaXNUb3VjaCA9IHRydWU7XG4gICAgICAgICAgdG9nZ2xlVG91Y2hFdmVudHMob24pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG91Y2hNb3ZlSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCAhaXNUb3VjaCApIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm47IH1cbiAgXG4gICAgICAgIGN1cnJlbnRYUG9zaXRpb24gPSBwYXJzZUludChlLnRvdWNoZXNbMF0ucGFnZVgpO1xuICAgICAgICBcbiAgICAgICAgLy9jYW5jZWwgdG91Y2ggaWYgbW9yZSB0aGFuIG9uZSB0b3VjaGVzIGRldGVjdGVkXG4gICAgICAgIGlmICggZS50eXBlID09PSAndG91Y2htb3ZlJyAmJiBlLnRvdWNoZXNbbGVuZ3RoXSA+IDEgKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvdWNoRW5kSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCAhaXNUb3VjaCB8fCBpc1NsaWRpbmcgKSB7IHJldHVybiB9XG4gICAgICAgIFxuICAgICAgICBlbmRYUG9zaXRpb24gPSBjdXJyZW50WFBvc2l0aW9uIHx8IHBhcnNlSW50KCBlLnRvdWNoZXNbMF0ucGFnZVggKTtcbiAgXG4gICAgICAgIGlmICggaXNUb3VjaCApIHtcbiAgICAgICAgICBpZiAoICghZWxlbWVudC5jb250YWlucyhlW3RhcmdldF0pIHx8ICFlbGVtZW50LmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkgKSAmJiBNYXRoLmFicyhzdGFydFhQb3NpdGlvbiAtIGVuZFhQb3NpdGlvbikgPCA3NSApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCBjdXJyZW50WFBvc2l0aW9uIDwgc3RhcnRYUG9zaXRpb24gKSB7XG4gICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjdXJyZW50WFBvc2l0aW9uID4gc3RhcnRYUG9zaXRpb24gKSB7XG4gICAgICAgICAgICAgIGluZGV4LS07ICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzVG91Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuc2xpZGVUbyhpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvZ2dsZVRvdWNoRXZlbnRzKG9mZik7ICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIH0sXG4gIFxuICAgICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgICBpc0VsZW1lbnRJblNjcm9sbFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVjdCA9IGVsZW1lbnRbZ2V0Qm91bmRpbmdDbGllbnRSZWN0XSgpLFxuICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0ID0gZ2xvYmFsT2JqZWN0W2lubmVySGVpZ2h0XSB8fCBIVE1MW2NsaWVudEhlaWdodF1cbiAgICAgICAgcmV0dXJuIHJlY3RbdG9wXSA8PSB2aWV3cG9ydEhlaWdodCAmJiByZWN0W2JvdHRvbV0gPj0gMDsgLy8gYm90dG9tICYmIHRvcFxuICAgICAgfSwgICAgXG4gICAgICBzZXRBY3RpdmVQYWdlID0gZnVuY3Rpb24oIHBhZ2VJbmRleCApIHsgLy9pbmRpY2F0b3JzXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWNsID0gaW5kaWNhdG9yc1tsZW5ndGhdOyBpIDwgaWNsOyBpKysgKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoaW5kaWNhdG9yc1tpXSxhY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRpY2F0b3JzW3BhZ2VJbmRleF0pIGFkZENsYXNzKGluZGljYXRvcnNbcGFnZUluZGV4XSwgYWN0aXZlKTtcbiAgICAgIH07XG4gIFxuICBcbiAgICAvLyBwdWJsaWMgbWV0aG9kc1xuICAgIHRoaXMuY3ljbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aW1lcikge1xuICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgfVxuICBcbiAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlzRWxlbWVudEluU2Nyb2xsUmFuZ2UoKSAmJiAoaW5kZXgrKywgc2VsZi5zbGlkZVRvKCBpbmRleCApICk7XG4gICAgICB9LCB0aGlzW2ludGVydmFsXSk7XG4gICAgfTtcbiAgICB0aGlzLnNsaWRlVG8gPSBmdW5jdGlvbiggbmV4dCApIHtcbiAgICAgIGlmIChpc1NsaWRpbmcpIHJldHVybjsgLy8gd2hlbiBjb250cm9sZWQgdmlhIG1ldGhvZHMsIG1ha2Ugc3VyZSB0byBjaGVjayBhZ2FpbiAgICAgIFxuICAgICAgXG4gICAgICB2YXIgYWN0aXZlSXRlbSA9IHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSwgLy8gdGhlIGN1cnJlbnQgYWN0aXZlXG4gICAgICAgICAgb3JpZW50YXRpb247XG4gICAgICBcbiAgICAgIC8vIGZpcnN0IHJldHVybiBpZiB3ZSdyZSBvbiB0aGUgc2FtZSBpdGVtICMyMjdcbiAgICAgIGlmICggYWN0aXZlSXRlbSA9PT0gbmV4dCApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgLy8gb3IgZGV0ZXJtaW5lIHNsaWRlRGlyZWN0aW9uXG4gICAgICB9IGVsc2UgaWYgICggKGFjdGl2ZUl0ZW0gPCBuZXh0ICkgfHwgKGFjdGl2ZUl0ZW0gPT09IDAgJiYgbmV4dCA9PT0gdG90YWwgLTEgKSApIHtcbiAgICAgICAgc2xpZGVEaXJlY3Rpb24gPSBzZWxmW2RpcmVjdGlvbl0gPSBsZWZ0OyAvLyBuZXh0XG4gICAgICB9IGVsc2UgaWYgICggKGFjdGl2ZUl0ZW0gPiBuZXh0KSB8fCAoYWN0aXZlSXRlbSA9PT0gdG90YWwgLSAxICYmIG5leHQgPT09IDAgKSApIHtcbiAgICAgICAgc2xpZGVEaXJlY3Rpb24gPSBzZWxmW2RpcmVjdGlvbl0gPSByaWdodDsgLy8gcHJldlxuICAgICAgfVxuICBcbiAgICAgIC8vIGZpbmQgdGhlIHJpZ2h0IG5leHQgaW5kZXggXG4gICAgICBpZiAoIG5leHQgPCAwICkgeyBuZXh0ID0gdG90YWwgLSAxOyB9IFxuICAgICAgZWxzZSBpZiAoIG5leHQgPj0gdG90YWwgKXsgbmV4dCA9IDA7IH1cbiAgXG4gICAgICAvLyB1cGRhdGUgaW5kZXhcbiAgICAgIGluZGV4ID0gbmV4dDtcbiAgXG4gICAgICBvcmllbnRhdGlvbiA9IHNsaWRlRGlyZWN0aW9uID09PSBsZWZ0ID8gJ25leHQnIDogJ3ByZXYnOyAvL2RldGVybWluZSB0eXBlXG4gICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNsaWRlRXZlbnQsIGNvbXBvbmVudCwgc2xpZGVzW25leHRdKTsgLy8gaGVyZSB3ZSBnbyB3aXRoIHRoZSBzbGlkZVxuICBcbiAgICAgIGlzU2xpZGluZyA9IHRydWU7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIHNldEFjdGl2ZVBhZ2UoIG5leHQgKTtcbiAgXG4gICAgICBpZiAoIHN1cHBvcnRUcmFuc2l0aW9ucyAmJiBoYXNDbGFzcyhlbGVtZW50LCdzbGlkZScpICkge1xuICBcbiAgICAgICAgYWRkQ2xhc3Moc2xpZGVzW25leHRdLGNhcm91c2VsSXRlbSArJy0nKyBvcmllbnRhdGlvbik7XG4gICAgICAgIHNsaWRlc1tuZXh0XVtvZmZzZXRXaWR0aF07XG4gICAgICAgIGFkZENsYXNzKHNsaWRlc1tuZXh0XSxjYXJvdXNlbEl0ZW0gKyctJysgc2xpZGVEaXJlY3Rpb24pO1xuICAgICAgICBhZGRDbGFzcyhzbGlkZXNbYWN0aXZlSXRlbV0sY2Fyb3VzZWxJdGVtICsnLScrIHNsaWRlRGlyZWN0aW9uKTtcbiAgXG4gICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHNsaWRlc1tuZXh0XSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHZhciB0aW1lb3V0ID0gZSAmJiBlW3RhcmdldF0gIT09IHNsaWRlc1tuZXh0XSA/IGUuZWxhcHNlZFRpbWUqMTAwMCsxMDAgOiAyMDtcbiAgICAgICAgICBcbiAgICAgICAgICBpc1NsaWRpbmcgJiYgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgaXNTbGlkaW5nID0gZmFsc2U7XG4gIFxuICAgICAgICAgICAgYWRkQ2xhc3Moc2xpZGVzW25leHRdLGFjdGl2ZSk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhzbGlkZXNbYWN0aXZlSXRlbV0sYWN0aXZlKTtcbiAgXG4gICAgICAgICAgICByZW1vdmVDbGFzcyhzbGlkZXNbbmV4dF0sY2Fyb3VzZWxJdGVtICsnLScrIG9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNsaWRlc1tuZXh0XSxjYXJvdXNlbEl0ZW0gKyctJysgc2xpZGVEaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2xpZGVzW2FjdGl2ZUl0ZW1dLGNhcm91c2VsSXRlbSArJy0nKyBzbGlkZURpcmVjdGlvbik7XG4gIFxuICAgICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkRXZlbnQsIGNvbXBvbmVudCwgc2xpZGVzW25leHRdKTtcbiAgXG4gICAgICAgICAgICBpZiAoICFET0MuaGlkZGVuICYmIHNlbGZbaW50ZXJ2YWxdICYmICFoYXNDbGFzcyhlbGVtZW50LHBhdXNlZCkgKSB7XG4gICAgICAgICAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfSk7XG4gIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkQ2xhc3Moc2xpZGVzW25leHRdLGFjdGl2ZSk7XG4gICAgICAgIHNsaWRlc1tuZXh0XVtvZmZzZXRXaWR0aF07XG4gICAgICAgIHJlbW92ZUNsYXNzKHNsaWRlc1thY3RpdmVJdGVtXSxhY3RpdmUpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmICggc2VsZltpbnRlcnZhbF0gJiYgIWhhc0NsYXNzKGVsZW1lbnQscGF1c2VkKSApIHtcbiAgICAgICAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkRXZlbnQsIGNvbXBvbmVudCwgc2xpZGVzW25leHRdKTtcbiAgICAgICAgfSwgMTAwICk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldEFjdGl2ZUluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNsaWRlc1tpbmRleE9mXShnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGVsZW1lbnQsY2Fyb3VzZWxJdGVtKycgYWN0aXZlJylbMF0pIHx8IDA7XG4gICAgfTtcbiAgXG4gICAgLy8gaW5pdFxuICAgIGlmICggIShzdHJpbmdDYXJvdXNlbCBpbiBlbGVtZW50ICkgKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gIFxuICAgICAgaWYgKCBzZWxmW3BhdXNlXSAmJiBzZWxmW2ludGVydmFsXSApIHtcbiAgICAgICAgb24oIGVsZW1lbnQsIG1vdXNlSG92ZXJbMF0sIHBhdXNlSGFuZGxlciApO1xuICAgICAgICBvbiggZWxlbWVudCwgbW91c2VIb3ZlclsxXSwgcmVzdW1lSGFuZGxlciApO1xuICAgICAgICBvbiggZWxlbWVudCwgdG91Y2hFdmVudHMuc3RhcnQsIHBhdXNlSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgICAgICAgb24oIGVsZW1lbnQsIHRvdWNoRXZlbnRzLmVuZCwgcmVzdW1lSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgICAgIH1cbiAgICBcbiAgICAgIHNsaWRlc1tsZW5ndGhdID4gMSAmJiBvbiggZWxlbWVudCwgdG91Y2hFdmVudHMuc3RhcnQsIHRvdWNoRG93bkhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyICk7XG4gIFxuICAgICAgcmlnaHRBcnJvdyAmJiBvbiggcmlnaHRBcnJvdywgY2xpY2tFdmVudCwgY29udHJvbHNIYW5kbGVyICk7XG4gICAgICBsZWZ0QXJyb3cgJiYgb24oIGxlZnRBcnJvdywgY2xpY2tFdmVudCwgY29udHJvbHNIYW5kbGVyICk7XG4gICAgXG4gICAgICBpbmRpY2F0b3IgJiYgb24oIGluZGljYXRvciwgY2xpY2tFdmVudCwgaW5kaWNhdG9ySGFuZGxlciApO1xuICAgICAgc2VsZltrZXlib2FyZF0gJiYgb24oIGdsb2JhbE9iamVjdCwga2V5ZG93bkV2ZW50LCBrZXlIYW5kbGVyICk7XG4gIFxuICAgIH1cbiAgICBpZiAoc2VsZi5nZXRBY3RpdmVJbmRleCgpPDApIHtcbiAgICAgIHNsaWRlc1tsZW5ndGhdICYmIGFkZENsYXNzKHNsaWRlc1swXSxhY3RpdmUpO1xuICAgICAgaW5kaWNhdG9yc1tsZW5ndGhdICYmIHNldEFjdGl2ZVBhZ2UoMCk7XG4gICAgfVxuICBcbiAgICBpZiAoIHNlbGZbaW50ZXJ2YWxdICl7IHNlbGYuY3ljbGUoKTsgfVxuICAgIGVsZW1lbnRbc3RyaW5nQ2Fyb3VzZWxdID0gc2VsZjtcbiAgfTtcbiAgXG4gIC8vIENBUk9VU0VMIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKCBbIHN0cmluZ0Nhcm91c2VsLCBDYXJvdXNlbCwgJ1snK2RhdGFSaWRlKyc9XCJjYXJvdXNlbFwiXScgXSApO1xuICBcbiAgXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IENvbGxhcHNlXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgXG4gIC8vIENPTExBUFNFIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuICB2YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiggZWxlbWVudCwgb3B0aW9ucyApIHtcbiAgXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIFxuICAgIC8vIHNldCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFxuICAgIC8vIGV2ZW50IHRhcmdldHMgYW5kIGNvbnN0YW50c1xuICAgIHZhciBhY2NvcmRpb24gPSBudWxsLCBjb2xsYXBzZSA9IG51bGwsIHNlbGYgPSB0aGlzLCBcbiAgICAgIGFjY29yZGlvbkRhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oJ2RhdGEtcGFyZW50JyksXG4gICAgICBhY3RpdmVDb2xsYXBzZSwgYWN0aXZlRWxlbWVudCxcbiAgXG4gICAgICAvLyBjb21wb25lbnQgc3RyaW5nc1xuICAgICAgY29tcG9uZW50ID0gJ2NvbGxhcHNlJyxcbiAgICAgIGNvbGxhcHNlZCA9ICdjb2xsYXBzZWQnLFxuICAgICAgaXNBbmltYXRpbmcgPSAnaXNBbmltYXRpbmcnLFxuICBcbiAgICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgICAgb3BlbkFjdGlvbiA9IGZ1bmN0aW9uKGNvbGxhcHNlRWxlbWVudCx0b2dnbGUpIHtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChjb2xsYXBzZUVsZW1lbnQsIHNob3dFdmVudCwgY29tcG9uZW50KTtcbiAgICAgICAgY29sbGFwc2VFbGVtZW50W2lzQW5pbWF0aW5nXSA9IHRydWU7XG4gICAgICAgIGFkZENsYXNzKGNvbGxhcHNlRWxlbWVudCxjb2xsYXBzaW5nKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoY29sbGFwc2VFbGVtZW50LGNvbXBvbmVudCk7XG4gICAgICAgIGNvbGxhcHNlRWxlbWVudFtzdHlsZV1baGVpZ2h0XSA9IGNvbGxhcHNlRWxlbWVudFtzY3JvbGxIZWlnaHRdICsgJ3B4JztcbiAgICAgICAgXG4gICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGNvbGxhcHNlRWxlbWVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29sbGFwc2VFbGVtZW50W2lzQW5pbWF0aW5nXSA9IGZhbHNlO1xuICAgICAgICAgIGNvbGxhcHNlRWxlbWVudFtzZXRBdHRyaWJ1dGVdKGFyaWFFeHBhbmRlZCwndHJ1ZScpO1xuICAgICAgICAgIHRvZ2dsZVtzZXRBdHRyaWJ1dGVdKGFyaWFFeHBhbmRlZCwndHJ1ZScpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGNvbGxhcHNlRWxlbWVudCxjb2xsYXBzaW5nKTtcbiAgICAgICAgICBhZGRDbGFzcyhjb2xsYXBzZUVsZW1lbnQsIGNvbXBvbmVudCk7XG4gICAgICAgICAgYWRkQ2xhc3MoY29sbGFwc2VFbGVtZW50LHNob3dDbGFzcyk7XG4gICAgICAgICAgY29sbGFwc2VFbGVtZW50W3N0eWxlXVtoZWlnaHRdID0gJyc7XG4gICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChjb2xsYXBzZUVsZW1lbnQsIHNob3duRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNsb3NlQWN0aW9uID0gZnVuY3Rpb24oY29sbGFwc2VFbGVtZW50LHRvZ2dsZSkge1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGNvbGxhcHNlRWxlbWVudCwgaGlkZUV2ZW50LCBjb21wb25lbnQpO1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnRbaXNBbmltYXRpbmddID0gdHJ1ZTtcbiAgICAgICAgY29sbGFwc2VFbGVtZW50W3N0eWxlXVtoZWlnaHRdID0gY29sbGFwc2VFbGVtZW50W3Njcm9sbEhlaWdodF0gKyAncHgnOyAvLyBzZXQgaGVpZ2h0IGZpcnN0XG4gICAgICAgIHJlbW92ZUNsYXNzKGNvbGxhcHNlRWxlbWVudCxjb21wb25lbnQpO1xuICAgICAgICByZW1vdmVDbGFzcyhjb2xsYXBzZUVsZW1lbnQsc2hvd0NsYXNzKTtcbiAgICAgICAgYWRkQ2xhc3MoY29sbGFwc2VFbGVtZW50LGNvbGxhcHNpbmcpO1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnRbb2Zmc2V0V2lkdGhdOyAvLyBmb3JjZSByZWZsb3cgdG8gZW5hYmxlIHRyYW5zaXRpb25cbiAgICAgICAgY29sbGFwc2VFbGVtZW50W3N0eWxlXVtoZWlnaHRdID0gJzBweCc7XG4gICAgICAgIFxuICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChjb2xsYXBzZUVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbGxhcHNlRWxlbWVudFtpc0FuaW1hdGluZ10gPSBmYWxzZTtcbiAgICAgICAgICBjb2xsYXBzZUVsZW1lbnRbc2V0QXR0cmlidXRlXShhcmlhRXhwYW5kZWQsJ2ZhbHNlJyk7XG4gICAgICAgICAgdG9nZ2xlW3NldEF0dHJpYnV0ZV0oYXJpYUV4cGFuZGVkLCdmYWxzZScpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGNvbGxhcHNlRWxlbWVudCxjb2xsYXBzaW5nKTtcbiAgICAgICAgICBhZGRDbGFzcyhjb2xsYXBzZUVsZW1lbnQsY29tcG9uZW50KTtcbiAgICAgICAgICBjb2xsYXBzZUVsZW1lbnRbc3R5bGVdW2hlaWdodF0gPSAnJztcbiAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGNvbGxhcHNlRWxlbWVudCwgaGlkZGVuRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldFRhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHJlZiA9IGVsZW1lbnQuaHJlZiAmJiBlbGVtZW50W2dldEF0dHJpYnV0ZV0oJ2hyZWYnKSxcbiAgICAgICAgICBwYXJlbnQgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YVRhcmdldCksXG4gICAgICAgICAgaWQgPSBocmVmIHx8ICggcGFyZW50ICYmIHBhcmVudC5jaGFyQXQoMCkgPT09ICcjJyApICYmIHBhcmVudDtcbiAgICAgICAgcmV0dXJuIGlkICYmIHF1ZXJ5RWxlbWVudChpZCk7XG4gICAgICB9O1xuICAgIFxuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgdGhpcy50b2dnbGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICBlW3ByZXZlbnREZWZhdWx0XSgpO1xuICAgICAgaWYgKCFoYXNDbGFzcyhjb2xsYXBzZSxzaG93Q2xhc3MpKSB7IHNlbGYuc2hvdygpOyB9IFxuICAgICAgZWxzZSB7IHNlbGYuaGlkZSgpOyB9XG4gICAgfTtcbiAgICB0aGlzLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICggY29sbGFwc2VbaXNBbmltYXRpbmddICkgcmV0dXJuOyAgICBcbiAgICAgIGNsb3NlQWN0aW9uKGNvbGxhcHNlLGVsZW1lbnQpO1xuICAgICAgYWRkQ2xhc3MoZWxlbWVudCxjb2xsYXBzZWQpO1xuICAgIH07XG4gICAgdGhpcy5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIGFjY29yZGlvbiApIHtcbiAgICAgICAgYWN0aXZlQ29sbGFwc2UgPSBxdWVyeUVsZW1lbnQoJy4nK2NvbXBvbmVudCsnLicrc2hvd0NsYXNzLGFjY29yZGlvbik7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVDb2xsYXBzZSAmJiAocXVlcnlFbGVtZW50KCdbJytkYXRhVGFyZ2V0Kyc9XCIjJythY3RpdmVDb2xsYXBzZS5pZCsnXCJdJyxhY2NvcmRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgfHwgcXVlcnlFbGVtZW50KCdbaHJlZj1cIiMnK2FjdGl2ZUNvbGxhcHNlLmlkKydcIl0nLGFjY29yZGlvbikgKTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoICFjb2xsYXBzZVtpc0FuaW1hdGluZ10gfHwgYWN0aXZlQ29sbGFwc2UgJiYgIWFjdGl2ZUNvbGxhcHNlW2lzQW5pbWF0aW5nXSApIHtcbiAgICAgICAgaWYgKCBhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUNvbGxhcHNlICE9PSBjb2xsYXBzZSApIHtcbiAgICAgICAgICBjbG9zZUFjdGlvbihhY3RpdmVDb2xsYXBzZSxhY3RpdmVFbGVtZW50KTsgXG4gICAgICAgICAgYWRkQ2xhc3MoYWN0aXZlRWxlbWVudCxjb2xsYXBzZWQpO1xuICAgICAgICB9XG4gICAgICAgIG9wZW5BY3Rpb24oY29sbGFwc2UsZWxlbWVudCk7XG4gICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsY29sbGFwc2VkKTtcbiAgICAgIH1cbiAgICB9O1xuICBcbiAgICAvLyBpbml0XG4gICAgaWYgKCAhKHN0cmluZ0NvbGxhcHNlIGluIGVsZW1lbnQgKSApIHsgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICAgIG9uKGVsZW1lbnQsIGNsaWNrRXZlbnQsIHNlbGYudG9nZ2xlKTtcbiAgICB9XG4gICAgY29sbGFwc2UgPSBnZXRUYXJnZXQoKTtcbiAgICBjb2xsYXBzZVtpc0FuaW1hdGluZ10gPSBmYWxzZTsgIC8vIHdoZW4gdHJ1ZSBpdCB3aWxsIHByZXZlbnQgY2xpY2sgaGFuZGxlcnMgIFxuICAgIGFjY29yZGlvbiA9IHF1ZXJ5RWxlbWVudChvcHRpb25zLnBhcmVudCkgfHwgYWNjb3JkaW9uRGF0YSAmJiBnZXRDbG9zZXN0KGVsZW1lbnQsIGFjY29yZGlvbkRhdGEpO1xuICAgIGVsZW1lbnRbc3RyaW5nQ29sbGFwc2VdID0gc2VsZjtcbiAgfTtcbiAgXG4gIC8vIENPTExBUFNFIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKCBbIHN0cmluZ0NvbGxhcHNlLCBDb2xsYXBzZSwgJ1snK2RhdGFUb2dnbGUrJz1cImNvbGxhcHNlXCJdJyBdICk7XG4gIFxuICBcbiAgLyogTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgRHJvcGRvd25cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIFxuICAvLyBEUk9QRE9XTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT1cbiAgdmFyIERyb3Bkb3duID0gZnVuY3Rpb24oIGVsZW1lbnQsIG9wdGlvbiApIHtcbiAgICAgIFxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBcbiAgICAvLyBzZXQgb3B0aW9uXG4gICAgdGhpcy5wZXJzaXN0ID0gb3B0aW9uID09PSB0cnVlIHx8IGVsZW1lbnRbZ2V0QXR0cmlidXRlXSgnZGF0YS1wZXJzaXN0JykgPT09ICd0cnVlJyB8fCBmYWxzZTtcbiAgXG4gICAgLy8gY29uc3RhbnRzLCBldmVudCB0YXJnZXRzLCBzdHJpbmdzXG4gICAgdmFyIHNlbGYgPSB0aGlzLCBjaGlsZHJlbiA9ICdjaGlsZHJlbicsXG4gICAgICBwYXJlbnQgPSBlbGVtZW50W3BhcmVudE5vZGVdLFxuICAgICAgY29tcG9uZW50ID0gJ2Ryb3Bkb3duJywgb3BlbiA9ICdvcGVuJyxcbiAgICAgIHJlbGF0ZWRUYXJnZXQgPSBudWxsLFxuICAgICAgbWVudSA9IHF1ZXJ5RWxlbWVudCgnLmRyb3Bkb3duLW1lbnUnLCBwYXJlbnQpLFxuICAgICAgbWVudUl0ZW1zID0gKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzZXQgPSBtZW51W2NoaWxkcmVuXSwgbmV3U2V0ID0gW107XG4gICAgICAgIGZvciAoIHZhciBpPTA7IGk8c2V0W2xlbmd0aF07IGkrKyApe1xuICAgICAgICAgIHNldFtpXVtjaGlsZHJlbl1bbGVuZ3RoXSAmJiAoc2V0W2ldW2NoaWxkcmVuXVswXS50YWdOYW1lID09PSAnQScgJiYgbmV3U2V0W3B1c2hdKHNldFtpXVtjaGlsZHJlbl1bMF0pKTtcbiAgICAgICAgICBzZXRbaV0udGFnTmFtZSA9PT0gJ0EnICYmIG5ld1NldFtwdXNoXShzZXRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTZXQ7XG4gICAgICB9KSgpLFxuICBcbiAgICAgIC8vIHByZXZlbnREZWZhdWx0IG9uIGVtcHR5IGFuY2hvciBsaW5rc1xuICAgICAgcHJldmVudEVtcHR5QW5jaG9yID0gZnVuY3Rpb24oYW5jaG9yKXtcbiAgICAgICAgKGFuY2hvci5ocmVmICYmIGFuY2hvci5ocmVmLnNsaWNlKC0xKSA9PT0gJyMnIHx8IGFuY2hvcltwYXJlbnROb2RlXSAmJiBhbmNob3JbcGFyZW50Tm9kZV0uaHJlZiBcbiAgICAgICAgICAmJiBhbmNob3JbcGFyZW50Tm9kZV0uaHJlZi5zbGljZSgtMSkgPT09ICcjJykgJiYgdGhpc1twcmV2ZW50RGVmYXVsdF0oKTsgICAgXG4gICAgICB9LFxuICBcbiAgICAgIC8vIHRvZ2dsZSBkaXNtaXNzaWJsZSBldmVudHNcbiAgICAgIHRvZ2dsZURpc21pc3MgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgdHlwZSA9IGVsZW1lbnRbb3Blbl0gPyBvbiA6IG9mZjtcbiAgICAgICAgdHlwZShET0MsIGNsaWNrRXZlbnQsIGRpc21pc3NIYW5kbGVyKTsgXG4gICAgICAgIHR5cGUoRE9DLCBrZXlkb3duRXZlbnQsIHByZXZlbnRTY3JvbGwpO1xuICAgICAgICB0eXBlKERPQywga2V5dXBFdmVudCwga2V5SGFuZGxlcik7XG4gICAgICAgIHR5cGUoRE9DLCBmb2N1c0V2ZW50LCBkaXNtaXNzSGFuZGxlciwgdHJ1ZSk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIGhhbmRsZXJzXG4gICAgICBkaXNtaXNzSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZVt0YXJnZXRdLCBoYXNEYXRhID0gZXZlbnRUYXJnZXQgJiYgKGV2ZW50VGFyZ2V0W2dldEF0dHJpYnV0ZV0oZGF0YVRvZ2dsZSkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBldmVudFRhcmdldFtwYXJlbnROb2RlXSAmJiBnZXRBdHRyaWJ1dGUgaW4gZXZlbnRUYXJnZXRbcGFyZW50Tm9kZV0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBldmVudFRhcmdldFtwYXJlbnROb2RlXVtnZXRBdHRyaWJ1dGVdKGRhdGFUb2dnbGUpKTtcbiAgICAgICAgaWYgKCBlLnR5cGUgPT09IGZvY3VzRXZlbnQgJiYgKGV2ZW50VGFyZ2V0ID09PSBlbGVtZW50IHx8IGV2ZW50VGFyZ2V0ID09PSBtZW51IHx8IG1lbnVbY29udGFpbnNdKGV2ZW50VGFyZ2V0KSApICkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIChldmVudFRhcmdldCA9PT0gbWVudSB8fCBtZW51W2NvbnRhaW5zXShldmVudFRhcmdldCkpICYmIChzZWxmLnBlcnNpc3QgfHwgaGFzRGF0YSkgKSB7IHJldHVybjsgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0ID0gZXZlbnRUYXJnZXQgPT09IGVsZW1lbnQgfHwgZWxlbWVudFtjb250YWluc10oZXZlbnRUYXJnZXQpID8gZWxlbWVudCA6IG51bGw7XG4gICAgICAgICAgaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZlbnRFbXB0eUFuY2hvci5jYWxsKGUsZXZlbnRUYXJnZXQpO1xuICAgICAgfSxcbiAgICAgIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICAgIHNob3coKTtcbiAgICAgICAgcHJldmVudEVtcHR5QW5jaG9yLmNhbGwoZSxlW3RhcmdldF0pO1xuICAgICAgfSxcbiAgICAgIHByZXZlbnRTY3JvbGwgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgdmFyIGtleSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlO1xuICAgICAgICBpZigga2V5ID09PSAzOCB8fCBrZXkgPT09IDQwICkgeyBlW3ByZXZlbnREZWZhdWx0XSgpOyB9XG4gICAgICB9LFxuICAgICAga2V5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGUsXG4gICAgICAgICAgYWN0aXZlSXRlbSA9IERPQy5hY3RpdmVFbGVtZW50LFxuICAgICAgICAgIGlkeCA9IG1lbnVJdGVtc1tpbmRleE9mXShhY3RpdmVJdGVtKSxcbiAgICAgICAgICBpc1NhbWVFbGVtZW50ID0gYWN0aXZlSXRlbSA9PT0gZWxlbWVudCxcbiAgICAgICAgICBpc0luc2lkZU1lbnUgPSBtZW51W2NvbnRhaW5zXShhY3RpdmVJdGVtKSxcbiAgICAgICAgICBpc01lbnVJdGVtID0gYWN0aXZlSXRlbVtwYXJlbnROb2RlXSA9PT0gbWVudSB8fCBhY3RpdmVJdGVtW3BhcmVudE5vZGVdW3BhcmVudE5vZGVdID09PSBtZW51OyAgICAgICAgICBcbiAgXG4gICAgICAgIGlmICggaXNNZW51SXRlbSApIHsgLy8gbmF2aWdhdGUgdXAgfCBkb3duXG4gICAgICAgICAgaWR4ID0gaXNTYW1lRWxlbWVudCA/IDAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGtleSA9PT0gMzggPyAoaWR4PjE/aWR4LTE6MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoga2V5ID09PSA0MCA/IChpZHg8bWVudUl0ZW1zW2xlbmd0aF0tMT9pZHgrMTppZHgpIDogaWR4O1xuICAgICAgICAgIG1lbnVJdGVtc1tpZHhdICYmIHNldEZvY3VzKG1lbnVJdGVtc1tpZHhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIChtZW51SXRlbXNbbGVuZ3RoXSAmJiBpc01lbnVJdGVtIC8vIG1lbnUgaGFzIGl0ZW1zXG4gICAgICAgICAgICAgIHx8ICFtZW51SXRlbXNbbGVuZ3RoXSAmJiAoaXNJbnNpZGVNZW51IHx8IGlzU2FtZUVsZW1lbnQpICAvLyBtZW51IG1pZ2h0IGJlIGEgZm9ybVxuICAgICAgICAgICAgICB8fCAhaXNJbnNpZGVNZW51ICkgLy8gb3IgdGhlIGZvY3VzZWQgZWxlbWVudCBpcyBub3QgaW4gdGhlIG1lbnUgYXQgYWxsXG4gICAgICAgICAgICAgICYmIGVsZW1lbnRbb3Blbl0gJiYga2V5ID09PSAyNyAgLy8gbWVudSBtdXN0IGJlIG9wZW5cbiAgICAgICAgKSB7XG4gICAgICAgICAgc2VsZi50b2dnbGUoKTtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgXG4gICAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICAgIHNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIHNob3dFdmVudCwgY29tcG9uZW50LCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgYWRkQ2xhc3MobWVudSxzaG93Q2xhc3MpO1xuICAgICAgICBhZGRDbGFzcyhwYXJlbnQsc2hvd0NsYXNzKTtcbiAgICAgICAgZWxlbWVudFtzZXRBdHRyaWJ1dGVdKGFyaWFFeHBhbmRlZCx0cnVlKTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIHNob3duRXZlbnQsIGNvbXBvbmVudCwgcmVsYXRlZFRhcmdldCk7XG4gICAgICAgIGVsZW1lbnRbb3Blbl0gPSB0cnVlO1xuICAgICAgICBvZmYoZWxlbWVudCwgY2xpY2tFdmVudCwgY2xpY2tIYW5kbGVyKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHNldEZvY3VzKCBtZW51W2dldEVsZW1lbnRzQnlUYWdOYW1lXSgnSU5QVVQnKVswXSB8fCBlbGVtZW50ICk7IC8vIGZvY3VzIHRoZSBmaXJzdCBpbnB1dCBpdGVtIHwgZWxlbWVudFxuICAgICAgICAgIHRvZ2dsZURpc21pc3MoKTtcbiAgICAgICAgfSwxKTtcbiAgICAgIH0sXG4gICAgICBoaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwocGFyZW50LCBoaWRlRXZlbnQsIGNvbXBvbmVudCwgcmVsYXRlZFRhcmdldCk7XG4gICAgICAgIHJlbW92ZUNsYXNzKG1lbnUsc2hvd0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MocGFyZW50LHNob3dDbGFzcyk7XG4gICAgICAgIGVsZW1lbnRbc2V0QXR0cmlidXRlXShhcmlhRXhwYW5kZWQsZmFsc2UpO1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKHBhcmVudCwgaGlkZGVuRXZlbnQsIGNvbXBvbmVudCwgcmVsYXRlZFRhcmdldCk7XG4gICAgICAgIGVsZW1lbnRbb3Blbl0gPSBmYWxzZTtcbiAgICAgICAgdG9nZ2xlRGlzbWlzcygpO1xuICAgICAgICBzZXRGb2N1cyhlbGVtZW50KTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpeyBvbihlbGVtZW50LCBjbGlja0V2ZW50LCBjbGlja0hhbmRsZXIpOyB9LDEpO1xuICAgICAgfTtcbiAgXG4gICAgLy8gc2V0IGluaXRpYWwgc3RhdGUgdG8gY2xvc2VkXG4gICAgZWxlbWVudFtvcGVuXSA9IGZhbHNlO1xuICBcbiAgICAvLyBwdWJsaWMgbWV0aG9kc1xuICAgIHRoaXMudG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoaGFzQ2xhc3MocGFyZW50LHNob3dDbGFzcykgJiYgZWxlbWVudFtvcGVuXSkgeyBoaWRlKCk7IH0gXG4gICAgICBlbHNlIHsgc2hvdygpOyB9XG4gICAgfTtcbiAgXG4gICAgLy8gaW5pdFxuICAgIGlmICggIShzdHJpbmdEcm9wZG93biBpbiBlbGVtZW50KSApIHsgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICAgICF0YWJpbmRleCBpbiBtZW51ICYmIG1lbnVbc2V0QXR0cmlidXRlXSh0YWJpbmRleCwgJzAnKTsgLy8gRml4IG9uYmx1ciBvbiBDaHJvbWUgfCBTYWZhcmlcbiAgICAgIG9uKGVsZW1lbnQsIGNsaWNrRXZlbnQsIGNsaWNrSGFuZGxlcik7XG4gICAgfVxuICBcbiAgICBlbGVtZW50W3N0cmluZ0Ryb3Bkb3duXSA9IHNlbGY7XG4gIH07XG4gIFxuICAvLyBEUk9QRE9XTiBEQVRBIEFQSVxuICAvLyA9PT09PT09PT09PT09PT09PVxuICBzdXBwb3J0c1twdXNoXSggW3N0cmluZ0Ryb3Bkb3duLCBEcm9wZG93biwgJ1snK2RhdGFUb2dnbGUrJz1cImRyb3Bkb3duXCJdJ10gKTtcbiAgXG4gIFxuICAvKiBOYXRpdmUgSmF2YXNjcmlwdCBmb3IgQm9vdHN0cmFwIDQgfCBNb2RhbFxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgXG4gIC8vIE1PREFMIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09XG4gIHZhciBNb2RhbCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHsgLy8gZWxlbWVudCBjYW4gYmUgdGhlIG1vZGFsL3RyaWdnZXJpbmcgYnV0dG9uXG4gIFxuICAgIC8vIHRoZSBtb2RhbCAoYm90aCBKYXZhU2NyaXB0IC8gREFUQSBBUEkgaW5pdCkgLyB0cmlnZ2VyaW5nIGJ1dHRvbiBlbGVtZW50IChEQVRBIEFQSSlcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBcbiAgICAgIC8vIHN0cmluZ3NcbiAgICAgIHZhciBjb21wb25lbnQgPSAnbW9kYWwnLFxuICAgICAgICBzdGF0aWNTdHJpbmcgPSAnc3RhdGljJyxcbiAgICAgICAgbW9kYWxUcmlnZ2VyID0gJ21vZGFsVHJpZ2dlcicsXG4gICAgICAgIHBhZGRpbmdSaWdodCA9ICdwYWRkaW5nUmlnaHQnLFxuICAgICAgICBtb2RhbEJhY2tkcm9wU3RyaW5nID0gJ21vZGFsLWJhY2tkcm9wJyxcbiAgICAgICAgaXNBbmltYXRpbmcgPSAnaXNBbmltYXRpbmcnLFxuICAgICAgICAvLyBkZXRlcm1pbmUgbW9kYWwsIHRyaWdnZXJpbmcgZWxlbWVudFxuICAgICAgICBidG5DaGVjayA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhVGFyZ2V0KXx8ZWxlbWVudFtnZXRBdHRyaWJ1dGVdKCdocmVmJyksXG4gICAgICAgIGNoZWNrTW9kYWwgPSBxdWVyeUVsZW1lbnQoIGJ0bkNoZWNrICksXG4gICAgICAgIG1vZGFsID0gaGFzQ2xhc3MoZWxlbWVudCxjb21wb25lbnQpID8gZWxlbWVudCA6IGNoZWNrTW9kYWw7XG4gIFxuICAgICAgaWYgKCBoYXNDbGFzcyhlbGVtZW50LCBjb21wb25lbnQpICkgeyBlbGVtZW50ID0gbnVsbDsgfSAvLyBtb2RhbCBpcyBub3cgaW5kZXBlbmRlbnQgb2YgaXQncyB0cmlnZ2VyaW5nIGVsZW1lbnRcbiAgXG4gICAgaWYgKCAhbW9kYWwgKSB7IHJldHVybjsgfSAvLyBpbnZhbGlkYXRlXG4gIFxuICAgIC8vIHNldCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFxuICAgIHRoaXNba2V5Ym9hcmRdID0gb3B0aW9uc1trZXlib2FyZF0gPT09IGZhbHNlIHx8IG1vZGFsW2dldEF0dHJpYnV0ZV0oZGF0YUtleWJvYXJkKSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdHJ1ZTtcbiAgICB0aGlzW2JhY2tkcm9wXSA9IG9wdGlvbnNbYmFja2Ryb3BdID09PSBzdGF0aWNTdHJpbmcgfHwgbW9kYWxbZ2V0QXR0cmlidXRlXShkYXRhYmFja2Ryb3ApID09PSBzdGF0aWNTdHJpbmcgPyBzdGF0aWNTdHJpbmcgOiB0cnVlO1xuICAgIHRoaXNbYmFja2Ryb3BdID0gb3B0aW9uc1tiYWNrZHJvcF0gPT09IGZhbHNlIHx8IG1vZGFsW2dldEF0dHJpYnV0ZV0oZGF0YWJhY2tkcm9wKSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdGhpc1tiYWNrZHJvcF07XG4gICAgdGhpc1thbmltYXRpb25dID0gaGFzQ2xhc3MobW9kYWwsICdmYWRlJykgPyB0cnVlIDogZmFsc2U7XG4gICAgdGhpc1tjb250ZW50XSAgPSBvcHRpb25zW2NvbnRlbnRdOyAvLyBKYXZhU2NyaXB0IG9ubHlcbiAgXG4gICAgLy8gc2V0IGFuIGluaXRpYWwgc3RhdGUgb2YgdGhlIG1vZGFsXG4gICAgbW9kYWxbaXNBbmltYXRpbmddID0gZmFsc2U7XG4gICAgXG4gICAgLy8gYmluZCwgY29uc3RhbnRzLCBldmVudCB0YXJnZXRzIGFuZCBvdGhlciB2YXJzXG4gICAgdmFyIHNlbGYgPSB0aGlzLCByZWxhdGVkVGFyZ2V0ID0gbnVsbCxcbiAgICAgIGJvZHlJc092ZXJmbG93aW5nLCBzY3JvbGxCYXJXaWR0aCwgb3ZlcmxheSwgb3ZlcmxheURlbGF5LCBtb2RhbFRpbWVyLFxuICBcbiAgICAgIC8vIGFsc28gZmluZCBmaXhlZC10b3AgLyBmaXhlZC1ib3R0b20gaXRlbXNcbiAgICAgIGZpeGVkSXRlbXMgPSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKEhUTUwsZml4ZWRUb3ApLmNvbmNhdChnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKEhUTUwsZml4ZWRCb3R0b20pKSxcbiAgXG4gICAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICAgIGdldFdpbmRvd1dpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBodG1sUmVjdCA9IEhUTUxbZ2V0Qm91bmRpbmdDbGllbnRSZWN0XSgpO1xuICAgICAgICByZXR1cm4gZ2xvYmFsT2JqZWN0W2lubmVyV2lkdGhdIHx8IChodG1sUmVjdFtyaWdodF0gLSBNYXRoLmFicyhodG1sUmVjdFtsZWZ0XSkpO1xuICAgICAgfSxcbiAgICAgIHNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJvZHlTdHlsZSA9IGdsb2JhbE9iamVjdFtnZXRDb21wdXRlZFN0eWxlXShET0NbYm9keV0pLFxuICAgICAgICAgICAgYm9keVBhZCA9IHBhcnNlSW50KChib2R5U3R5bGVbcGFkZGluZ1JpZ2h0XSksIDEwKSwgaXRlbVBhZDtcbiAgICAgICAgaWYgKGJvZHlJc092ZXJmbG93aW5nKSB7XG4gICAgICAgICAgRE9DW2JvZHldW3N0eWxlXVtwYWRkaW5nUmlnaHRdID0gKGJvZHlQYWQgKyBzY3JvbGxCYXJXaWR0aCkgKyAncHgnO1xuICAgICAgICAgIG1vZGFsW3N0eWxlXVtwYWRkaW5nUmlnaHRdID0gc2Nyb2xsQmFyV2lkdGgrJ3B4JztcbiAgICAgICAgICBpZiAoZml4ZWRJdGVtc1tsZW5ndGhdKXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZml4ZWRJdGVtc1tsZW5ndGhdOyBpKyspIHtcbiAgICAgICAgICAgICAgaXRlbVBhZCA9IGdsb2JhbE9iamVjdFtnZXRDb21wdXRlZFN0eWxlXShmaXhlZEl0ZW1zW2ldKVtwYWRkaW5nUmlnaHRdO1xuICAgICAgICAgICAgICBmaXhlZEl0ZW1zW2ldW3N0eWxlXVtwYWRkaW5nUmlnaHRdID0gKCBwYXJzZUludChpdGVtUGFkKSArIHNjcm9sbEJhcldpZHRoKSArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIERPQ1tib2R5XVtzdHlsZV1bcGFkZGluZ1JpZ2h0XSA9ICcnO1xuICAgICAgICBtb2RhbFtzdHlsZV1bcGFkZGluZ1JpZ2h0XSA9ICcnO1xuICAgICAgICBpZiAoZml4ZWRJdGVtc1tsZW5ndGhdKXtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpeGVkSXRlbXNbbGVuZ3RoXTsgaSsrKSB7XG4gICAgICAgICAgICBmaXhlZEl0ZW1zW2ldW3N0eWxlXVtwYWRkaW5nUmlnaHRdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWVhc3VyZVNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHsgLy8gdGh4IHdhbHNoXG4gICAgICAgIHZhciBzY3JvbGxEaXYgPSBET0NbY3JlYXRlRWxlbWVudF0oJ2RpdicpLCB3aWR0aFZhbHVlO1xuICAgICAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gY29tcG9uZW50Kyctc2Nyb2xsYmFyLW1lYXN1cmUnOyAvLyB0aGlzIGlzIGhlcmUgdG8gc3RheVxuICAgICAgICBET0NbYm9keV1bYXBwZW5kQ2hpbGRdKHNjcm9sbERpdik7XG4gICAgICAgIHdpZHRoVmFsdWUgPSBzY3JvbGxEaXZbb2Zmc2V0V2lkdGhdIC0gc2Nyb2xsRGl2W2NsaWVudFdpZHRoXTtcbiAgICAgICAgRE9DW2JvZHldLnJlbW92ZUNoaWxkKHNjcm9sbERpdik7XG4gICAgICAgIHJldHVybiB3aWR0aFZhbHVlO1xuICAgICAgfSxcbiAgICAgIGNoZWNrU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBib2R5SXNPdmVyZmxvd2luZyA9IERPQ1tib2R5XVtjbGllbnRXaWR0aF0gPCBnZXRXaW5kb3dXaWR0aCgpO1xuICAgICAgICBzY3JvbGxCYXJXaWR0aCA9IG1lYXN1cmVTY3JvbGxiYXIoKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdPdmVybGF5ID0gRE9DW2NyZWF0ZUVsZW1lbnRdKCdkaXYnKTtcbiAgICAgICAgb3ZlcmxheSA9IHF1ZXJ5RWxlbWVudCgnLicrbW9kYWxCYWNrZHJvcFN0cmluZyk7XG4gIFxuICAgICAgICBpZiAoIG92ZXJsYXkgPT09IG51bGwgKSB7XG4gICAgICAgICAgbmV3T3ZlcmxheVtzZXRBdHRyaWJ1dGVdKCdjbGFzcycsIG1vZGFsQmFja2Ryb3BTdHJpbmcgKyAoc2VsZlthbmltYXRpb25dID8gJyBmYWRlJyA6ICcnKSk7XG4gICAgICAgICAgb3ZlcmxheSA9IG5ld092ZXJsYXk7XG4gICAgICAgICAgRE9DW2JvZHldW2FwcGVuZENoaWxkXShvdmVybGF5KTtcbiAgICAgICAgfVxuICAgICAgICBtb2RhbE92ZXJsYXkgPSAxO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZU92ZXJsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgb3ZlcmxheSA9IHF1ZXJ5RWxlbWVudCgnLicrbW9kYWxCYWNrZHJvcFN0cmluZyk7XG4gICAgICAgIGlmICggb3ZlcmxheSAmJiBvdmVybGF5ICE9PSBudWxsICYmIHR5cGVvZiBvdmVybGF5ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICBtb2RhbE92ZXJsYXkgPSAwO1xuICAgICAgICAgIERPQ1tib2R5XS5yZW1vdmVDaGlsZChvdmVybGF5KTsgb3ZlcmxheSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyB0cmlnZ2Vyc1xuICAgICAgdHJpZ2dlclNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0Rm9jdXMobW9kYWwpO1xuICAgICAgICBtb2RhbFtpc0FuaW1hdGluZ10gPSBmYWxzZTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChtb2RhbCwgc2hvd25FdmVudCwgY29tcG9uZW50LCByZWxhdGVkVGFyZ2V0KTtcbiAgXG4gICAgICAgIG9uKGdsb2JhbE9iamVjdCwgcmVzaXplRXZlbnQsIHNlbGYudXBkYXRlLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgICAgIG9uKG1vZGFsLCBjbGlja0V2ZW50LCBkaXNtaXNzSGFuZGxlcik7XG4gICAgICAgIG9uKERPQywga2V5ZG93bkV2ZW50LCBrZXlIYW5kbGVyKTsgICAgICBcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VySGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtb2RhbFtzdHlsZV0uZGlzcGxheSA9ICcnO1xuICAgICAgICBlbGVtZW50ICYmIChzZXRGb2N1cyhlbGVtZW50KSk7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIGhpZGRlbkV2ZW50LCBjb21wb25lbnQpO1xuICBcbiAgICAgICAgKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgaWYgKCFnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKERPQyxjb21wb25lbnQrJyAnK3Nob3dDbGFzcylbMF0pIHtcbiAgICAgICAgICAgIHJlc2V0U2Nyb2xsYmFyKCk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhET0NbYm9keV0sY29tcG9uZW50Kyctb3BlbicpO1xuICAgICAgICAgICAgb3ZlcmxheSAmJiBoYXNDbGFzcyhvdmVybGF5LCdmYWRlJykgPyAocmVtb3ZlQ2xhc3Mob3ZlcmxheSxzaG93Q2xhc3MpLCBlbXVsYXRlVHJhbnNpdGlvbkVuZChvdmVybGF5LHJlbW92ZU92ZXJsYXkpKVxuICAgICAgICAgICAgOiByZW1vdmVPdmVybGF5KCk7XG4gIFxuICAgICAgICAgICAgb2ZmKGdsb2JhbE9iamVjdCwgcmVzaXplRXZlbnQsIHNlbGYudXBkYXRlLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgICAgICAgICBvZmYobW9kYWwsIGNsaWNrRXZlbnQsIGRpc21pc3NIYW5kbGVyKTtcbiAgICAgICAgICAgIG9mZihET0MsIGtleWRvd25FdmVudCwga2V5SGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KCkpO1xuICAgICAgICBtb2RhbFtpc0FuaW1hdGluZ10gPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICAvLyBoYW5kbGVyc1xuICAgICAgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIG1vZGFsW2lzQW5pbWF0aW5nXSApIHJldHVybjtcbiAgXG4gICAgICAgIHZhciBjbGlja1RhcmdldCA9IGVbdGFyZ2V0XTtcbiAgICAgICAgY2xpY2tUYXJnZXQgPSBjbGlja1RhcmdldFtoYXNBdHRyaWJ1dGVdKGRhdGFUYXJnZXQpIHx8IGNsaWNrVGFyZ2V0W2hhc0F0dHJpYnV0ZV0oJ2hyZWYnKSA/IGNsaWNrVGFyZ2V0IDogY2xpY2tUYXJnZXRbcGFyZW50Tm9kZV07XG4gICAgICAgIGlmICggY2xpY2tUYXJnZXQgPT09IGVsZW1lbnQgJiYgIWhhc0NsYXNzKG1vZGFsLHNob3dDbGFzcykgKSB7XG4gICAgICAgICAgbW9kYWxbbW9kYWxUcmlnZ2VyXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICAgICAgc2VsZi5zaG93KCk7XG4gICAgICAgICAgZVtwcmV2ZW50RGVmYXVsdF0oKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGtleUhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICggbW9kYWxbaXNBbmltYXRpbmddICkgcmV0dXJuO1xuICBcbiAgICAgICAgaWYgKHNlbGZba2V5Ym9hcmRdICYmIGUud2hpY2ggPT0gMjcgJiYgaGFzQ2xhc3MobW9kYWwsc2hvd0NsYXNzKSApIHtcbiAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc21pc3NIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIG1vZGFsW2lzQW5pbWF0aW5nXSApIHJldHVybjtcbiAgICAgICAgdmFyIGNsaWNrVGFyZ2V0ID0gZVt0YXJnZXRdO1xuICBcbiAgICAgICAgaWYgKCBoYXNDbGFzcyhtb2RhbCxzaG93Q2xhc3MpICYmICggY2xpY2tUYXJnZXRbcGFyZW50Tm9kZV1bZ2V0QXR0cmlidXRlXShkYXRhRGlzbWlzcykgPT09IGNvbXBvbmVudFxuICAgICAgICAgICAgfHwgY2xpY2tUYXJnZXRbZ2V0QXR0cmlidXRlXShkYXRhRGlzbWlzcykgPT09IGNvbXBvbmVudFxuICAgICAgICAgICAgfHwgY2xpY2tUYXJnZXQgPT09IG1vZGFsICYmIHNlbGZbYmFja2Ryb3BdICE9PSBzdGF0aWNTdHJpbmcgKSApIHtcbiAgICAgICAgICBzZWxmLmhpZGUoKTsgcmVsYXRlZFRhcmdldCA9IG51bGw7XG4gICAgICAgICAgZVtwcmV2ZW50RGVmYXVsdF0oKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICB0aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCBoYXNDbGFzcyhtb2RhbCxzaG93Q2xhc3MpICkge3RoaXMuaGlkZSgpO30gZWxzZSB7dGhpcy5zaG93KCk7fVxuICAgIH07XG4gICAgdGhpcy5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIGhhc0NsYXNzKG1vZGFsLHNob3dDbGFzcykgfHwgbW9kYWxbaXNBbmltYXRpbmddICkge3JldHVybn1cbiAgXG4gICAgICBjbGVhclRpbWVvdXQobW9kYWxUaW1lcik7XG4gICAgICBtb2RhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICBtb2RhbFtpc0FuaW1hdGluZ10gPSB0cnVlO1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKG1vZGFsLCBzaG93RXZlbnQsIGNvbXBvbmVudCwgcmVsYXRlZFRhcmdldCk7XG4gIFxuICAgICAgICAvLyB3ZSBlbGVnYW50bHkgaGlkZSBhbnkgb3BlbmVkIG1vZGFsXG4gICAgICAgIHZhciBjdXJyZW50T3BlbiA9IGdldEVsZW1lbnRzQnlDbGFzc05hbWUoRE9DLGNvbXBvbmVudCsnICcrc2hvd0NsYXNzKVswXTtcbiAgICAgICAgaWYgKGN1cnJlbnRPcGVuICYmIGN1cnJlbnRPcGVuICE9PSBtb2RhbCkge1xuICAgICAgICAgIG1vZGFsVHJpZ2dlciBpbiBjdXJyZW50T3BlbiAmJiBjdXJyZW50T3Blblttb2RhbFRyaWdnZXJdW3N0cmluZ01vZGFsXS5oaWRlKCk7XG4gICAgICAgICAgc3RyaW5nTW9kYWwgaW4gY3VycmVudE9wZW4gJiYgY3VycmVudE9wZW5bc3RyaW5nTW9kYWxdLmhpZGUoKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKCBzZWxmW2JhY2tkcm9wXSApIHtcbiAgICAgICAgICAhbW9kYWxPdmVybGF5ICYmICFvdmVybGF5ICYmIGNyZWF0ZU92ZXJsYXkoKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKCBvdmVybGF5ICYmICFoYXNDbGFzcyhvdmVybGF5LHNob3dDbGFzcykgKSB7XG4gICAgICAgICAgb3ZlcmxheVtvZmZzZXRXaWR0aF07IC8vIGZvcmNlIHJlZmxvdyB0byBlbmFibGUgdHJhc2l0aW9uXG4gICAgICAgICAgb3ZlcmxheURlbGF5ID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQob3ZlcmxheSk7XG4gICAgICAgICAgYWRkQ2xhc3Mob3ZlcmxheSwgc2hvd0NsYXNzKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbW9kYWxbc3R5bGVdLmRpc3BsYXkgPSAnYmxvY2snO1xuICBcbiAgICAgICAgICBjaGVja1Njcm9sbGJhcigpO1xuICAgICAgICAgIHNldFNjcm9sbGJhcigpO1xuICBcbiAgICAgICAgICBhZGRDbGFzcyhET0NbYm9keV0sY29tcG9uZW50Kyctb3BlbicpO1xuICAgICAgICAgIGFkZENsYXNzKG1vZGFsLHNob3dDbGFzcyk7XG4gICAgICAgICAgbW9kYWxbc2V0QXR0cmlidXRlXShhcmlhSGlkZGVuLCBmYWxzZSk7XG4gIFxuICAgICAgICAgIGhhc0NsYXNzKG1vZGFsLCdmYWRlJykgPyBlbXVsYXRlVHJhbnNpdGlvbkVuZChtb2RhbCwgdHJpZ2dlclNob3cpIDogdHJpZ2dlclNob3coKTtcbiAgICAgICAgfSwgc3VwcG9ydFRyYW5zaXRpb25zICYmIG92ZXJsYXkgJiYgb3ZlcmxheURlbGF5ID8gb3ZlcmxheURlbGF5IDogMSk7XG4gICAgICB9LDEpO1xuICAgIH07XG4gICAgdGhpcy5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIG1vZGFsW2lzQW5pbWF0aW5nXSB8fCAhaGFzQ2xhc3MobW9kYWwsc2hvd0NsYXNzKSApIHtyZXR1cm59XG4gIFxuICAgICAgY2xlYXJUaW1lb3V0KG1vZGFsVGltZXIpO1xuICAgICAgbW9kYWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgbW9kYWxbaXNBbmltYXRpbmddID0gdHJ1ZTsgICAgXG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIGhpZGVFdmVudCwgY29tcG9uZW50KTtcbiAgICAgICAgb3ZlcmxheSA9IHF1ZXJ5RWxlbWVudCgnLicrbW9kYWxCYWNrZHJvcFN0cmluZyk7XG4gICAgICAgIG92ZXJsYXlEZWxheSA9IG92ZXJsYXkgJiYgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQob3ZlcmxheSk7XG4gIFxuICAgICAgICByZW1vdmVDbGFzcyhtb2RhbCxzaG93Q2xhc3MpO1xuICAgICAgICBtb2RhbFtzZXRBdHRyaWJ1dGVdKGFyaWFIaWRkZW4sIHRydWUpO1xuICBcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIGhhc0NsYXNzKG1vZGFsLCdmYWRlJykgPyBlbXVsYXRlVHJhbnNpdGlvbkVuZChtb2RhbCwgdHJpZ2dlckhpZGUpIDogdHJpZ2dlckhpZGUoKTtcbiAgICAgICAgfSwgc3VwcG9ydFRyYW5zaXRpb25zICYmIG92ZXJsYXkgJiYgb3ZlcmxheURlbGF5ID8gb3ZlcmxheURlbGF5IDogMik7XG4gICAgICB9LDIpXG4gICAgfTtcbiAgICB0aGlzLnNldENvbnRlbnQgPSBmdW5jdGlvbiggY29udGVudCApIHtcbiAgICAgIHF1ZXJ5RWxlbWVudCgnLicrY29tcG9uZW50KyctY29udGVudCcsbW9kYWwpW2lubmVySFRNTF0gPSBjb250ZW50O1xuICAgIH07XG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChoYXNDbGFzcyhtb2RhbCxzaG93Q2xhc3MpKSB7XG4gICAgICAgIGNoZWNrU2Nyb2xsYmFyKCk7XG4gICAgICAgIHNldFNjcm9sbGJhcigpO1xuICAgICAgfVxuICAgIH07XG4gIFxuICAgIC8vIGluaXRcbiAgICAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyBvdmVyIGFuZCBvdmVyXG4gICAgLy8gbW9kYWwgaXMgaW5kZXBlbmRlbnQgb2YgYSB0cmlnZ2VyaW5nIGVsZW1lbnRcbiAgICBpZiAoICEhZWxlbWVudCAmJiAhKHN0cmluZ01vZGFsIGluIGVsZW1lbnQpICkge1xuICAgICAgb24oZWxlbWVudCwgY2xpY2tFdmVudCwgY2xpY2tIYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKCAhIXNlbGZbY29udGVudF0gKSB7IHNlbGYuc2V0Q29udGVudCggc2VsZltjb250ZW50XSApOyB9XG4gICAgaWYgKGVsZW1lbnQpIHsgZWxlbWVudFtzdHJpbmdNb2RhbF0gPSBzZWxmOyBtb2RhbFttb2RhbFRyaWdnZXJdID0gZWxlbWVudDsgfVxuICAgIGVsc2UgeyBtb2RhbFtzdHJpbmdNb2RhbF0gPSBzZWxmOyB9XG4gIH07XG4gIFxuICAvLyBEQVRBIEFQSVxuICBzdXBwb3J0c1twdXNoXSggWyBzdHJpbmdNb2RhbCwgTW9kYWwsICdbJytkYXRhVG9nZ2xlKyc9XCJtb2RhbFwiXScgXSApO1xuICBcbiAgLyogTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgUG9wb3ZlclxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgXG4gIC8vIFBPUE9WRVIgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT1cbiAgdmFyIFBvcG92ZXIgPSBmdW5jdGlvbiggZWxlbWVudCwgb3B0aW9ucyApIHtcbiAgXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIFxuICAgIC8vIHNldCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFxuICAgIC8vIERBVEEgQVBJXG4gICAgdmFyIHRyaWdnZXJEYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFUcmlnZ2VyKSwgLy8gY2xpY2sgLyBob3ZlciAvIGZvY3VzXG4gICAgICAgIGFuaW1hdGlvbkRhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YUFuaW1hdGlvbiksIC8vIHRydWUgLyBmYWxzZVxuICAgICAgICBwbGFjZW1lbnREYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFQbGFjZW1lbnQpLFxuICAgICAgICBkaXNtaXNzaWJsZURhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YURpc21pc3NpYmxlKSxcbiAgICAgICAgZGVsYXlEYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFEZWxheSksXG4gICAgICAgIGNvbnRhaW5lckRhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YUNvbnRhaW5lciksXG4gIFxuICAgICAgICAvLyBpbnRlcm5hbCBzdHJpbmdzXG4gICAgICAgIGNvbXBvbmVudCA9ICdwb3BvdmVyJyxcbiAgICAgICAgdGVtcGxhdGUgPSAndGVtcGxhdGUnLFxuICAgICAgICB0cmlnZ2VyID0gJ3RyaWdnZXInLFxuICAgICAgICBjbGFzc1N0cmluZyA9ICdjbGFzcycsXG4gICAgICAgIGRpdiA9ICdkaXYnLFxuICAgICAgICBmYWRlID0gJ2ZhZGUnLFxuICAgICAgICBkYXRhQ29udGVudCA9ICdkYXRhLWNvbnRlbnQnLFxuICAgICAgICBkaXNtaXNzaWJsZSA9ICdkaXNtaXNzaWJsZScsXG4gICAgICAgIGNsb3NlQnRuID0gJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIj7DlzwvYnV0dG9uPicsXG4gIFxuICAgICAgICAvLyBjaGVjayBjb250YWluZXJcbiAgICAgICAgY29udGFpbmVyRWxlbWVudCA9IHF1ZXJ5RWxlbWVudChvcHRpb25zW2NvbnRhaW5lcl0pLFxuICAgICAgICBjb250YWluZXJEYXRhRWxlbWVudCA9IHF1ZXJ5RWxlbWVudChjb250YWluZXJEYXRhKSwgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvLyBtYXliZSB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYSBtb2RhbFxuICAgICAgICBtb2RhbCA9IGdldENsb3Nlc3QoZWxlbWVudCwnLm1vZGFsJyksXG4gICAgICAgIFxuICAgICAgICAvLyBtYXliZSB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYSBmaXhlZCBuYXZiYXJcbiAgICAgICAgbmF2YmFyRml4ZWRUb3AgPSBnZXRDbG9zZXN0KGVsZW1lbnQsJy4nK2ZpeGVkVG9wKSxcbiAgICAgICAgbmF2YmFyRml4ZWRCb3R0b20gPSBnZXRDbG9zZXN0KGVsZW1lbnQsJy4nK2ZpeGVkQm90dG9tKTtcbiAgXG4gICAgLy8gc2V0IGluc3RhbmNlIG9wdGlvbnNcbiAgICB0aGlzW3RlbXBsYXRlXSA9IG9wdGlvbnNbdGVtcGxhdGVdID8gb3B0aW9uc1t0ZW1wbGF0ZV0gOiBudWxsOyAvLyBKYXZhU2NyaXB0IG9ubHlcbiAgICB0aGlzW3RyaWdnZXJdID0gb3B0aW9uc1t0cmlnZ2VyXSA/IG9wdGlvbnNbdHJpZ2dlcl0gOiB0cmlnZ2VyRGF0YSB8fCBob3ZlckV2ZW50O1xuICAgIHRoaXNbYW5pbWF0aW9uXSA9IG9wdGlvbnNbYW5pbWF0aW9uXSAmJiBvcHRpb25zW2FuaW1hdGlvbl0gIT09IGZhZGUgPyBvcHRpb25zW2FuaW1hdGlvbl0gOiBhbmltYXRpb25EYXRhIHx8IGZhZGU7XG4gICAgdGhpc1twbGFjZW1lbnRdID0gb3B0aW9uc1twbGFjZW1lbnRdID8gb3B0aW9uc1twbGFjZW1lbnRdIDogcGxhY2VtZW50RGF0YSB8fCB0b3A7XG4gICAgdGhpc1tkZWxheV0gPSBwYXJzZUludChvcHRpb25zW2RlbGF5XSB8fCBkZWxheURhdGEpIHx8IDIwMDtcbiAgICB0aGlzW2Rpc21pc3NpYmxlXSA9IG9wdGlvbnNbZGlzbWlzc2libGVdIHx8IGRpc21pc3NpYmxlRGF0YSA9PT0gJ3RydWUnID8gdHJ1ZSA6IGZhbHNlO1xuICAgIHRoaXNbY29udGFpbmVyXSA9IGNvbnRhaW5lckVsZW1lbnQgPyBjb250YWluZXJFbGVtZW50IFxuICAgICAgICAgICAgICAgICAgICA6IGNvbnRhaW5lckRhdGFFbGVtZW50ID8gY29udGFpbmVyRGF0YUVsZW1lbnQgXG4gICAgICAgICAgICAgICAgICAgIDogbmF2YmFyRml4ZWRUb3AgPyBuYXZiYXJGaXhlZFRvcFxuICAgICAgICAgICAgICAgICAgICA6IG5hdmJhckZpeGVkQm90dG9tID8gbmF2YmFyRml4ZWRCb3R0b21cbiAgICAgICAgICAgICAgICAgICAgOiBtb2RhbCA/IG1vZGFsIDogRE9DW2JvZHldO1xuICAgIFxuICAgIC8vIGJpbmQsIGNvbnRlbnRcbiAgICB2YXIgc2VsZiA9IHRoaXMsIFxuICAgICAgICB0aXRsZVN0cmluZyA9IG9wdGlvbnMudGl0bGUgfHwgZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFUaXRsZSkgfHwgbnVsbCxcbiAgICAgICAgY29udGVudFN0cmluZyA9IG9wdGlvbnMuY29udGVudCB8fCBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YUNvbnRlbnQpIHx8IG51bGw7XG4gIFxuICAgIGlmICggIWNvbnRlbnRTdHJpbmcgJiYgIXRoaXNbdGVtcGxhdGVdICkgcmV0dXJuOyAvLyBpbnZhbGlkYXRlXG4gIFxuICAgIC8vIGNvbnN0YW50cywgdmFyc1xuICAgIHZhciBwb3BvdmVyID0gbnVsbCwgdGltZXIgPSAwLCBwbGFjZW1lbnRTZXR0aW5nID0gdGhpc1twbGFjZW1lbnRdLFxuICAgICAgXG4gICAgICAvLyBoYW5kbGVyc1xuICAgICAgZGlzbWlzc2libGVIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAocG9wb3ZlciAhPT0gbnVsbCAmJiBlW3RhcmdldF0gPT09IHF1ZXJ5RWxlbWVudCgnLmNsb3NlJyxwb3BvdmVyKSkge1xuICAgICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICBcbiAgICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgICAgcmVtb3ZlUG9wb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmW2NvbnRhaW5lcl0ucmVtb3ZlQ2hpbGQocG9wb3Zlcik7XG4gICAgICAgIHRpbWVyID0gbnVsbDsgcG9wb3ZlciA9IG51bGw7IFxuICAgICAgfSxcbiAgICAgIGNyZWF0ZVBvcG92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGl0bGVTdHJpbmcgPSBvcHRpb25zLnRpdGxlIHx8IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhVGl0bGUpO1xuICAgICAgICBjb250ZW50U3RyaW5nID0gb3B0aW9ucy5jb250ZW50IHx8IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhQ29udGVudCk7XG4gICAgICAgIC8vIGZpeGluZyBodHRwczovL2dpdGh1Yi5jb20vdGhlZG5wL2Jvb3RzdHJhcC5uYXRpdmUvaXNzdWVzLzIzM1xuICAgICAgICBjb250ZW50U3RyaW5nID0gISFjb250ZW50U3RyaW5nID8gY29udGVudFN0cmluZy50cmltKCkgOiBudWxsO1xuICBcbiAgICAgICAgcG9wb3ZlciA9IERPQ1tjcmVhdGVFbGVtZW50XShkaXYpO1xuICBcbiAgICAgICAgLy8gcG9wb3ZlciBhcnJvd1xuICAgICAgICB2YXIgcG9wb3ZlckFycm93ID0gRE9DW2NyZWF0ZUVsZW1lbnRdKGRpdik7XG4gICAgICAgIHBvcG92ZXJBcnJvd1tzZXRBdHRyaWJ1dGVdKGNsYXNzU3RyaW5nLCdhcnJvdycpO1xuICAgICAgICBwb3BvdmVyW2FwcGVuZENoaWxkXShwb3BvdmVyQXJyb3cpO1xuICBcbiAgICAgICAgaWYgKCBjb250ZW50U3RyaW5nICE9PSBudWxsICYmIHNlbGZbdGVtcGxhdGVdID09PSBudWxsICkgeyAvL2NyZWF0ZSB0aGUgcG9wb3ZlciBmcm9tIGRhdGEgYXR0cmlidXRlc1xuICBcbiAgICAgICAgICBwb3BvdmVyW3NldEF0dHJpYnV0ZV0oJ3JvbGUnLCd0b29sdGlwJyk7ICAgICBcbiAgXG4gICAgICAgICAgaWYgKHRpdGxlU3RyaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcG9wb3ZlclRpdGxlID0gRE9DW2NyZWF0ZUVsZW1lbnRdKCdoMycpO1xuICAgICAgICAgICAgcG9wb3ZlclRpdGxlW3NldEF0dHJpYnV0ZV0oY2xhc3NTdHJpbmcsY29tcG9uZW50KyctaGVhZGVyJyk7XG4gIFxuICAgICAgICAgICAgcG9wb3ZlclRpdGxlW2lubmVySFRNTF0gPSBzZWxmW2Rpc21pc3NpYmxlXSA/IHRpdGxlU3RyaW5nICsgY2xvc2VCdG4gOiB0aXRsZVN0cmluZztcbiAgICAgICAgICAgIHBvcG92ZXJbYXBwZW5kQ2hpbGRdKHBvcG92ZXJUaXRsZSk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvL3NldCBwb3BvdmVyIGNvbnRlbnRcbiAgICAgICAgICB2YXIgcG9wb3ZlckNvbnRlbnQgPSBET0NbY3JlYXRlRWxlbWVudF0oZGl2KTtcbiAgICAgICAgICBwb3BvdmVyQ29udGVudFtzZXRBdHRyaWJ1dGVdKGNsYXNzU3RyaW5nLGNvbXBvbmVudCsnLWJvZHknKTtcbiAgICAgICAgICBwb3BvdmVyQ29udGVudFtpbm5lckhUTUxdID0gc2VsZltkaXNtaXNzaWJsZV0gJiYgdGl0bGVTdHJpbmcgPT09IG51bGwgPyBjb250ZW50U3RyaW5nICsgY2xvc2VCdG4gOiBjb250ZW50U3RyaW5nO1xuICAgICAgICAgIHBvcG92ZXJbYXBwZW5kQ2hpbGRdKHBvcG92ZXJDb250ZW50KTtcbiAgXG4gICAgICAgIH0gZWxzZSB7ICAvLyBvciBjcmVhdGUgdGhlIHBvcG92ZXIgZnJvbSB0ZW1wbGF0ZVxuICAgICAgICAgIHZhciBwb3BvdmVyVGVtcGxhdGUgPSBET0NbY3JlYXRlRWxlbWVudF0oZGl2KTtcbiAgICAgICAgICBzZWxmW3RlbXBsYXRlXSA9IHNlbGZbdGVtcGxhdGVdLnRyaW0oKTtcbiAgICAgICAgICBwb3BvdmVyVGVtcGxhdGVbaW5uZXJIVE1MXSA9IHNlbGZbdGVtcGxhdGVdO1xuICAgICAgICAgIHBvcG92ZXJbaW5uZXJIVE1MXSA9IHBvcG92ZXJUZW1wbGF0ZS5maXJzdENoaWxkW2lubmVySFRNTF07XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vYXBwZW5kIHRvIHRoZSBjb250YWluZXJcbiAgICAgICAgc2VsZltjb250YWluZXJdW2FwcGVuZENoaWxkXShwb3BvdmVyKTtcbiAgICAgICAgcG9wb3ZlcltzdHlsZV0uZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHBvcG92ZXJbc2V0QXR0cmlidXRlXShjbGFzc1N0cmluZywgY29tcG9uZW50KyAnIGJzLScgKyBjb21wb25lbnQrJy0nK3BsYWNlbWVudFNldHRpbmcgKyAnICcgKyBzZWxmW2FuaW1hdGlvbl0pO1xuICAgICAgfSxcbiAgICAgIHNob3dQb3BvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAhaGFzQ2xhc3MocG9wb3ZlcixzaG93Q2xhc3MpICYmICggYWRkQ2xhc3MocG9wb3ZlcixzaG93Q2xhc3MpICk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlUG9wb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHlsZVRpcChlbGVtZW50LCBwb3BvdmVyLCBwbGFjZW1lbnRTZXR0aW5nLCBzZWxmW2NvbnRhaW5lcl0pO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBldmVudCB0b2dnbGVcbiAgICAgIGRpc21pc3NIYW5kbGVyVG9nZ2xlID0gZnVuY3Rpb24odHlwZSl7XG4gICAgICAgIGlmIChjbGlja0V2ZW50ID09IHNlbGZbdHJpZ2dlcl0gfHwgJ2ZvY3VzJyA9PSBzZWxmW3RyaWdnZXJdKSB7XG4gICAgICAgICAgIXNlbGZbZGlzbWlzc2libGVdICYmIHR5cGUoIGVsZW1lbnQsICdibHVyJywgc2VsZi5oaWRlICk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZltkaXNtaXNzaWJsZV0gJiYgdHlwZSggRE9DLCBjbGlja0V2ZW50LCBkaXNtaXNzaWJsZUhhbmRsZXIgKTsgICAgIFxuICAgICAgICB0eXBlKCBnbG9iYWxPYmplY3QsIHJlc2l6ZUV2ZW50LCBzZWxmLmhpZGUsIHBhc3NpdmVIYW5kbGVyICk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIHRyaWdnZXJzXG4gICAgICBzaG93VHJpZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkaXNtaXNzSGFuZGxlclRvZ2dsZShvbik7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2hvd25FdmVudCwgY29tcG9uZW50KTtcbiAgICAgIH0sXG4gICAgICBoaWRlVHJpZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkaXNtaXNzSGFuZGxlclRvZ2dsZShvZmYpO1xuICAgICAgICByZW1vdmVQb3BvdmVyKCk7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgaGlkZGVuRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICB9O1xuICBcbiAgICAvLyBwdWJsaWMgbWV0aG9kcyAvIGhhbmRsZXJzXG4gICAgdGhpcy50b2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChwb3BvdmVyID09PSBudWxsKSB7IHNlbGYuc2hvdygpOyB9IFxuICAgICAgZWxzZSB7IHNlbGYuaGlkZSgpOyB9XG4gICAgfTtcbiAgICB0aGlzLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocG9wb3ZlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHBsYWNlbWVudFNldHRpbmcgPSBzZWxmW3BsYWNlbWVudF07IC8vIHdlIHJlc2V0IHBsYWNlbWVudCBpbiBhbGwgY2FzZXNcbiAgICAgICAgICBjcmVhdGVQb3BvdmVyKCk7XG4gICAgICAgICAgdXBkYXRlUG9wb3ZlcigpO1xuICAgICAgICAgIHNob3dQb3BvdmVyKCk7XG4gICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzaG93RXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgICAgISFzZWxmW2FuaW1hdGlvbl0gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZChwb3BvdmVyLCBzaG93VHJpZ2dlcikgOiBzaG93VHJpZ2dlcigpO1xuICAgICAgICB9XG4gICAgICB9LCAyMCApO1xuICAgIH07XG4gICAgdGhpcy5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHBvcG92ZXIgJiYgcG9wb3ZlciAhPT0gbnVsbCAmJiBoYXNDbGFzcyhwb3BvdmVyLHNob3dDbGFzcykpIHtcbiAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGhpZGVFdmVudCwgY29tcG9uZW50KTtcbiAgICAgICAgICByZW1vdmVDbGFzcyhwb3BvdmVyLHNob3dDbGFzcyk7XG4gICAgICAgICAgISFzZWxmW2FuaW1hdGlvbl0gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZChwb3BvdmVyLCBoaWRlVHJpZ2dlcikgOiBoaWRlVHJpZ2dlcigpO1xuICAgICAgICB9XG4gICAgICB9LCBzZWxmW2RlbGF5XSApO1xuICAgIH07XG4gIFxuICAgIC8vIGluaXRcbiAgICBpZiAoICEoc3RyaW5nUG9wb3ZlciBpbiBlbGVtZW50KSApIHsgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICAgIGlmIChzZWxmW3RyaWdnZXJdID09PSBob3ZlckV2ZW50KSB7XG4gICAgICAgIG9uKCBlbGVtZW50LCBtb3VzZUhvdmVyWzBdLCBzZWxmLnNob3cgKTtcbiAgICAgICAgaWYgKCFzZWxmW2Rpc21pc3NpYmxlXSkgeyBvbiggZWxlbWVudCwgbW91c2VIb3ZlclsxXSwgc2VsZi5oaWRlICk7IH1cbiAgICAgIH0gZWxzZSBpZiAoY2xpY2tFdmVudCA9PSBzZWxmW3RyaWdnZXJdIHx8ICdmb2N1cycgPT0gc2VsZlt0cmlnZ2VyXSkge1xuICAgICAgICBvbiggZWxlbWVudCwgc2VsZlt0cmlnZ2VyXSwgc2VsZi50b2dnbGUgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudFtzdHJpbmdQb3BvdmVyXSA9IHNlbGY7XG4gIH07XG4gIFxuICAvLyBQT1BPVkVSIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT1cbiAgc3VwcG9ydHNbcHVzaF0oIFsgc3RyaW5nUG9wb3ZlciwgUG9wb3ZlciwgJ1snK2RhdGFUb2dnbGUrJz1cInBvcG92ZXJcIl0nIF0gKTtcbiAgXG4gIFxuICAvKiBOYXRpdmUgSmF2YXNjcmlwdCBmb3IgQm9vdHN0cmFwIDQgfCBTY3JvbGxTcHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBcbiAgLy8gU0NST0xMU1BZIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cbiAgdmFyIFNjcm9sbFNweSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudCwgdGhlIGVsZW1lbnQgd2Ugc3B5IG9uXG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTsgXG4gIFxuICAgIC8vIERBVEEgQVBJXG4gICAgdmFyIHRhcmdldERhdGEgPSBxdWVyeUVsZW1lbnQoZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFUYXJnZXQpKSxcbiAgICAgICAgb2Zmc2V0RGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXSgnZGF0YS1vZmZzZXQnKTtcbiAgXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXG4gICAgLy8gaW52YWxpZGF0ZVxuICAgIGlmICggIW9wdGlvbnNbdGFyZ2V0XSAmJiAhdGFyZ2V0RGF0YSApIHsgcmV0dXJuOyB9IFxuICBcbiAgICAvLyBldmVudCB0YXJnZXRzLCBjb25zdGFudHNcbiAgICB2YXIgc2VsZiA9IHRoaXMsIHNweVRhcmdldCA9IG9wdGlvbnNbdGFyZ2V0XSAmJiBxdWVyeUVsZW1lbnQob3B0aW9uc1t0YXJnZXRdKSB8fCB0YXJnZXREYXRhLFxuICAgICAgICBsaW5rcyA9IHNweVRhcmdldCAmJiBzcHlUYXJnZXRbZ2V0RWxlbWVudHNCeVRhZ05hbWVdKCdBJyksXG4gICAgICAgIG9mZnNldCA9IHBhcnNlSW50KG9wdGlvbnNbJ29mZnNldCddIHx8IG9mZnNldERhdGEpIHx8IDEwLCAgICAgIFxuICAgICAgICBpdGVtcyA9IFtdLCB0YXJnZXRJdGVtcyA9IFtdLCBzY3JvbGxPZmZzZXQsXG4gICAgICAgIHNjcm9sbFRhcmdldCA9IGVsZW1lbnRbb2Zmc2V0SGVpZ2h0XSA8IGVsZW1lbnRbc2Nyb2xsSGVpZ2h0XSA/IGVsZW1lbnQgOiBnbG9iYWxPYmplY3QsIC8vIGRldGVybWluZSB3aGljaCBpcyB0aGUgcmVhbCBzY3JvbGxUYXJnZXRcbiAgICAgICAgaXNXaW5kb3cgPSBzY3JvbGxUYXJnZXQgPT09IGdsb2JhbE9iamVjdDsgIFxuICBcbiAgICAvLyBwb3B1bGF0ZSBpdGVtcyBhbmQgdGFyZ2V0c1xuICAgIGZvciAodmFyIGk9MCwgaWw9bGlua3NbbGVuZ3RoXTsgaTxpbDsgaSsrKSB7XG4gICAgICB2YXIgaHJlZiA9IGxpbmtzW2ldW2dldEF0dHJpYnV0ZV0oJ2hyZWYnKSwgXG4gICAgICAgICAgdGFyZ2V0SXRlbSA9IGhyZWYgJiYgaHJlZi5jaGFyQXQoMCkgPT09ICcjJyAmJiBocmVmLnNsaWNlKC0xKSAhPT0gJyMnICYmIHF1ZXJ5RWxlbWVudChocmVmKTtcbiAgICAgIGlmICggISF0YXJnZXRJdGVtICkge1xuICAgICAgICBpdGVtc1twdXNoXShsaW5rc1tpXSk7XG4gICAgICAgIHRhcmdldEl0ZW1zW3B1c2hdKHRhcmdldEl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgdmFyIHVwZGF0ZUl0ZW0gPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2luZGV4XSxcbiAgICAgICAgICB0YXJnZXRJdGVtID0gdGFyZ2V0SXRlbXNbaW5kZXhdLCAvLyB0aGUgbWVudSBpdGVtIHRhcmdldHMgdGhpcyBlbGVtZW50XG4gICAgICAgICAgZHJvcGRvd24gPSBpdGVtW3BhcmVudE5vZGVdW3BhcmVudE5vZGVdLFxuICAgICAgICAgIGRyb3Bkb3duTGluayA9IGhhc0NsYXNzKGRyb3Bkb3duLCdkcm9wZG93bicpICYmIGRyb3Bkb3duW2dldEVsZW1lbnRzQnlUYWdOYW1lXSgnQScpWzBdLFxuICAgICAgICAgIHRhcmdldFJlY3QgPSBpc1dpbmRvdyAmJiB0YXJnZXRJdGVtW2dldEJvdW5kaW5nQ2xpZW50UmVjdF0oKSxcbiAgXG4gICAgICAgICAgaXNBY3RpdmUgPSBoYXNDbGFzcyhpdGVtLGFjdGl2ZSkgfHwgZmFsc2UsXG4gIFxuICAgICAgICAgIHRvcEVkZ2UgPSAoaXNXaW5kb3cgPyB0YXJnZXRSZWN0W3RvcF0gKyBzY3JvbGxPZmZzZXQgOiB0YXJnZXRJdGVtW29mZnNldFRvcF0pIC0gb2Zmc2V0LFxuICAgICAgICAgIGJvdHRvbUVkZ2UgPSBpc1dpbmRvdyA/IHRhcmdldFJlY3RbYm90dG9tXSArIHNjcm9sbE9mZnNldCAtIG9mZnNldCA6IHRhcmdldEl0ZW1zW2luZGV4KzFdID8gdGFyZ2V0SXRlbXNbaW5kZXgrMV1bb2Zmc2V0VG9wXSAtIG9mZnNldCA6IGVsZW1lbnRbc2Nyb2xsSGVpZ2h0XSxcbiAgXG4gICAgICAgICAgaW5zaWRlID0gc2Nyb2xsT2Zmc2V0ID49IHRvcEVkZ2UgJiYgYm90dG9tRWRnZSA+IHNjcm9sbE9mZnNldDtcbiAgXG4gICAgICAgIGlmICggIWlzQWN0aXZlICYmIGluc2lkZSApIHtcbiAgICAgICAgICBpZiAoICFoYXNDbGFzcyhpdGVtLGFjdGl2ZSkgKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhpdGVtLGFjdGl2ZSk7XG4gICAgICAgICAgICBpZiAoZHJvcGRvd25MaW5rICYmICFoYXNDbGFzcyhkcm9wZG93bkxpbmssYWN0aXZlKSApIHtcbiAgICAgICAgICAgICAgYWRkQ2xhc3MoZHJvcGRvd25MaW5rLGFjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsICdhY3RpdmF0ZScsICdzY3JvbGxzcHknLCBpdGVtc1tpbmRleF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggIWluc2lkZSApIHtcbiAgICAgICAgICBpZiAoIGhhc0NsYXNzKGl0ZW0sYWN0aXZlKSApIHtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGl0ZW0sYWN0aXZlKTtcbiAgICAgICAgICAgIGlmIChkcm9wZG93bkxpbmsgJiYgaGFzQ2xhc3MoZHJvcGRvd25MaW5rLGFjdGl2ZSkgJiYgIWdldEVsZW1lbnRzQnlDbGFzc05hbWUoaXRlbVtwYXJlbnROb2RlXSxhY3RpdmUpLmxlbmd0aCAgKSB7XG4gICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGRyb3Bkb3duTGluayxhY3RpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggIWluc2lkZSAmJiAhaXNBY3RpdmUgfHwgaXNBY3RpdmUgJiYgaW5zaWRlICkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZUl0ZW1zID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2Nyb2xsT2Zmc2V0ID0gaXNXaW5kb3cgPyBnZXRTY3JvbGwoKS55IDogZWxlbWVudFtzY3JvbGxUb3BdO1xuICAgICAgICBmb3IgKHZhciBpbmRleD0wLCBpdGw9aXRlbXNbbGVuZ3RoXTsgaW5kZXg8aXRsOyBpbmRleCsrKSB7XG4gICAgICAgICAgdXBkYXRlSXRlbShpbmRleClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgXG4gICAgLy8gcHVibGljIG1ldGhvZFxuICAgIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZUl0ZW1zKCk7XG4gICAgfVxuICBcbiAgICAvLyBpbml0XG4gICAgaWYgKCAhKHN0cmluZ1Njcm9sbFNweSBpbiBlbGVtZW50KSApIHsgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICAgIG9uKCBzY3JvbGxUYXJnZXQsIHNjcm9sbEV2ZW50LCBzZWxmLnJlZnJlc2gsIHBhc3NpdmVIYW5kbGVyICk7XG4gICAgICBvbiggZ2xvYmFsT2JqZWN0LCByZXNpemVFdmVudCwgc2VsZi5yZWZyZXNoLCBwYXNzaXZlSGFuZGxlciApO1xuICAgIH1cbiAgICBzZWxmLnJlZnJlc2goKTtcbiAgICBlbGVtZW50W3N0cmluZ1Njcm9sbFNweV0gPSBzZWxmO1xuICB9O1xuICBcbiAgLy8gU0NST0xMU1BZIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09PVxuICBzdXBwb3J0c1twdXNoXSggWyBzdHJpbmdTY3JvbGxTcHksIFNjcm9sbFNweSwgJ1snK2RhdGFTcHkrJz1cInNjcm9sbFwiXScgXSApO1xuICBcbiAgXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IFRhYlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIFxuICAvLyBUQUIgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PVxuICB2YXIgVGFiID0gZnVuY3Rpb24oIGVsZW1lbnQsIG9wdGlvbnMgKSB7XG4gIFxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBcbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciBoZWlnaHREYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFIZWlnaHQpLFxuICAgICAgXG4gICAgICAgIC8vIHN0cmluZ3NcbiAgICAgICAgY29tcG9uZW50ID0gJ3RhYicsIGhlaWdodCA9ICdoZWlnaHQnLCBmbG9hdCA9ICdmbG9hdCcsIGlzQW5pbWF0aW5nID0gJ2lzQW5pbWF0aW5nJztcbiAgICAgICAgXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzW2hlaWdodF0gPSBzdXBwb3J0VHJhbnNpdGlvbnMgPyAob3B0aW9uc1toZWlnaHRdIHx8IGhlaWdodERhdGEgPT09ICd0cnVlJykgOiBmYWxzZTtcbiAgXG4gICAgLy8gYmluZCwgZXZlbnQgdGFyZ2V0c1xuICAgIHZhciBzZWxmID0gdGhpcywgbmV4dCxcbiAgICAgIHRhYnMgPSBnZXRDbG9zZXN0KGVsZW1lbnQsJy5uYXYnKSxcbiAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyID0gZmFsc2UsXG4gICAgICBkcm9wZG93biA9IHRhYnMgJiYgcXVlcnlFbGVtZW50KCcuZHJvcGRvd24tdG9nZ2xlJyx0YWJzKSxcbiAgICAgIGFjdGl2ZVRhYiwgYWN0aXZlQ29udGVudCwgbmV4dENvbnRlbnQsIGNvbnRhaW5lckhlaWdodCwgZXF1YWxDb250ZW50cywgbmV4dEhlaWdodCxcbiAgICAgIFxuICAgICAgLy8gdHJpZ2dlclxuICAgICAgdHJpZ2dlckVuZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyW3N0eWxlXVtoZWlnaHRdID0gJyc7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRhYnNDb250ZW50Q29udGFpbmVyLGNvbGxhcHNpbmcpO1xuICAgICAgICB0YWJzW2lzQW5pbWF0aW5nXSA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJTaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0YWJzQ29udGVudENvbnRhaW5lcikgeyAvLyBoZWlnaHQgYW5pbWF0aW9uXG4gICAgICAgICAgaWYgKCBlcXVhbENvbnRlbnRzICkge1xuICAgICAgICAgICAgdHJpZ2dlckVuZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IC8vIGVuYWJsZXMgaGVpZ2h0IGFuaW1hdGlvblxuICAgICAgICAgICAgICB0YWJzQ29udGVudENvbnRhaW5lcltzdHlsZV1baGVpZ2h0XSA9IG5leHRIZWlnaHQgKyAncHgnOyAvLyBoZWlnaHQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyW29mZnNldFdpZHRoXTtcbiAgICAgICAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQodGFic0NvbnRlbnRDb250YWluZXIsIHRyaWdnZXJFbmQpO1xuICAgICAgICAgICAgfSw1MCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhYnNbaXNBbmltYXRpbmddID0gZmFsc2U7IFxuICAgICAgICB9XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwobmV4dCwgc2hvd25FdmVudCwgY29tcG9uZW50LCBhY3RpdmVUYWIpO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJIaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0YWJzQ29udGVudENvbnRhaW5lcikge1xuICAgICAgICAgIGFjdGl2ZUNvbnRlbnRbc3R5bGVdW2Zsb2F0XSA9IGxlZnQ7XG4gICAgICAgICAgbmV4dENvbnRlbnRbc3R5bGVdW2Zsb2F0XSA9IGxlZnQ7ICAgICAgICBcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQgPSBhY3RpdmVDb250ZW50W3Njcm9sbEhlaWdodF07XG4gICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgYWRkQ2xhc3MobmV4dENvbnRlbnQsYWN0aXZlKTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChuZXh0LCBzaG93RXZlbnQsIGNvbXBvbmVudCwgYWN0aXZlVGFiKTtcbiAgXG4gICAgICAgIHJlbW92ZUNsYXNzKGFjdGl2ZUNvbnRlbnQsYWN0aXZlKTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChhY3RpdmVUYWIsIGhpZGRlbkV2ZW50LCBjb21wb25lbnQsIG5leHQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRhYnNDb250ZW50Q29udGFpbmVyKSB7XG4gICAgICAgICAgbmV4dEhlaWdodCA9IG5leHRDb250ZW50W3Njcm9sbEhlaWdodF07XG4gICAgICAgICAgZXF1YWxDb250ZW50cyA9IG5leHRIZWlnaHQgPT09IGNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgICBhZGRDbGFzcyh0YWJzQ29udGVudENvbnRhaW5lcixjb2xsYXBzaW5nKTtcbiAgICAgICAgICB0YWJzQ29udGVudENvbnRhaW5lcltzdHlsZV1baGVpZ2h0XSA9IGNvbnRhaW5lckhlaWdodCArICdweCc7IC8vIGhlaWdodCBhbmltYXRpb25cbiAgICAgICAgICB0YWJzQ29udGVudENvbnRhaW5lcltvZmZzZXRIZWlnaHRdO1xuICAgICAgICAgIGFjdGl2ZUNvbnRlbnRbc3R5bGVdW2Zsb2F0XSA9ICcnO1xuICAgICAgICAgIG5leHRDb250ZW50W3N0eWxlXVtmbG9hdF0gPSAnJztcbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKCBoYXNDbGFzcyhuZXh0Q29udGVudCwgJ2ZhZGUnKSApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBhZGRDbGFzcyhuZXh0Q29udGVudCxzaG93Q2xhc3MpO1xuICAgICAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQobmV4dENvbnRlbnQsdHJpZ2dlclNob3cpO1xuICAgICAgICAgIH0sMjApO1xuICAgICAgICB9IGVsc2UgeyB0cmlnZ2VyU2hvdygpOyB9ICAgICAgICBcbiAgICAgIH07XG4gIFxuICAgIGlmICghdGFicykgcmV0dXJuOyAvLyBpbnZhbGlkYXRlXG4gIFxuICAgIC8vIHNldCBkZWZhdWx0IGFuaW1hdGlvbiBzdGF0ZVxuICAgIHRhYnNbaXNBbmltYXRpbmddID0gZmFsc2U7ICAgIFxuICAgICAgICAgIFxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIHZhciBnZXRBY3RpdmVUYWIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFjdGl2ZVRhYnMgPSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHRhYnMsYWN0aXZlKSwgYWN0aXZlVGFiO1xuICAgICAgICBpZiAoIGFjdGl2ZVRhYnNbbGVuZ3RoXSA9PT0gMSAmJiAhaGFzQ2xhc3MoYWN0aXZlVGFic1swXVtwYXJlbnROb2RlXSwnZHJvcGRvd24nKSApIHtcbiAgICAgICAgICBhY3RpdmVUYWIgPSBhY3RpdmVUYWJzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKCBhY3RpdmVUYWJzW2xlbmd0aF0gPiAxICkge1xuICAgICAgICAgIGFjdGl2ZVRhYiA9IGFjdGl2ZVRhYnNbYWN0aXZlVGFic1tsZW5ndGhdLTFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmVUYWI7XG4gICAgICB9LFxuICAgICAgZ2V0QWN0aXZlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcXVlcnlFbGVtZW50KGdldEFjdGl2ZVRhYigpW2dldEF0dHJpYnV0ZV0oJ2hyZWYnKSk7XG4gICAgICB9LFxuICAgICAgLy8gaGFuZGxlciBcbiAgICAgIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZVtwcmV2ZW50RGVmYXVsdF0oKTtcbiAgICAgICAgbmV4dCA9IGVbY3VycmVudFRhcmdldF07XG4gICAgICAgICF0YWJzW2lzQW5pbWF0aW5nXSAmJiAhaGFzQ2xhc3MobmV4dCxhY3RpdmUpICYmIHNlbGYuc2hvdygpO1xuICAgICAgfTtcbiAgXG4gICAgLy8gcHVibGljIG1ldGhvZFxuICAgIHRoaXMuc2hvdyA9IGZ1bmN0aW9uKCkgeyAvLyB0aGUgdGFiIHdlIGNsaWNrZWQgaXMgbm93IHRoZSBuZXh0IHRhYlxuICAgICAgbmV4dCA9IG5leHQgfHwgZWxlbWVudDtcbiAgICAgIG5leHRDb250ZW50ID0gcXVlcnlFbGVtZW50KG5leHRbZ2V0QXR0cmlidXRlXSgnaHJlZicpKTsgLy90aGlzIGlzIHRoZSBhY3R1YWwgb2JqZWN0LCB0aGUgbmV4dCB0YWIgY29udGVudCB0byBhY3RpdmF0ZVxuICAgICAgYWN0aXZlVGFiID0gZ2V0QWN0aXZlVGFiKCk7IFxuICAgICAgYWN0aXZlQ29udGVudCA9IGdldEFjdGl2ZUNvbnRlbnQoKTtcbiAgICAgIFxuICAgICAgdGFic1tpc0FuaW1hdGluZ10gPSB0cnVlO1xuICAgICAgcmVtb3ZlQ2xhc3MoYWN0aXZlVGFiLGFjdGl2ZSk7XG4gICAgICBhY3RpdmVUYWJbc2V0QXR0cmlidXRlXShhcmlhU2VsZWN0ZWQsJ2ZhbHNlJyk7XG4gICAgICBhZGRDbGFzcyhuZXh0LGFjdGl2ZSk7XG4gICAgICBuZXh0W3NldEF0dHJpYnV0ZV0oYXJpYVNlbGVjdGVkLCd0cnVlJyk7ICAgIFxuICBcbiAgICAgIGlmICggZHJvcGRvd24gKSB7XG4gICAgICAgIGlmICggIWhhc0NsYXNzKGVsZW1lbnRbcGFyZW50Tm9kZV0sJ2Ryb3Bkb3duLW1lbnUnKSApIHtcbiAgICAgICAgICBpZiAoaGFzQ2xhc3MoZHJvcGRvd24sYWN0aXZlKSkgcmVtb3ZlQ2xhc3MoZHJvcGRvd24sYWN0aXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWhhc0NsYXNzKGRyb3Bkb3duLGFjdGl2ZSkpIGFkZENsYXNzKGRyb3Bkb3duLGFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChhY3RpdmVUYWIsIGhpZGVFdmVudCwgY29tcG9uZW50LCBuZXh0KTtcbiAgXG4gICAgICBpZiAoaGFzQ2xhc3MoYWN0aXZlQ29udGVudCwgJ2ZhZGUnKSkge1xuICAgICAgICByZW1vdmVDbGFzcyhhY3RpdmVDb250ZW50LHNob3dDbGFzcyk7XG4gICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGFjdGl2ZUNvbnRlbnQsIHRyaWdnZXJIaWRlKTtcbiAgICAgIH0gZWxzZSB7IHRyaWdnZXJIaWRlKCk7IH1cbiAgICB9O1xuICBcbiAgICAvLyBpbml0XG4gICAgaWYgKCAhKHN0cmluZ1RhYiBpbiBlbGVtZW50KSApIHsgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICAgIG9uKGVsZW1lbnQsIGNsaWNrRXZlbnQsIGNsaWNrSGFuZGxlcik7XG4gICAgfVxuICAgIGlmIChzZWxmW2hlaWdodF0pIHsgdGFic0NvbnRlbnRDb250YWluZXIgPSBnZXRBY3RpdmVDb250ZW50KClbcGFyZW50Tm9kZV07IH1cbiAgICBlbGVtZW50W3N0cmluZ1RhYl0gPSBzZWxmO1xuICB9O1xuICBcbiAgLy8gVEFCIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PVxuICBzdXBwb3J0c1twdXNoXSggWyBzdHJpbmdUYWIsIFRhYiwgJ1snK2RhdGFUb2dnbGUrJz1cInRhYlwiXScgXSApO1xuICBcbiAgXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IFRvYXN0XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIFxuICAvLyBUT0FTVCBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PVxuICB2YXIgVG9hc3QgPSBmdW5jdGlvbiggZWxlbWVudCxvcHRpb25zICkge1xuICBcbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXG4gICAgLy8gREFUQSBBUElcbiAgICB2YXIgYW5pbWF0aW9uRGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhQW5pbWF0aW9uKSxcbiAgICAgICAgYXV0b2hpZGVEYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFBdXRvaGlkZSksXG4gICAgICAgIGRlbGF5RGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhRGVsYXkpLFxuICAgICAgICBcbiAgICAgICAgLy8gc3RyaW5nc1xuICAgICAgICBjb21wb25lbnQgPSAndG9hc3QnLFxuICAgICAgICBhdXRvaGlkZSA9ICdhdXRvaGlkZScsXG4gICAgICAgIGFuaW1hdGlvbiA9ICdhbmltYXRpb24nLFxuICAgICAgICBzaG93aW5nID0gJ3Nob3dpbmcnLFxuICAgICAgICBoaWRlID0gJ2hpZGUnLFxuICAgICAgICBmYWRlID0gJ2ZhZGUnO1xuICBcbiAgICAvLyBzZXQgaW5zdGFuY2Ugb3B0aW9uc1xuICAgIHRoaXNbYW5pbWF0aW9uXSA9IG9wdGlvbnNbYW5pbWF0aW9uXSA9PT0gZmFsc2UgfHwgYW5pbWF0aW9uRGF0YSA9PT0gJ2ZhbHNlJyA/IDAgOiAxOyAvLyB0cnVlIGJ5IGRlZmF1bHRcbiAgICB0aGlzW2F1dG9oaWRlXSA9IG9wdGlvbnNbYXV0b2hpZGVdID09PSBmYWxzZSB8fCBhdXRvaGlkZURhdGEgPT09ICdmYWxzZScgPyAwIDogMTsgLy8gdHJ1ZSBieSBkZWZhdWx0XG4gICAgdGhpc1tkZWxheV0gPSBwYXJzZUludChvcHRpb25zW2RlbGF5XSB8fCBkZWxheURhdGEpIHx8IDUwMDsgLy8gNTAwbXMgZGVmYXVsdFxuICBcbiAgICAvLyBiaW5kLHRvYXN0IGFuZCB0aW1lclxuICAgIHZhciBzZWxmID0gdGhpcywgdGltZXIgPSAwLFxuICAgICAgICAvLyBnZXQgdGhlIHRvYXN0IGVsZW1lbnRcbiAgICAgICAgdG9hc3QgPSBnZXRDbG9zZXN0KGVsZW1lbnQsJy50b2FzdCcpO1xuICBcbiAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICAvLyBhbmltYXRpb24gY29tcGxldGVcbiAgICB2YXIgc2hvd0NvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKCB0b2FzdCwgc2hvd2luZyApO1xuICAgICAgICBhZGRDbGFzcyggdG9hc3QsIHNob3dDbGFzcyApO1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKHRvYXN0LCBzaG93bkV2ZW50LCBjb21wb25lbnQpO1xuICAgICAgICBpZiAoc2VsZlthdXRvaGlkZV0pIHsgc2VsZi5oaWRlKCk7IH1cbiAgICAgIH0sXG4gICAgICBoaWRlQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgYWRkQ2xhc3MoIHRvYXN0LCBoaWRlICk7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwodG9hc3QsIGhpZGRlbkV2ZW50LCBjb21wb25lbnQpO1xuICAgICAgfSxcbiAgICAgIGNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKCB0b2FzdCxzaG93Q2xhc3MgKTtcbiAgICAgICAgc2VsZlthbmltYXRpb25dID8gZW11bGF0ZVRyYW5zaXRpb25FbmQodG9hc3QsIGhpZGVDb21wbGV0ZSkgOiBoaWRlQ29tcGxldGUoKTtcbiAgICAgIH0sXG4gICAgICBkaXNwb3NlQ29tcGxldGUgPSBmdW5jdGlvbigpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpOyB0aW1lciA9IG51bGw7XG4gICAgICAgIGFkZENsYXNzKCB0b2FzdCwgaGlkZSApO1xuICAgICAgICBvZmYoZWxlbWVudCwgY2xpY2tFdmVudCwgc2VsZi5oaWRlKTtcbiAgICAgICAgZWxlbWVudFtzdHJpbmdUb2FzdF0gPSBudWxsO1xuICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdG9hc3QgPSBudWxsO1xuICAgICAgfTtcbiAgXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICB0aGlzLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0b2FzdCkge1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKHRvYXN0LCBzaG93RXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIHNlbGZbYW5pbWF0aW9uXSAmJiBhZGRDbGFzcyggdG9hc3QsZmFkZSApO1xuICAgICAgICByZW1vdmVDbGFzcyggdG9hc3QsaGlkZSApO1xuICAgICAgICBhZGRDbGFzcyggdG9hc3Qsc2hvd2luZyApO1xuICBcbiAgICAgICAgc2VsZlthbmltYXRpb25dID8gZW11bGF0ZVRyYW5zaXRpb25FbmQodG9hc3QsIHNob3dDb21wbGV0ZSkgOiBzaG93Q29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGlkZSA9IGZ1bmN0aW9uKG5vVGltZXIpIHtcbiAgICAgIGlmICh0b2FzdCAmJiBoYXNDbGFzcyh0b2FzdCxzaG93Q2xhc3MpKSB7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwodG9hc3QsIGhpZGVFdmVudCwgY29tcG9uZW50KTtcbiAgXG4gICAgICAgIGlmIChub1RpbWVyKSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoIGNsb3NlLCBzZWxmW2RlbGF5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCB0b2FzdCAmJiBoYXNDbGFzcyh0b2FzdCxzaG93Q2xhc3MpICkge1xuICAgICAgICByZW1vdmVDbGFzcyggdG9hc3Qsc2hvd0NsYXNzICk7XG4gICAgICAgIHNlbGZbYW5pbWF0aW9uXSA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRvYXN0LCBkaXNwb3NlQ29tcGxldGUpIDogZGlzcG9zZUNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgXG4gICAgLy8gaW5pdFxuICAgIGlmICggIShzdHJpbmdUb2FzdCBpbiBlbGVtZW50KSApIHsgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICAgIG9uKGVsZW1lbnQsIGNsaWNrRXZlbnQsIHNlbGYuaGlkZSk7XG4gICAgfVxuICAgIGVsZW1lbnRbc3RyaW5nVG9hc3RdID0gc2VsZjtcbiAgfTtcbiAgXG4gIC8vIFRPQVNUIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKCBbIHN0cmluZ1RvYXN0LCBUb2FzdCwgJ1snK2RhdGFEaXNtaXNzKyc9XCJ0b2FzdFwiXScgXSApO1xuICBcbiAgXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IFRvb2x0aXBcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgXG4gIC8vIFRPT0xUSVAgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT1cbiAgdmFyIFRvb2x0aXAgPSBmdW5jdGlvbiggZWxlbWVudCxvcHRpb25zICkge1xuICBcbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXG4gICAgLy8gREFUQSBBUElcbiAgICB2YXIgYW5pbWF0aW9uRGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhQW5pbWF0aW9uKSxcbiAgICAgICAgcGxhY2VtZW50RGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhUGxhY2VtZW50KSxcbiAgICAgICAgZGVsYXlEYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFEZWxheSksXG4gICAgICAgIGNvbnRhaW5lckRhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YUNvbnRhaW5lciksXG4gICAgICAgIFxuICAgICAgICAvLyBzdHJpbmdzXG4gICAgICAgIGNvbXBvbmVudCA9ICd0b29sdGlwJyxcbiAgICAgICAgY2xhc3NTdHJpbmcgPSAnY2xhc3MnLFxuICAgICAgICB0aXRsZSA9ICd0aXRsZScsXG4gICAgICAgIGZhZGUgPSAnZmFkZScsXG4gICAgICAgIGRpdiA9ICdkaXYnLFxuICBcbiAgICAgICAgLy8gY2hlY2sgY29udGFpbmVyXG4gICAgICAgIGNvbnRhaW5lckVsZW1lbnQgPSBxdWVyeUVsZW1lbnQob3B0aW9uc1tjb250YWluZXJdKSxcbiAgICAgICAgY29udGFpbmVyRGF0YUVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoY29udGFpbmVyRGF0YSksICAgICAgXG4gIFxuICAgICAgICAvLyBtYXliZSB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYSBtb2RhbFxuICAgICAgICBtb2RhbCA9IGdldENsb3Nlc3QoZWxlbWVudCwnLm1vZGFsJyksXG4gICAgICAgIFxuICAgICAgICAvLyBtYXliZSB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYSBmaXhlZCBuYXZiYXJcbiAgICAgICAgbmF2YmFyRml4ZWRUb3AgPSBnZXRDbG9zZXN0KGVsZW1lbnQsJy4nK2ZpeGVkVG9wKSxcbiAgICAgICAgbmF2YmFyRml4ZWRCb3R0b20gPSBnZXRDbG9zZXN0KGVsZW1lbnQsJy4nK2ZpeGVkQm90dG9tKTtcbiAgXG4gICAgLy8gc2V0IGluc3RhbmNlIG9wdGlvbnNcbiAgICB0aGlzW2FuaW1hdGlvbl0gPSBvcHRpb25zW2FuaW1hdGlvbl0gJiYgb3B0aW9uc1thbmltYXRpb25dICE9PSBmYWRlID8gb3B0aW9uc1thbmltYXRpb25dIDogYW5pbWF0aW9uRGF0YSB8fCBmYWRlO1xuICAgIHRoaXNbcGxhY2VtZW50XSA9IG9wdGlvbnNbcGxhY2VtZW50XSA/IG9wdGlvbnNbcGxhY2VtZW50XSA6IHBsYWNlbWVudERhdGEgfHwgdG9wO1xuICAgIHRoaXNbZGVsYXldID0gcGFyc2VJbnQob3B0aW9uc1tkZWxheV0gfHwgZGVsYXlEYXRhKSB8fCAyMDA7XG4gICAgdGhpc1tjb250YWluZXJdID0gY29udGFpbmVyRWxlbWVudCA/IGNvbnRhaW5lckVsZW1lbnQgXG4gICAgICAgICAgICAgICAgICAgIDogY29udGFpbmVyRGF0YUVsZW1lbnQgPyBjb250YWluZXJEYXRhRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICA6IG5hdmJhckZpeGVkVG9wID8gbmF2YmFyRml4ZWRUb3BcbiAgICAgICAgICAgICAgICAgICAgOiBuYXZiYXJGaXhlZEJvdHRvbSA/IG5hdmJhckZpeGVkQm90dG9tXG4gICAgICAgICAgICAgICAgICAgIDogbW9kYWwgPyBtb2RhbCA6IERPQ1tib2R5XTtcbiAgXG4gICAgLy8gYmluZCwgZXZlbnQgdGFyZ2V0cywgdGl0bGUgYW5kIGNvbnN0YW50c1xuICAgIHZhciBzZWxmID0gdGhpcywgdGltZXIgPSAwLCBwbGFjZW1lbnRTZXR0aW5nID0gdGhpc1twbGFjZW1lbnRdLCB0b29sdGlwID0gbnVsbCxcbiAgICAgICAgdGl0bGVTdHJpbmcgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0odGl0bGUpIHx8IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhVGl0bGUpIHx8IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhT3JpZ2luYWxUaXRsZSk7XG4gIFxuICAgIGlmICggIXRpdGxlU3RyaW5nIHx8IHRpdGxlU3RyaW5nID09IFwiXCIgKSByZXR1cm47IC8vIGludmFsaWRhdGVcbiAgXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgdmFyIHJlbW92ZVRvb2xUaXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZltjb250YWluZXJdLnJlbW92ZUNoaWxkKHRvb2x0aXApO1xuICAgICAgICB0b29sdGlwID0gbnVsbDsgdGltZXIgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVRvb2xUaXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGl0bGVTdHJpbmcgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0odGl0bGUpIHx8IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhVGl0bGUpIHx8IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhT3JpZ2luYWxUaXRsZSk7IC8vIHJlYWQgdGhlIHRpdGxlIGFnYWluXG4gIFxuICAgICAgICBpZiAoIHRpdGxlU3RyaW5nICYmIHRpdGxlU3RyaW5nICE9PSBcIlwiICkgeyAvLyBpbnZhbGlkYXRlLCBtYXliZSBtYXJrdXAgY2hhbmdlZFxuICAgICAgICAgIHRvb2x0aXAgPSBET0NbY3JlYXRlRWxlbWVudF0oZGl2KTtcbiAgICAgICAgICB0b29sdGlwW3NldEF0dHJpYnV0ZV0oJ3JvbGUnLGNvbXBvbmVudCk7XG4gICAgICAgICAgdG9vbHRpcFtzdHlsZV1bbGVmdF0gPSAnMCc7XG4gICAgICAgICAgdG9vbHRpcFtzdHlsZV1bdG9wXSA9ICcwJzsgICAgICAgIFxuICBcbiAgICAgICAgICAvLyB0b29sdGlwIGFycm93XG4gICAgICAgICAgdmFyIHRvb2x0aXBBcnJvdyA9IERPQ1tjcmVhdGVFbGVtZW50XShkaXYpO1xuICAgICAgICAgIHRvb2x0aXBBcnJvd1tzZXRBdHRyaWJ1dGVdKGNsYXNzU3RyaW5nLCdhcnJvdycpO1xuICAgICAgICAgIHRvb2x0aXBbYXBwZW5kQ2hpbGRdKHRvb2x0aXBBcnJvdyk7XG4gICAgICBcbiAgICAgICAgICB2YXIgdG9vbHRpcElubmVyID0gRE9DW2NyZWF0ZUVsZW1lbnRdKGRpdik7XG4gICAgICAgICAgdG9vbHRpcElubmVyW3NldEF0dHJpYnV0ZV0oY2xhc3NTdHJpbmcsY29tcG9uZW50KyctaW5uZXInKTtcbiAgICAgICAgICB0b29sdGlwW2FwcGVuZENoaWxkXSh0b29sdGlwSW5uZXIpO1xuICAgICAgICAgIHRvb2x0aXBJbm5lcltpbm5lckhUTUxdID0gdGl0bGVTdHJpbmc7XG4gIFxuICAgICAgICAgIHNlbGZbY29udGFpbmVyXVthcHBlbmRDaGlsZF0odG9vbHRpcCk7XG4gICAgICAgICAgdG9vbHRpcFtzZXRBdHRyaWJ1dGVdKGNsYXNzU3RyaW5nLCBjb21wb25lbnQgKyAnIGJzLScgKyBjb21wb25lbnQrJy0nK3BsYWNlbWVudFNldHRpbmcgKyAnICcgKyBzZWxmW2FuaW1hdGlvbl0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXBkYXRlVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3R5bGVUaXAoZWxlbWVudCwgdG9vbHRpcCwgcGxhY2VtZW50U2V0dGluZywgc2VsZltjb250YWluZXJdKTtcbiAgICAgIH0sXG4gICAgICBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIWhhc0NsYXNzKHRvb2x0aXAsc2hvd0NsYXNzKSAmJiAoIGFkZENsYXNzKHRvb2x0aXAsc2hvd0NsYXNzKSApO1xuICAgICAgfSxcbiAgICAgIC8vIHRyaWdnZXJzXG4gICAgICBzaG93VHJpZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBvbiggZ2xvYmFsT2JqZWN0LCByZXNpemVFdmVudCwgc2VsZi5oaWRlLCBwYXNzaXZlSGFuZGxlciApO1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNob3duRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICB9LFxuICAgICAgaGlkZVRyaWdnZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgb2ZmKCBnbG9iYWxPYmplY3QsIHJlc2l6ZUV2ZW50LCBzZWxmLmhpZGUsIHBhc3NpdmVIYW5kbGVyICk7XG4gICAgICAgIHJlbW92ZVRvb2xUaXAoKTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBoaWRkZW5FdmVudCwgY29tcG9uZW50KTtcbiAgICAgIH07XG4gIFxuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgdGhpcy5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRvb2x0aXAgPT09IG51bGwpIHtcbiAgICAgICAgICBwbGFjZW1lbnRTZXR0aW5nID0gc2VsZltwbGFjZW1lbnRdOyAvLyB3ZSByZXNldCBwbGFjZW1lbnQgaW4gYWxsIGNhc2VzXG4gICAgICAgICAgLy8gaWYoY3JlYXRlVG9vbFRpcCgpID09IGZhbHNlKSByZXR1cm47XG4gICAgICAgICAgaWYoY3JlYXRlVG9vbFRpcCgpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2hvd0V2ZW50LCBjb21wb25lbnQpO1xuICAgICAgICAgICAgISFzZWxmW2FuaW1hdGlvbl0gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b29sdGlwLCBzaG93VHJpZ2dlcikgOiBzaG93VHJpZ2dlcigpOyAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDIwICk7XG4gICAgfTtcbiAgICB0aGlzLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodG9vbHRpcCAmJiBoYXNDbGFzcyh0b29sdGlwLHNob3dDbGFzcykpIHtcbiAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGhpZGVFdmVudCwgY29tcG9uZW50KTtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0b29sdGlwLHNob3dDbGFzcyk7XG4gICAgICAgICAgISFzZWxmW2FuaW1hdGlvbl0gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b29sdGlwLCBoaWRlVHJpZ2dlcikgOiBoaWRlVHJpZ2dlcigpO1xuICAgICAgICB9XG4gICAgICB9LCBzZWxmW2RlbGF5XSk7XG4gICAgfTtcbiAgICB0aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0b29sdGlwKSB7IHNlbGYuc2hvdygpOyB9IFxuICAgICAgZWxzZSB7IHNlbGYuaGlkZSgpOyB9XG4gICAgfTtcbiAgXG4gICAgLy8gaW5pdFxuICAgIGlmICggIShzdHJpbmdUb29sdGlwIGluIGVsZW1lbnQpICkgeyAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgICAgZWxlbWVudFtzZXRBdHRyaWJ1dGVdKGRhdGFPcmlnaW5hbFRpdGxlLHRpdGxlU3RyaW5nKTtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHRpdGxlKTtcbiAgICAgIG9uKGVsZW1lbnQsIG1vdXNlSG92ZXJbMF0sIHNlbGYuc2hvdyk7XG4gICAgICBvbihlbGVtZW50LCBtb3VzZUhvdmVyWzFdLCBzZWxmLmhpZGUpO1xuICAgIH1cbiAgICBlbGVtZW50W3N0cmluZ1Rvb2x0aXBdID0gc2VsZjtcbiAgfTtcbiAgXG4gIC8vIFRPT0xUSVAgREFUQSBBUElcbiAgLy8gPT09PT09PT09PT09PT09PT1cbiAgc3VwcG9ydHNbcHVzaF0oIFsgc3RyaW5nVG9vbHRpcCwgVG9vbHRpcCwgJ1snK2RhdGFUb2dnbGUrJz1cInRvb2x0aXBcIl0nIF0gKTtcbiAgXG4gIFxuICBcclxuICAvKiBOYXRpdmUgSmF2YXNjcmlwdCBmb3IgQm9vdHN0cmFwIHwgSW5pdGlhbGl6ZSBEYXRhIEFQSVxyXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICB2YXIgaW5pdGlhbGl6ZURhdGFBUEkgPSBmdW5jdGlvbiggY29uc3RydWN0b3IsIGNvbGxlY3Rpb24gKXtcclxuICAgICAgZm9yICh2YXIgaT0wLCBsPWNvbGxlY3Rpb25bbGVuZ3RoXTsgaTxsOyBpKyspIHtcclxuICAgICAgICBuZXcgY29uc3RydWN0b3IoY29sbGVjdGlvbltpXSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBpbml0Q2FsbGJhY2sgPSBCU04uaW5pdENhbGxiYWNrID0gZnVuY3Rpb24obG9va1VwKXtcclxuICAgICAgbG9va1VwID0gbG9va1VwIHx8IERPQztcclxuICAgICAgZm9yICh2YXIgaT0wLCBsPXN1cHBvcnRzW2xlbmd0aF07IGk8bDsgaSsrKSB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZURhdGFBUEkoIHN1cHBvcnRzW2ldWzFdLCBsb29rVXBbcXVlcnlTZWxlY3RvckFsbF0gKHN1cHBvcnRzW2ldWzJdKSApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIFxyXG4gIC8vIGJ1bGsgaW5pdGlhbGl6ZSBhbGwgY29tcG9uZW50c1xyXG4gIERPQ1tib2R5XSA/IGluaXRDYWxsYmFjaygpIDogb24oIERPQywgJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpeyBpbml0Q2FsbGJhY2soKTsgfSApO1xyXG4gIFxuICByZXR1cm4ge1xuICAgIEFsZXJ0OiBBbGVydCxcbiAgICBCdXR0b246IEJ1dHRvbixcbiAgICBDYXJvdXNlbDogQ2Fyb3VzZWwsXG4gICAgQ29sbGFwc2U6IENvbGxhcHNlLFxuICAgIERyb3Bkb3duOiBEcm9wZG93bixcbiAgICBNb2RhbDogTW9kYWwsXG4gICAgUG9wb3ZlcjogUG9wb3ZlcixcbiAgICBTY3JvbGxTcHk6IFNjcm9sbFNweSxcbiAgICBUYWI6IFRhYixcbiAgICBUb2FzdDogVG9hc3QsXG4gICAgVG9vbHRpcDogVG9vbHRpcFxuICB9O1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bootstrap.native/dist/bootstrap-native-v4.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./resources/js/src/app.js":
/*!*********************************!*\
  !*** ./resources/js/src/app.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var bootstrap = __webpack_require__(/*! bootstrap.native/dist/bootstrap-native-v4 */ \"./node_modules/bootstrap.native/dist/bootstrap-native-v4.js\");\n\n(function (window, document) {\n  var messages = Array.prototype.slice.call(document.querySelectorAll('.toast'));\n  messages.forEach(function (message) {\n    new bootstrap.Toast(message, {\n      delay: message.dataset.delay == undefined ? 3000 : message.dataset.delay,\n      autohide: message.dataset.autohide == undefined ? true : Boolean(message.dataset.autohide)\n    }).show();\n  });\n})(window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvc3JjL2FwcC5qcz8wZWE3Il0sIm5hbWVzIjpbImJvb3RzdHJhcCIsInJlcXVpcmUiLCJ3aW5kb3ciLCJkb2N1bWVudCIsIm1lc3NhZ2VzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsIm1lc3NhZ2UiLCJUb2FzdCIsImRlbGF5IiwiZGF0YXNldCIsInVuZGVmaW5lZCIsImF1dG9oaWRlIiwiQm9vbGVhbiIsInNob3ciXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFNBQVMsR0FBR0MsbUJBQU8sQ0FBQyw4R0FBRCxDQUF2Qjs7QUFFQSxDQUFDLFVBQVVDLE1BQVYsRUFBa0JDLFFBQWxCLEVBQTRCO0FBRXpCLE1BQUlDLFFBQVEsR0FBR0MsS0FBSyxDQUFDQyxTQUFOLENBQWdCQyxLQUFoQixDQUFzQkMsSUFBdEIsQ0FDWEwsUUFBUSxDQUFDTSxnQkFBVCxDQUEwQixRQUExQixDQURXLENBQWY7QUFJQUwsVUFBUSxDQUFDTSxPQUFULENBQWlCLFVBQVVDLE9BQVYsRUFBbUI7QUFDaEMsUUFBSVgsU0FBUyxDQUFDWSxLQUFkLENBQW9CRCxPQUFwQixFQUE2QjtBQUN6QkUsV0FBSyxFQUFFRixPQUFPLENBQUNHLE9BQVIsQ0FBZ0JELEtBQWhCLElBQXlCRSxTQUF6QixHQUFxQyxJQUFyQyxHQUE0Q0osT0FBTyxDQUFDRyxPQUFSLENBQWdCRCxLQUQxQztBQUV6QkcsY0FBUSxFQUFFTCxPQUFPLENBQUNHLE9BQVIsQ0FBZ0JFLFFBQWhCLElBQTRCRCxTQUE1QixHQUF3QyxJQUF4QyxHQUErQ0UsT0FBTyxDQUFDTixPQUFPLENBQUNHLE9BQVIsQ0FBZ0JFLFFBQWpCO0FBRnZDLEtBQTdCLEVBR0dFLElBSEg7QUFJSCxHQUxEO0FBT0gsQ0FiRCxFQWFHaEIsTUFiSCxFQWFXQyxRQWJYIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL3NyYy9hcHAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwLm5hdGl2ZS9kaXN0L2Jvb3RzdHJhcC1uYXRpdmUtdjQnKTtcblxuKGZ1bmN0aW9uICh3aW5kb3csIGRvY3VtZW50KSB7XG5cbiAgICBsZXQgbWVzc2FnZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRvYXN0JylcbiAgICApO1xuXG4gICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBuZXcgYm9vdHN0cmFwLlRvYXN0KG1lc3NhZ2UsIHtcbiAgICAgICAgICAgIGRlbGF5OiBtZXNzYWdlLmRhdGFzZXQuZGVsYXkgPT0gdW5kZWZpbmVkID8gMzAwMCA6IG1lc3NhZ2UuZGF0YXNldC5kZWxheSxcbiAgICAgICAgICAgIGF1dG9oaWRlOiBtZXNzYWdlLmRhdGFzZXQuYXV0b2hpZGUgPT0gdW5kZWZpbmVkID8gdHJ1ZSA6IEJvb2xlYW4obWVzc2FnZS5kYXRhc2V0LmF1dG9oaWRlKVxuICAgICAgICB9KS5zaG93KCk7XG4gICAgfSk7XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/src/app.js\n");

/***/ }),

/***/ "./resources/js/src/polyfills.js":
/*!***************************************!*\
  !*** ./resources/js/src/polyfills.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Polyfill for matches()\n */\nif (!Element.prototype.matches) {\n  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n}\n\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function (s) {\n    var el = this;\n\n    do {\n      if (el.matches(s)) return el;\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1);\n\n    return null;\n  };\n}\n/**\n * Polyfill for closest()\n * - Relies on matches() above.\n */\n\n\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function (s) {\n    var el = this;\n\n    do {\n      if (el.matches(s)) return el;\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1);\n\n    return null;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvc3JjL3BvbHlmaWxscy5qcz9kZWNmIl0sIm5hbWVzIjpbIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJtYXRjaGVzIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJjbG9zZXN0IiwicyIsImVsIiwicGFyZW50RWxlbWVudCIsInBhcmVudE5vZGUiLCJub2RlVHlwZSJdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBLElBQUksQ0FBQ0EsT0FBTyxDQUFDQyxTQUFSLENBQWtCQyxPQUF2QixFQUFnQztBQUM1QkYsU0FBTyxDQUFDQyxTQUFSLENBQWtCQyxPQUFsQixHQUE0QkYsT0FBTyxDQUFDQyxTQUFSLENBQWtCRSxpQkFBbEIsSUFDeEJILE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkcscUJBRHRCO0FBRUg7O0FBRUQsSUFBSSxDQUFDSixPQUFPLENBQUNDLFNBQVIsQ0FBa0JJLE9BQXZCLEVBQWdDO0FBQzVCTCxTQUFPLENBQUNDLFNBQVIsQ0FBa0JJLE9BQWxCLEdBQTRCLFVBQVVDLENBQVYsRUFBYTtBQUNyQyxRQUFJQyxFQUFFLEdBQUcsSUFBVDs7QUFFQSxPQUFHO0FBQ0MsVUFBSUEsRUFBRSxDQUFDTCxPQUFILENBQVdJLENBQVgsQ0FBSixFQUFtQixPQUFPQyxFQUFQO0FBQ25CQSxRQUFFLEdBQUdBLEVBQUUsQ0FBQ0MsYUFBSCxJQUFvQkQsRUFBRSxDQUFDRSxVQUE1QjtBQUNILEtBSEQsUUFHU0YsRUFBRSxLQUFLLElBQVAsSUFBZUEsRUFBRSxDQUFDRyxRQUFILEtBQWdCLENBSHhDOztBQUlBLFdBQU8sSUFBUDtBQUNILEdBUkQ7QUFTSDtBQUVEOzs7Ozs7QUFJQSxJQUFJLENBQUNWLE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkksT0FBdkIsRUFBZ0M7QUFDNUJMLFNBQU8sQ0FBQ0MsU0FBUixDQUFrQkksT0FBbEIsR0FBNEIsVUFBVUMsQ0FBVixFQUFhO0FBQ3JDLFFBQUlDLEVBQUUsR0FBRyxJQUFUOztBQUVBLE9BQUc7QUFDQyxVQUFJQSxFQUFFLENBQUNMLE9BQUgsQ0FBV0ksQ0FBWCxDQUFKLEVBQW1CLE9BQU9DLEVBQVA7QUFDbkJBLFFBQUUsR0FBR0EsRUFBRSxDQUFDQyxhQUFILElBQW9CRCxFQUFFLENBQUNFLFVBQTVCO0FBQ0gsS0FIRCxRQUdTRixFQUFFLEtBQUssSUFBUCxJQUFlQSxFQUFFLENBQUNHLFFBQUgsS0FBZ0IsQ0FIeEM7O0FBSUEsV0FBTyxJQUFQO0FBQ0gsR0FSRDtBQVNIIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL3NyYy9wb2x5ZmlsbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBvbHlmaWxsIGZvciBtYXRjaGVzKClcbiAqL1xuaWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG4gICAgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgIEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3Rvcjtcbn1cblxuaWYgKCFFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0KSB7XG4gICAgRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXM7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVsLm1hdGNoZXMocykpIHJldHVybiBlbDtcbiAgICAgICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlO1xuICAgICAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG5cbi8qKlxuICogUG9seWZpbGwgZm9yIGNsb3Nlc3QoKVxuICogLSBSZWxpZXMgb24gbWF0Y2hlcygpIGFib3ZlLlxuICovXG5pZiAoIUVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QpIHtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcztcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZWwubWF0Y2hlcyhzKSkgcmV0dXJuIGVsO1xuICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGU7XG4gICAgICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/src/polyfills.js\n");

/***/ }),

/***/ "./resources/scss/theme/login.scss":
/*!*****************************************!*\
  !*** ./resources/scss/theme/login.scss ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy90aGVtZS9sb2dpbi5zY3NzPzI0MjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiLi9yZXNvdXJjZXMvc2Nzcy90aGVtZS9sb2dpbi5zY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/scss/theme/login.scss\n");

/***/ }),

/***/ "./resources/scss/theme/theme.scss":
/*!*****************************************!*\
  !*** ./resources/scss/theme/theme.scss ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy90aGVtZS90aGVtZS5zY3NzPzg5OTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiLi9yZXNvdXJjZXMvc2Nzcy90aGVtZS90aGVtZS5zY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/scss/theme/theme.scss\n");

/***/ }),

/***/ 0:
/*!*******************************************************************************************************************************************!*\
  !*** multi ./resources/js/src/app.js ./resources/js/src/polyfills.js ./resources/scss/theme/theme.scss ./resources/scss/theme/login.scss ***!
  \*******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! /Users/ryanthompson/Sites/streams.local/vendor/anomaly/flow-theme/resources/js/src/app.js */"./resources/js/src/app.js");
__webpack_require__(/*! /Users/ryanthompson/Sites/streams.local/vendor/anomaly/flow-theme/resources/js/src/polyfills.js */"./resources/js/src/polyfills.js");
__webpack_require__(/*! /Users/ryanthompson/Sites/streams.local/vendor/anomaly/flow-theme/resources/scss/theme/theme.scss */"./resources/scss/theme/theme.scss");
module.exports = __webpack_require__(/*! /Users/ryanthompson/Sites/streams.local/vendor/anomaly/flow-theme/resources/scss/theme/login.scss */"./resources/scss/theme/login.scss");


/***/ })

/******/ });