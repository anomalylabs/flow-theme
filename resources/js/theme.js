/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/bootstrap.native/dist/bootstrap-native-v4.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bootstrap.native/dist/bootstrap-native-v4.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Native Javascript for Bootstrap 4 v2.0.27 | Â© dnp_theme | MIT-License\n(function (root, factory) {\n  if (true) {\n    // AMD support:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var bsn; }\n}(this, function () {\n\n  /* Native Javascript for Bootstrap 4 | Internal Utility Functions\n  ----------------------------------------------------------------*/\n  \"use strict\";\n\n  // globals\n  var globalObject = typeof global !== 'undefined' ? global : this || window,\n    DOC = document,\n    HTML = DOC.documentElement,\n    body = 'body', // allow the library to be used in <head>\n\n    // Native Javascript for Bootstrap Global Object\n    BSN = globalObject.BSN = {},\n    supports = BSN.supports = [],\n\n    // function toggle attributes\n    dataToggle = 'data-toggle',\n    dataDismiss = 'data-dismiss',\n    dataSpy = 'data-spy',\n    dataRide = 'data-ride',\n\n    // components\n    stringAlert = 'Alert',\n    stringButton = 'Button',\n    stringCarousel = 'Carousel',\n    stringCollapse = 'Collapse',\n    stringDropdown = 'Dropdown',\n    stringModal = 'Modal',\n    stringPopover = 'Popover',\n    stringScrollSpy = 'ScrollSpy',\n    stringTab = 'Tab',\n    stringTooltip = 'Tooltip',\n    stringToast = 'Toast',\n\n    // options DATA API\n    dataAutohide = 'data-autohide',\n    databackdrop = 'data-backdrop',\n    dataKeyboard = 'data-keyboard',\n    dataTarget = 'data-target',\n    dataInterval = 'data-interval',\n    dataHeight = 'data-height',\n    dataPause = 'data-pause',\n    dataTitle = 'data-title',\n    dataOriginalTitle = 'data-original-title',\n    dataDismissible = 'data-dismissible',\n    dataTrigger = 'data-trigger',\n    dataAnimation = 'data-animation',\n    dataContainer = 'data-container',\n    dataPlacement = 'data-placement',\n    dataDelay = 'data-delay',\n\n    // option keys\n    backdrop = 'backdrop',\n    keyboard = 'keyboard',\n    delay = 'delay',\n    content = 'content',\n    target = 'target',\n    currentTarget = 'currentTarget',\n    interval = 'interval',\n    pause = 'pause',\n    animation = 'animation',\n    placement = 'placement',\n    container = 'container',\n\n    // box model\n    offsetTop = 'offsetTop',\n    offsetBottom = 'offsetBottom',\n    offsetLeft = 'offsetLeft',\n    scrollTop = 'scrollTop',\n    scrollLeft = 'scrollLeft',\n    clientWidth = 'clientWidth',\n    clientHeight = 'clientHeight',\n    offsetWidth = 'offsetWidth',\n    offsetHeight = 'offsetHeight',\n    innerWidth = 'innerWidth',\n    innerHeight = 'innerHeight',\n    scrollHeight = 'scrollHeight',\n    scrollWidth = 'scrollWidth',\n    height = 'height',\n\n    // aria\n    ariaExpanded = 'aria-expanded',\n    ariaHidden = 'aria-hidden',\n    ariaSelected = 'aria-selected',\n\n    // event names\n    clickEvent = 'click',\n    focusEvent = 'focus',\n    hoverEvent = 'hover',\n    keydownEvent = 'keydown',\n    keyupEvent = 'keyup',\n    resizeEvent = 'resize', // passive\n    scrollEvent = 'scroll', // passive\n    mouseHover = ('onmouseleave' in DOC) ? ['mouseenter', 'mouseleave'] : ['mouseover', 'mouseout'],\n    // touch since 2.0.26\n    touchEvents = {\n      start: 'touchstart',\n      end: 'touchend',\n      move: 'touchmove'\n    }, // passive\n    // originalEvents\n    showEvent = 'show',\n    shownEvent = 'shown',\n    hideEvent = 'hide',\n    hiddenEvent = 'hidden',\n    closeEvent = 'close',\n    closedEvent = 'closed',\n    slidEvent = 'slid',\n    slideEvent = 'slide',\n    changeEvent = 'change',\n\n    // other\n    getAttribute = 'getAttribute',\n    setAttribute = 'setAttribute',\n    hasAttribute = 'hasAttribute',\n    createElement = 'createElement',\n    appendChild = 'appendChild',\n    innerHTML = 'innerHTML',\n    getElementsByTagName = 'getElementsByTagName',\n    preventDefault = 'preventDefault',\n    getBoundingClientRect = 'getBoundingClientRect',\n    querySelectorAll = 'querySelectorAll',\n    getElementsByCLASSNAME = 'getElementsByClassName',\n    getComputedStyle = 'getComputedStyle',\n\n    indexOf = 'indexOf',\n    parentNode = 'parentNode',\n    length = 'length',\n    toLowerCase = 'toLowerCase',\n    Transition = 'Transition',\n    Duration = 'Duration',\n    Webkit = 'Webkit',\n    style = 'style',\n    push = 'push',\n    tabindex = 'tabindex',\n    contains = 'contains',\n\n    active = 'active',\n    showClass = 'show',\n    collapsing = 'collapsing',\n    disabled = 'disabled',\n    loading = 'loading',\n    left = 'left',\n    right = 'right',\n    top = 'top',\n    bottom = 'bottom',\n\n    // tooltip / popover\n    tipPositions = /\\b(top|bottom|left|right)+/,\n\n    // modal\n    modalOverlay = 0,\n    fixedTop = 'fixed-top',\n    fixedBottom = 'fixed-bottom',\n\n    // transitionEnd since 2.0.4\n    supportTransitions = Webkit + Transition in HTML[style] || Transition[toLowerCase]() in HTML[style],\n    transitionEndEvent = Webkit + Transition in HTML[style] ? Webkit[toLowerCase]() + Transition + 'End' : Transition[toLowerCase]() + 'end',\n    transitionDuration = Webkit + Duration in HTML[style] ? Webkit[toLowerCase]() + Transition + Duration : Transition[toLowerCase]() + Duration,\n\n    // set new focus element since 2.0.3\n    setFocus = function (element) {\n      element.focus ? element.focus() : element.setActive();\n    },\n\n    // class manipulation, since 2.0.0 requires polyfill.js\n    addClass = function (element, classNAME) {\n      element.classList.add(classNAME);\n    },\n    removeClass = function (element, classNAME) {\n      element.classList.remove(classNAME);\n    },\n    hasClass = function (element, classNAME) { // since 2.0.0\n      return element.classList[contains](classNAME);\n    },\n\n    // selection methods\n    getElementsByClassName = function (element, classNAME) { // returns Array\n      return [].slice.call(element[getElementsByCLASSNAME](classNAME));\n    },\n    queryElement = function (selector, parent) {\n      var lookUp = parent ? parent : DOC;\n      return typeof selector === 'object' ? selector : lookUp.querySelector(selector);\n    },\n    getClosest = function (element, selector) { //element is the element and selector is for the closest parent element to find\n      // source http://gomakethings.com/climbing-up-and-down-the-dom-tree-with-vanilla-javascript/\n      var firstChar = selector.charAt(0),\n        selectorSubstring = selector.substr(1);\n      if (firstChar === '.') { // If selector is a class\n        for (; element && element !== DOC; element = element[parentNode]) { // Get closest match\n          if (queryElement(selector, element[parentNode]) !== null && hasClass(element, selectorSubstring)) {\n            return element;\n          }\n        }\n      } else if (firstChar === '#') { // If selector is an ID\n        for (; element && element !== DOC; element = element[parentNode]) { // Get closest match\n          if (element.id === selectorSubstring) {\n            return element;\n          }\n        }\n      }\n      return false;\n    },\n\n    // event attach jQuery style / trigger  since 1.2.0\n    on = function (element, event, handler, options) {\n      options = options || false;\n      element.addEventListener(event, handler, options);\n    },\n    off = function (element, event, handler, options) {\n      options = options || false;\n      element.removeEventListener(event, handler, options);\n    },\n    one = function (element, event, handler, options) { // one since 2.0.4\n      on(element, event, function handlerWrapper(e) {\n        handler(e);\n        off(element, event, handlerWrapper, options);\n      }, options);\n    },\n    // determine support for passive events\n    supportPassive = (function () {\n      // Test via a getter in the options object to see if the passive property is accessed\n      var result = false;\n      try {\n        var opts = Object.defineProperty({}, 'passive', {\n          get: function () {\n            result = true;\n          }\n        });\n        one(globalObject, 'testPassive', null, opts);\n      } catch (e) {}\n\n      return result;\n    }()),\n    // event options\n    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n    passiveHandler = supportPassive ? {\n      passive: true\n    } : false,\n    // transitions\n    getTransitionDurationFromElement = function (element) {\n      var duration = supportTransitions ? globalObject[getComputedStyle](element)[transitionDuration] : 0;\n      duration = parseFloat(duration);\n      duration = typeof duration === 'number' && !isNaN(duration) ? duration * 1000 : 0;\n      return duration; // we take a short offset to make sure we fire on the next frame after animation\n    },\n    emulateTransitionEnd = function (element, handler) { // emulateTransitionEnd since 2.0.4\n      var called = 0,\n        duration = getTransitionDurationFromElement(element);\n      duration ? one(element, transitionEndEvent, function (e) {\n          !called && handler(e), called = 1;\n        }) :\n        setTimeout(function () {\n          !called && handler(), called = 1;\n        }, 17);\n    },\n    bootstrapCustomEvent = function (eventName, componentName, related) {\n      var OriginalCustomEvent = new CustomEvent(eventName + '.bs.' + componentName);\n      OriginalCustomEvent.relatedTarget = related;\n      this.dispatchEvent(OriginalCustomEvent);\n    },\n\n    // tooltip / popover stuff\n    getScroll = function () { // also Affix and ScrollSpy uses it\n      return {\n        y: globalObject.pageYOffset || HTML[scrollTop],\n        x: globalObject.pageXOffset || HTML[scrollLeft]\n      }\n    },\n    styleTip = function (link, element, position, parent) { // both popovers and tooltips (target,tooltip,placement,elementToAppendTo)\n      var elementDimensions = {\n          w: element[offsetWidth],\n          h: element[offsetHeight]\n        },\n        windowWidth = (HTML[clientWidth] || DOC[body][clientWidth]),\n        windowHeight = (HTML[clientHeight] || DOC[body][clientHeight]),\n        rect = link[getBoundingClientRect](),\n        scroll = parent === DOC[body] ? getScroll() : {\n          x: parent[offsetLeft] + parent[scrollLeft],\n          y: parent[offsetTop] + parent[scrollTop]\n        },\n        linkDimensions = {\n          w: rect[right] - rect[left],\n          h: rect[bottom] - rect[top]\n        },\n        isPopover = hasClass(element, 'popover'),\n        topPosition, leftPosition,\n\n        arrow = queryElement('.arrow', element),\n        arrowTop, arrowLeft, arrowWidth, arrowHeight,\n\n        halfTopExceed = rect[top] + linkDimensions.h / 2 - elementDimensions.h / 2 < 0,\n        halfLeftExceed = rect[left] + linkDimensions.w / 2 - elementDimensions.w / 2 < 0,\n        halfRightExceed = rect[left] + elementDimensions.w / 2 + linkDimensions.w / 2 >= windowWidth,\n        halfBottomExceed = rect[top] + elementDimensions.h / 2 + linkDimensions.h / 2 >= windowHeight,\n        topExceed = rect[top] - elementDimensions.h < 0,\n        leftExceed = rect[left] - elementDimensions.w < 0,\n        bottomExceed = rect[top] + elementDimensions.h + linkDimensions.h >= windowHeight,\n        rightExceed = rect[left] + elementDimensions.w + linkDimensions.w >= windowWidth;\n\n      // recompute position\n      position = (position === left || position === right) && leftExceed && rightExceed ? top : position; // first, when both left and right limits are exceeded, we fall back to top|bottom\n      position = position === top && topExceed ? bottom : position;\n      position = position === bottom && bottomExceed ? top : position;\n      position = position === left && leftExceed ? right : position;\n      position = position === right && rightExceed ? left : position;\n\n      // update tooltip/popover class\n      element.className[indexOf](position) === -1 && (element.className = element.className.replace(tipPositions, position));\n\n      // we check the computed width & height and update here\n      arrowWidth = arrow[offsetWidth];\n      arrowHeight = arrow[offsetHeight];\n\n      // apply styling to tooltip or popover\n      if (position === left || position === right) { // secondary|side positions\n        if (position === left) { // LEFT\n          leftPosition = rect[left] + scroll.x - elementDimensions.w - (isPopover ? arrowWidth : 0);\n        } else { // RIGHT\n          leftPosition = rect[left] + scroll.x + linkDimensions.w;\n        }\n\n        // adjust top and arrow\n        if (halfTopExceed) {\n          topPosition = rect[top] + scroll.y;\n          arrowTop = linkDimensions.h / 2 - arrowWidth;\n        } else if (halfBottomExceed) {\n          topPosition = rect[top] + scroll.y - elementDimensions.h + linkDimensions.h;\n          arrowTop = elementDimensions.h - linkDimensions.h / 2 - arrowWidth;\n        } else {\n          topPosition = rect[top] + scroll.y - elementDimensions.h / 2 + linkDimensions.h / 2;\n          arrowTop = elementDimensions.h / 2 - (isPopover ? arrowHeight * 0.9 : arrowHeight / 2);\n        }\n      } else if (position === top || position === bottom) { // primary|vertical positions\n        if (position === top) { // TOP\n          topPosition = rect[top] + scroll.y - elementDimensions.h - (isPopover ? arrowHeight : 0);\n        } else { // BOTTOM\n          topPosition = rect[top] + scroll.y + linkDimensions.h;\n        }\n        // adjust left | right and also the arrow\n        if (halfLeftExceed) {\n          leftPosition = 0;\n          arrowLeft = rect[left] + linkDimensions.w / 2 - arrowWidth;\n        } else if (halfRightExceed) {\n          leftPosition = windowWidth - elementDimensions.w * 1.01;\n          arrowLeft = elementDimensions.w - (windowWidth - rect[left]) + linkDimensions.w / 2 - arrowWidth / 2;\n        } else {\n          leftPosition = rect[left] + scroll.x - elementDimensions.w / 2 + linkDimensions.w / 2;\n          arrowLeft = elementDimensions.w / 2 - (isPopover ? arrowWidth : arrowWidth / 2);\n        }\n      }\n\n      // apply style to tooltip/popover and its arrow\n      element[style][top] = topPosition + 'px';\n      element[style][left] = leftPosition + 'px';\n\n      arrowTop && (arrow[style][top] = arrowTop + 'px');\n      arrowLeft && (arrow[style][left] = arrowLeft + 'px');\n    };\n\n  BSN.version = '2.0.27';\n\n  /* Native Javascript for Bootstrap 4 | Alert\n  -------------------------------------------*/\n\n  // ALERT DEFINITION\n  // ================\n  var Alert = function (element) {\n\n    // initialization element\n    element = queryElement(element);\n\n    // bind, target alert, duration and stuff\n    var self = this,\n      component = 'alert',\n      alert = getClosest(element, '.' + component),\n      triggerHandler = function () {\n        hasClass(alert, 'fade') ? emulateTransitionEnd(alert, transitionEndHandler) : transitionEndHandler();\n      },\n      // handlers\n      clickHandler = function (e) {\n        alert = getClosest(e[target], '.' + component);\n        element = queryElement('[' + dataDismiss + '=\"' + component + '\"]', alert);\n        element && alert && (element === e[target] || element[contains](e[target])) && self.close();\n      },\n      transitionEndHandler = function () {\n        bootstrapCustomEvent.call(alert, closedEvent, component);\n        off(element, clickEvent, clickHandler); // detach it's listener\n        alert[parentNode].removeChild(alert);\n      };\n\n    // public method\n    this.close = function () {\n      if (alert && element && hasClass(alert, showClass)) {\n        bootstrapCustomEvent.call(alert, closeEvent, component);\n        removeClass(alert, showClass);\n        alert && triggerHandler();\n      }\n    };\n\n    // init\n    if (!(stringAlert in element)) { // prevent adding event handlers twice\n      on(element, clickEvent, clickHandler);\n    }\n    element[stringAlert] = self;\n  };\n\n  // ALERT DATA API\n  // ==============\n  supports[push]([stringAlert, Alert, '[' + dataDismiss + '=\"alert\"]']);\n\n\n  /* Native Javascript for Bootstrap 4 | Button\n  ---------------------------------------------*/\n\n  // BUTTON DEFINITION\n  // ===================\n  var Button = function (element) {\n\n    // initialization element\n    element = queryElement(element);\n\n    // constant\n    var toggled = false, // toggled makes sure to prevent triggering twice the change.bs.button events\n\n      // strings\n      component = 'button',\n      checked = 'checked',\n      LABEL = 'LABEL',\n      INPUT = 'INPUT',\n\n      // private methods\n      keyHandler = function (e) {\n        var key = e.which || e.keyCode;\n        key === 32 && e[target] === DOC.activeElement && toggle(e);\n      },\n      preventScroll = function (e) {\n        var key = e.which || e.keyCode;\n        key === 32 && e[preventDefault]();\n      },\n      toggle = function (e) {\n        var label = e[target].tagName === LABEL ? e[target] : e[target][parentNode].tagName === LABEL ? e[target][parentNode] : null; // the .btn label\n\n        if (!label) return; //react if a label or its immediate child is clicked\n\n        var labels = getElementsByClassName(label[parentNode], 'btn'), // all the button group buttons\n          input = label[getElementsByTagName](INPUT)[0];\n\n        if (!input) return; // return if no input found\n\n        // manage the dom manipulation\n        if (input.type === 'checkbox') { //checkboxes\n          if (!input[checked]) {\n            addClass(label, active);\n            input[getAttribute](checked);\n            input[setAttribute](checked, checked);\n            input[checked] = true;\n          } else {\n            removeClass(label, active);\n            input[getAttribute](checked);\n            input.removeAttribute(checked);\n            input[checked] = false;\n          }\n\n          if (!toggled) { // prevent triggering the event twice\n            toggled = true;\n            bootstrapCustomEvent.call(input, changeEvent, component); //trigger the change for the input\n            bootstrapCustomEvent.call(element, changeEvent, component); //trigger the change for the btn-group\n          }\n        }\n\n        if (input.type === 'radio' && !toggled) { // radio buttons\n          // don't trigger if already active (the OR condition is a hack to check if the buttons were selected with key press and NOT mouse click)\n          if (!input[checked] || (e.screenX === 0 && e.screenY == 0)) {\n            addClass(label, active);\n            addClass(label, focusEvent);\n            input[setAttribute](checked, checked);\n            input[checked] = true;\n            bootstrapCustomEvent.call(input, changeEvent, component); //trigger the change for the input\n            bootstrapCustomEvent.call(element, changeEvent, component); //trigger the change for the btn-group\n\n            toggled = true;\n            for (var i = 0, ll = labels[length]; i < ll; i++) {\n              var otherLabel = labels[i],\n                otherInput = otherLabel[getElementsByTagName](INPUT)[0];\n              if (otherLabel !== label && hasClass(otherLabel, active)) {\n                removeClass(otherLabel, active);\n                otherInput.removeAttribute(checked);\n                otherInput[checked] = false;\n                bootstrapCustomEvent.call(otherInput, changeEvent, component); // trigger the change\n              }\n            }\n          }\n        }\n        setTimeout(function () {\n          toggled = false;\n        }, 50);\n      },\n      focusHandler = function (e) {\n        addClass(e[target][parentNode], focusEvent);\n      },\n      blurHandler = function (e) {\n        removeClass(e[target][parentNode], focusEvent);\n      };\n\n    // init\n    if (!(stringButton in element)) { // prevent adding event handlers twice\n      on(element, clickEvent, toggle);\n      on(element, keyupEvent, keyHandler), on(element, keydownEvent, preventScroll);\n\n      var allBtns = getElementsByClassName(element, 'btn');\n      for (var i = 0; i < allBtns.length; i++) {\n        var input = allBtns[i][getElementsByTagName](INPUT)[0];\n        on(input, focusEvent, focusHandler), on(input, 'blur', blurHandler);\n      }\n    }\n\n    // activate items on load\n    var labelsToACtivate = getElementsByClassName(element, 'btn'),\n      lbll = labelsToACtivate[length];\n    for (var i = 0; i < lbll; i++) {\n      !hasClass(labelsToACtivate[i], active) && queryElement('input:checked', labelsToACtivate[i]) &&\n        addClass(labelsToACtivate[i], active);\n    }\n    element[stringButton] = this;\n  };\n\n  // BUTTON DATA API\n  // =================\n  supports[push]([stringButton, Button, '[' + dataToggle + '=\"buttons\"]']);\n\n\n  /* Native Javascript for Bootstrap 4 | Carousel\n  ----------------------------------------------*/\n\n  // CAROUSEL DEFINITION\n  // ===================\n  var Carousel = function (element, options) {\n\n    // initialization element\n    element = queryElement(element);\n\n    // set options\n    options = options || {};\n\n    // DATA API\n    var intervalAttribute = element[getAttribute](dataInterval),\n      intervalOption = options[interval],\n      intervalData = intervalAttribute === 'false' ? 0 : parseInt(intervalAttribute),\n      pauseData = element[getAttribute](dataPause) === hoverEvent || false,\n      keyboardData = element[getAttribute](dataKeyboard) === 'true' || false,\n\n      // strings\n      component = 'carousel',\n      paused = 'paused',\n      direction = 'direction',\n      carouselItem = 'carousel-item',\n      dataSlideTo = 'data-slide-to';\n\n    this[keyboard] = options[keyboard] === true || keyboardData;\n    this[pause] = (options[pause] === hoverEvent || pauseData) ? hoverEvent : false; // false / hover\n\n    this[interval] = typeof intervalOption === 'number' ? intervalOption :\n      intervalOption === false || intervalData === 0 || intervalData === false ? 0 :\n      isNaN(intervalData) ? 5000 // bootstrap carousel default interval\n      :\n      intervalData;\n\n    // bind, event targets\n    var self = this,\n      index = element.index = 0,\n      timer = element.timer = 0,\n      isSliding = false, // isSliding prevents click event handlers when animation is running\n      isTouch = false,\n      startXPosition = null,\n      currentXPosition = null,\n      endXPosition = null, // touch and event coordinates\n      slides = getElementsByClassName(element, carouselItem),\n      total = slides[length],\n      slideDirection = this[direction] = left,\n      leftArrow = getElementsByClassName(element, component + '-control-prev')[0],\n      rightArrow = getElementsByClassName(element, component + '-control-next')[0],\n      indicator = queryElement('.' + component + '-indicators', element),\n      indicators = indicator && indicator[getElementsByTagName](\"LI\") || [];\n\n    // invalidate when not enough items\n    if (total < 2) {\n      return;\n    }\n\n    // handlers\n    var pauseHandler = function () {\n        if (self[interval] !== false && !hasClass(element, paused)) {\n          addClass(element, paused);\n          !isSliding && (clearInterval(timer), timer = null);\n        }\n      },\n      resumeHandler = function () {\n        if (self[interval] !== false && hasClass(element, paused)) {\n          removeClass(element, paused);\n          !isSliding && (clearInterval(timer), timer = null);\n          !isSliding && self.cycle();\n        }\n      },\n      indicatorHandler = function (e) {\n        e[preventDefault]();\n        if (isSliding) return;\n\n        var eventTarget = e[target]; // event target | the current active item\n\n        if (eventTarget && !hasClass(eventTarget, active) && eventTarget[getAttribute](dataSlideTo)) {\n          index = parseInt(eventTarget[getAttribute](dataSlideTo), 10);\n        } else {\n          return false;\n        }\n\n        self.slideTo(index); //Do the slide\n      },\n      controlsHandler = function (e) {\n        e[preventDefault]();\n        if (isSliding) return;\n\n        var eventTarget = e.currentTarget || e.srcElement;\n\n        if (eventTarget === rightArrow) {\n          index++;\n        } else if (eventTarget === leftArrow) {\n          index--;\n        }\n\n        self.slideTo(index); //Do the slide\n      },\n      keyHandler = function (e) {\n        if (isSliding) return;\n        switch (e.which) {\n          case 39:\n            index++;\n            break;\n          case 37:\n            index--;\n            break;\n          default:\n            return;\n        }\n        self.slideTo(index); //Do the slide\n      },\n      // touch events\n      toggleTouchEvents = function (toggle) {\n        toggle(element, touchEvents.move, touchMoveHandler, passiveHandler);\n        toggle(element, touchEvents.end, touchEndHandler, passiveHandler);\n      },\n      touchDownHandler = function (e) {\n        if (isTouch) {\n          return;\n        }\n\n        startXPosition = parseInt(e.touches[0].pageX);\n\n        if (element.contains(e[target])) {\n          isTouch = true;\n          toggleTouchEvents(on);\n        }\n      },\n      touchMoveHandler = function (e) {\n        if (!isTouch) {\n          e.preventDefault();\n          return;\n        }\n\n        currentXPosition = parseInt(e.touches[0].pageX);\n\n        //cancel touch if more than one touches detected\n        if (e.type === 'touchmove' && e.touches[length] > 1) {\n          e.preventDefault();\n          return false;\n        }\n      },\n      touchEndHandler = function (e) {\n        if (!isTouch || isSliding) {\n          return\n        }\n\n        endXPosition = currentXPosition || parseInt(e.touches[0].pageX);\n\n        if (isTouch) {\n          if ((!element.contains(e[target]) || !element.contains(e.relatedTarget)) && Math.abs(startXPosition - endXPosition) < 75) {\n            return false;\n          } else {\n            if (currentXPosition < startXPosition) {\n              index++;\n            } else if (currentXPosition > startXPosition) {\n              index--;\n            }\n            isTouch = false;\n            self.slideTo(index);\n          }\n          toggleTouchEvents(off);\n        }\n      },\n\n      // private methods\n      isElementInScrollRange = function () {\n        var rect = element[getBoundingClientRect](),\n          viewportHeight = globalObject[innerHeight] || HTML[clientHeight]\n        return rect[top] <= viewportHeight && rect[bottom] >= 0; // bottom && top\n      },\n      setActivePage = function (pageIndex) { //indicators\n        for (var i = 0, icl = indicators[length]; i < icl; i++) {\n          removeClass(indicators[i], active);\n        }\n        if (indicators[pageIndex]) addClass(indicators[pageIndex], active);\n      };\n\n\n    // public methods\n    this.cycle = function () {\n      if (timer) {\n        clearInterval(timer);\n        timer = null;\n      }\n\n      timer = setInterval(function () {\n        isElementInScrollRange() && (index++, self.slideTo(index));\n      }, this[interval]);\n    };\n    this.slideTo = function (next) {\n      if (isSliding) return; // when controled via methods, make sure to check again      \n\n      var activeItem = this.getActiveIndex(), // the current active\n        orientation;\n\n      // first return if we're on the same item #227\n      if (activeItem === next) {\n        return;\n        // or determine slideDirection\n      } else if ((activeItem < next) || (activeItem === 0 && next === total - 1)) {\n        slideDirection = self[direction] = left; // next\n      } else if ((activeItem > next) || (activeItem === total - 1 && next === 0)) {\n        slideDirection = self[direction] = right; // prev\n      }\n\n      // find the right next index \n      if (next < 0) {\n        next = total - 1;\n      } else if (next >= total) {\n        next = 0;\n      }\n\n      // update index\n      index = next;\n\n      orientation = slideDirection === left ? 'next' : 'prev'; //determine type\n      bootstrapCustomEvent.call(element, slideEvent, component, slides[next]); // here we go with the slide\n\n      isSliding = true;\n      clearInterval(timer);\n      timer = null;\n      setActivePage(next);\n\n      if (supportTransitions && hasClass(element, 'slide')) {\n\n        addClass(slides[next], carouselItem + '-' + orientation);\n        slides[next][offsetWidth];\n        addClass(slides[next], carouselItem + '-' + slideDirection);\n        addClass(slides[activeItem], carouselItem + '-' + slideDirection);\n\n        emulateTransitionEnd(slides[next], function (e) {\n          var timeout = e && e[target] !== slides[next] ? e.elapsedTime * 1000 + 100 : 20;\n\n          isSliding && setTimeout(function () {\n            isSliding = false;\n\n            addClass(slides[next], active);\n            removeClass(slides[activeItem], active);\n\n            removeClass(slides[next], carouselItem + '-' + orientation);\n            removeClass(slides[next], carouselItem + '-' + slideDirection);\n            removeClass(slides[activeItem], carouselItem + '-' + slideDirection);\n\n            bootstrapCustomEvent.call(element, slidEvent, component, slides[next]);\n\n            if (!DOC.hidden && self[interval] && !hasClass(element, paused)) {\n              self.cycle();\n            }\n          }, timeout);\n        });\n\n      } else {\n        addClass(slides[next], active);\n        slides[next][offsetWidth];\n        removeClass(slides[activeItem], active);\n        setTimeout(function () {\n          isSliding = false;\n          if (self[interval] && !hasClass(element, paused)) {\n            self.cycle();\n          }\n          bootstrapCustomEvent.call(element, slidEvent, component, slides[next]);\n        }, 100);\n      }\n    };\n    this.getActiveIndex = function () {\n      return slides[indexOf](getElementsByClassName(element, carouselItem + ' active')[0]) || 0;\n    };\n\n    // init\n    if (!(stringCarousel in element)) { // prevent adding event handlers twice\n\n      if (self[pause] && self[interval]) {\n        on(element, mouseHover[0], pauseHandler);\n        on(element, mouseHover[1], resumeHandler);\n        on(element, touchEvents.start, pauseHandler, passiveHandler);\n        on(element, touchEvents.end, resumeHandler, passiveHandler);\n      }\n\n      slides[length] > 1 && on(element, touchEvents.start, touchDownHandler, passiveHandler);\n\n      rightArrow && on(rightArrow, clickEvent, controlsHandler);\n      leftArrow && on(leftArrow, clickEvent, controlsHandler);\n\n      indicator && on(indicator, clickEvent, indicatorHandler);\n      self[keyboard] && on(globalObject, keydownEvent, keyHandler);\n\n    }\n    if (self.getActiveIndex() < 0) {\n      slides[length] && addClass(slides[0], active);\n      indicators[length] && setActivePage(0);\n    }\n\n    if (self[interval]) {\n      self.cycle();\n    }\n    element[stringCarousel] = self;\n  };\n\n  // CAROUSEL DATA API\n  // =================\n  supports[push]([stringCarousel, Carousel, '[' + dataRide + '=\"carousel\"]']);\n\n\n  /* Native Javascript for Bootstrap 4 | Collapse\n  -----------------------------------------------*/\n\n  // COLLAPSE DEFINITION\n  // ===================\n  var Collapse = function (element, options) {\n\n    // initialization element\n    element = queryElement(element);\n\n    // set options\n    options = options || {};\n\n    // event targets and constants\n    var accordion = null,\n      collapse = null,\n      self = this,\n      accordionData = element[getAttribute]('data-parent'),\n      activeCollapse, activeElement,\n\n      // component strings\n      component = 'collapse',\n      collapsed = 'collapsed',\n      isAnimating = 'isAnimating',\n\n      // private methods\n      openAction = function (collapseElement, toggle) {\n        bootstrapCustomEvent.call(collapseElement, showEvent, component);\n        collapseElement[isAnimating] = true;\n        addClass(collapseElement, collapsing);\n        removeClass(collapseElement, component);\n        collapseElement[style][height] = collapseElement[scrollHeight] + 'px';\n\n        emulateTransitionEnd(collapseElement, function () {\n          collapseElement[isAnimating] = false;\n          collapseElement[setAttribute](ariaExpanded, 'true');\n          toggle[setAttribute](ariaExpanded, 'true');\n          removeClass(collapseElement, collapsing);\n          addClass(collapseElement, component);\n          addClass(collapseElement, showClass);\n          collapseElement[style][height] = '';\n          bootstrapCustomEvent.call(collapseElement, shownEvent, component);\n        });\n      },\n      closeAction = function (collapseElement, toggle) {\n        bootstrapCustomEvent.call(collapseElement, hideEvent, component);\n        collapseElement[isAnimating] = true;\n        collapseElement[style][height] = collapseElement[scrollHeight] + 'px'; // set height first\n        removeClass(collapseElement, component);\n        removeClass(collapseElement, showClass);\n        addClass(collapseElement, collapsing);\n        collapseElement[offsetWidth]; // force reflow to enable transition\n        collapseElement[style][height] = '0px';\n\n        emulateTransitionEnd(collapseElement, function () {\n          collapseElement[isAnimating] = false;\n          collapseElement[setAttribute](ariaExpanded, 'false');\n          toggle[setAttribute](ariaExpanded, 'false');\n          removeClass(collapseElement, collapsing);\n          addClass(collapseElement, component);\n          collapseElement[style][height] = '';\n          bootstrapCustomEvent.call(collapseElement, hiddenEvent, component);\n        });\n      },\n      getTarget = function () {\n        var href = element.href && element[getAttribute]('href'),\n          parent = element[getAttribute](dataTarget),\n          id = href || (parent && parent.charAt(0) === '#') && parent;\n        return id && queryElement(id);\n      };\n\n    // public methods\n    this.toggle = function (e) {\n      e[preventDefault]();\n      if (!hasClass(collapse, showClass)) {\n        self.show();\n      } else {\n        self.hide();\n      }\n    };\n    this.hide = function () {\n      if (collapse[isAnimating]) return;\n      closeAction(collapse, element);\n      addClass(element, collapsed);\n    };\n    this.show = function () {\n      if (accordion) {\n        activeCollapse = queryElement('.' + component + '.' + showClass, accordion);\n        activeElement = activeCollapse && (queryElement('[' + dataTarget + '=\"#' + activeCollapse.id + '\"]', accordion) ||\n          queryElement('[href=\"#' + activeCollapse.id + '\"]', accordion));\n      }\n\n      if (!collapse[isAnimating] || activeCollapse && !activeCollapse[isAnimating]) {\n        if (activeElement && activeCollapse !== collapse) {\n          closeAction(activeCollapse, activeElement);\n          addClass(activeElement, collapsed);\n        }\n        openAction(collapse, element);\n        removeClass(element, collapsed);\n      }\n    };\n\n    // init\n    if (!(stringCollapse in element)) { // prevent adding event handlers twice\n      on(element, clickEvent, self.toggle);\n    }\n    collapse = getTarget();\n    collapse[isAnimating] = false; // when true it will prevent click handlers  \n    accordion = queryElement(options.parent) || accordionData && getClosest(element, accordionData);\n    element[stringCollapse] = self;\n  };\n\n  // COLLAPSE DATA API\n  // =================\n  supports[push]([stringCollapse, Collapse, '[' + dataToggle + '=\"collapse\"]']);\n\n\n  /* Native Javascript for Bootstrap 4 | Dropdown\n  ----------------------------------------------*/\n\n  // DROPDOWN DEFINITION\n  // ===================\n  var Dropdown = function (element, option) {\n\n    // initialization element\n    element = queryElement(element);\n\n    // set option\n    this.persist = option === true || element[getAttribute]('data-persist') === 'true' || false;\n\n    // constants, event targets, strings\n    var self = this,\n      children = 'children',\n      parent = element[parentNode],\n      component = 'dropdown',\n      open = 'open',\n      relatedTarget = null,\n      menu = queryElement('.dropdown-menu', parent),\n      menuItems = (function () {\n        var set = menu[children],\n          newSet = [];\n        for (var i = 0; i < set[length]; i++) {\n          set[i][children][length] && (set[i][children][0].tagName === 'A' && newSet[push](set[i][children][0]));\n          set[i].tagName === 'A' && newSet[push](set[i]);\n        }\n        return newSet;\n      })(),\n\n      // preventDefault on empty anchor links\n      preventEmptyAnchor = function (anchor) {\n        (anchor.href && anchor.href.slice(-1) === '#' || anchor[parentNode] && anchor[parentNode].href &&\n          anchor[parentNode].href.slice(-1) === '#') && this[preventDefault]();\n      },\n\n      // toggle dismissible events\n      toggleDismiss = function () {\n        var type = element[open] ? on : off;\n        type(DOC, clickEvent, dismissHandler);\n        type(DOC, keydownEvent, preventScroll);\n        type(DOC, keyupEvent, keyHandler);\n        type(DOC, focusEvent, dismissHandler, true);\n      },\n\n      // handlers\n      dismissHandler = function (e) {\n        var eventTarget = e[target],\n          hasData = eventTarget && (eventTarget[getAttribute](dataToggle) ||\n            eventTarget[parentNode] && getAttribute in eventTarget[parentNode] &&\n            eventTarget[parentNode][getAttribute](dataToggle));\n        if (e.type === focusEvent && (eventTarget === element || eventTarget === menu || menu[contains](eventTarget))) {\n          return;\n        }\n        if ((eventTarget === menu || menu[contains](eventTarget)) && (self.persist || hasData)) {\n          return;\n        } else {\n          relatedTarget = eventTarget === element || element[contains](eventTarget) ? element : null;\n          hide();\n        }\n        preventEmptyAnchor.call(e, eventTarget);\n      },\n      clickHandler = function (e) {\n        relatedTarget = element;\n        show();\n        preventEmptyAnchor.call(e, e[target]);\n      },\n      preventScroll = function (e) {\n        var key = e.which || e.keyCode;\n        if (key === 38 || key === 40) {\n          e[preventDefault]();\n        }\n      },\n      keyHandler = function (e) {\n        var key = e.which || e.keyCode,\n          activeItem = DOC.activeElement,\n          idx = menuItems[indexOf](activeItem),\n          isSameElement = activeItem === element,\n          isInsideMenu = menu[contains](activeItem),\n          isMenuItem = activeItem[parentNode] === menu || activeItem[parentNode][parentNode] === menu;\n\n        if (isMenuItem) { // navigate up | down\n          idx = isSameElement ? 0 :\n            key === 38 ? (idx > 1 ? idx - 1 : 0) :\n            key === 40 ? (idx < menuItems[length] - 1 ? idx + 1 : idx) : idx;\n          menuItems[idx] && setFocus(menuItems[idx]);\n        }\n        if ((menuItems[length] && isMenuItem // menu has items\n            ||\n            !menuItems[length] && (isInsideMenu || isSameElement) // menu might be a form\n            ||\n            !isInsideMenu) // or the focused element is not in the menu at all\n          &&\n          element[open] && key === 27 // menu must be open\n        ) {\n          self.toggle();\n          relatedTarget = null;\n        }\n      },\n\n      // private methods\n      show = function () {\n        bootstrapCustomEvent.call(parent, showEvent, component, relatedTarget);\n        addClass(menu, showClass);\n        addClass(parent, showClass);\n        element[setAttribute](ariaExpanded, true);\n        bootstrapCustomEvent.call(parent, shownEvent, component, relatedTarget);\n        element[open] = true;\n        off(element, clickEvent, clickHandler);\n        setTimeout(function () {\n          setFocus(menu[getElementsByTagName]('INPUT')[0] || element); // focus the first input item | element\n          toggleDismiss();\n        }, 1);\n      },\n      hide = function () {\n        bootstrapCustomEvent.call(parent, hideEvent, component, relatedTarget);\n        removeClass(menu, showClass);\n        removeClass(parent, showClass);\n        element[setAttribute](ariaExpanded, false);\n        bootstrapCustomEvent.call(parent, hiddenEvent, component, relatedTarget);\n        element[open] = false;\n        toggleDismiss();\n        setFocus(element);\n        setTimeout(function () {\n          on(element, clickEvent, clickHandler);\n        }, 1);\n      };\n\n    // set initial state to closed\n    element[open] = false;\n\n    // public methods\n    this.toggle = function () {\n      if (hasClass(parent, showClass) && element[open]) {\n        hide();\n      } else {\n        show();\n      }\n    };\n\n    // init\n    if (!(stringDropdown in element)) { // prevent adding event handlers twice\n      !tabindex in menu && menu[setAttribute](tabindex, '0'); // Fix onblur on Chrome | Safari\n      on(element, clickEvent, clickHandler);\n    }\n\n    element[stringDropdown] = self;\n  };\n\n  // DROPDOWN DATA API\n  // =================\n  supports[push]([stringDropdown, Dropdown, '[' + dataToggle + '=\"dropdown\"]']);\n\n\n  /* Native Javascript for Bootstrap 4 | Modal\n  -------------------------------------------*/\n\n  // MODAL DEFINITION\n  // ===============\n  var Modal = function (element, options) { // element can be the modal/triggering button\n\n    // the modal (both JavaScript / DATA API init) / triggering button element (DATA API)\n    element = queryElement(element);\n\n    // strings\n    var component = 'modal',\n      staticString = 'static',\n      modalTrigger = 'modalTrigger',\n      paddingRight = 'paddingRight',\n      modalBackdropString = 'modal-backdrop',\n      isAnimating = 'isAnimating',\n      // determine modal, triggering element\n      btnCheck = element[getAttribute](dataTarget) || element[getAttribute]('href'),\n      checkModal = queryElement(btnCheck),\n      modal = hasClass(element, component) ? element : checkModal;\n\n    if (hasClass(element, component)) {\n      element = null;\n    } // modal is now independent of it's triggering element\n\n    if (!modal) {\n      return;\n    } // invalidate\n\n    // set options\n    options = options || {};\n\n    this[keyboard] = options[keyboard] === false || modal[getAttribute](dataKeyboard) === 'false' ? false : true;\n    this[backdrop] = options[backdrop] === staticString || modal[getAttribute](databackdrop) === staticString ? staticString : true;\n    this[backdrop] = options[backdrop] === false || modal[getAttribute](databackdrop) === 'false' ? false : this[backdrop];\n    this[animation] = hasClass(modal, 'fade') ? true : false;\n    this[content] = options[content]; // JavaScript only\n\n    // set an initial state of the modal\n    modal[isAnimating] = false;\n\n    // bind, constants, event targets and other vars\n    var self = this,\n      relatedTarget = null,\n      bodyIsOverflowing, scrollBarWidth, overlay, overlayDelay, modalTimer,\n\n      // also find fixed-top / fixed-bottom items\n      fixedItems = getElementsByClassName(HTML, fixedTop).concat(getElementsByClassName(HTML, fixedBottom)),\n\n      // private methods\n      getWindowWidth = function () {\n        var htmlRect = HTML[getBoundingClientRect]();\n        return globalObject[innerWidth] || (htmlRect[right] - Math.abs(htmlRect[left]));\n      },\n      setScrollbar = function () {\n        var bodyStyle = globalObject[getComputedStyle](DOC[body]),\n          bodyPad = parseInt((bodyStyle[paddingRight]), 10),\n          itemPad;\n        if (bodyIsOverflowing) {\n          DOC[body][style][paddingRight] = (bodyPad + scrollBarWidth) + 'px';\n          modal[style][paddingRight] = scrollBarWidth + 'px';\n          if (fixedItems[length]) {\n            for (var i = 0; i < fixedItems[length]; i++) {\n              itemPad = globalObject[getComputedStyle](fixedItems[i])[paddingRight];\n              fixedItems[i][style][paddingRight] = (parseInt(itemPad) + scrollBarWidth) + 'px';\n            }\n          }\n        }\n      },\n      resetScrollbar = function () {\n        DOC[body][style][paddingRight] = '';\n        modal[style][paddingRight] = '';\n        if (fixedItems[length]) {\n          for (var i = 0; i < fixedItems[length]; i++) {\n            fixedItems[i][style][paddingRight] = '';\n          }\n        }\n      },\n      measureScrollbar = function () { // thx walsh\n        var scrollDiv = DOC[createElement]('div'),\n          widthValue;\n        scrollDiv.className = component + '-scrollbar-measure'; // this is here to stay\n        DOC[body][appendChild](scrollDiv);\n        widthValue = scrollDiv[offsetWidth] - scrollDiv[clientWidth];\n        DOC[body].removeChild(scrollDiv);\n        return widthValue;\n      },\n      checkScrollbar = function () {\n        bodyIsOverflowing = DOC[body][clientWidth] < getWindowWidth();\n        scrollBarWidth = measureScrollbar();\n      },\n      createOverlay = function () {\n        var newOverlay = DOC[createElement]('div');\n        overlay = queryElement('.' + modalBackdropString);\n\n        if (overlay === null) {\n          newOverlay[setAttribute]('class', modalBackdropString + (self[animation] ? ' fade' : ''));\n          overlay = newOverlay;\n          DOC[body][appendChild](overlay);\n        }\n        modalOverlay = 1;\n      },\n      removeOverlay = function () {\n        overlay = queryElement('.' + modalBackdropString);\n        if (overlay && overlay !== null && typeof overlay === 'object') {\n          modalOverlay = 0;\n          DOC[body].removeChild(overlay);\n          overlay = null;\n        }\n      },\n      // triggers\n      triggerShow = function () {\n        setFocus(modal);\n        modal[isAnimating] = false;\n        bootstrapCustomEvent.call(modal, shownEvent, component, relatedTarget);\n\n        on(globalObject, resizeEvent, self.update, passiveHandler);\n        on(modal, clickEvent, dismissHandler);\n        on(DOC, keydownEvent, keyHandler);\n      },\n      triggerHide = function () {\n        modal[style].display = '';\n        element && (setFocus(element));\n        bootstrapCustomEvent.call(modal, hiddenEvent, component);\n\n        (function () {\n          if (!getElementsByClassName(DOC, component + ' ' + showClass)[0]) {\n            resetScrollbar();\n            removeClass(DOC[body], component + '-open');\n            overlay && hasClass(overlay, 'fade') ? (removeClass(overlay, showClass), emulateTransitionEnd(overlay, removeOverlay)) :\n              removeOverlay();\n\n            off(globalObject, resizeEvent, self.update, passiveHandler);\n            off(modal, clickEvent, dismissHandler);\n            off(DOC, keydownEvent, keyHandler);\n          }\n        }());\n        modal[isAnimating] = false;\n      },\n      // handlers\n      clickHandler = function (e) {\n        if (modal[isAnimating]) return;\n\n        var clickTarget = e[target];\n        clickTarget = clickTarget[hasAttribute](dataTarget) || clickTarget[hasAttribute]('href') ? clickTarget : clickTarget[parentNode];\n        if (clickTarget === element && !hasClass(modal, showClass)) {\n          modal[modalTrigger] = element;\n          relatedTarget = element;\n          self.show();\n          e[preventDefault]();\n        }\n      },\n      keyHandler = function (e) {\n        if (modal[isAnimating]) return;\n\n        if (self[keyboard] && e.which == 27 && hasClass(modal, showClass)) {\n          self.hide();\n        }\n      },\n      dismissHandler = function (e) {\n        if (modal[isAnimating]) return;\n        var clickTarget = e[target];\n\n        if (hasClass(modal, showClass) && (clickTarget[parentNode][getAttribute](dataDismiss) === component ||\n            clickTarget[getAttribute](dataDismiss) === component ||\n            clickTarget === modal && self[backdrop] !== staticString)) {\n          self.hide();\n          relatedTarget = null;\n          e[preventDefault]();\n        }\n      };\n\n    // public methods\n    this.toggle = function () {\n      if (hasClass(modal, showClass)) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    };\n    this.show = function () {\n      if (hasClass(modal, showClass) || modal[isAnimating]) {\n        return\n      }\n\n      clearTimeout(modalTimer);\n      modalTimer = setTimeout(function () {\n        modal[isAnimating] = true;\n        bootstrapCustomEvent.call(modal, showEvent, component, relatedTarget);\n\n        // we elegantly hide any opened modal\n        var currentOpen = getElementsByClassName(DOC, component + ' ' + showClass)[0];\n        if (currentOpen && currentOpen !== modal) {\n          modalTrigger in currentOpen && currentOpen[modalTrigger][stringModal].hide();\n          stringModal in currentOpen && currentOpen[stringModal].hide();\n        }\n\n        if (self[backdrop]) {\n          !modalOverlay && !overlay && createOverlay();\n        }\n\n        if (overlay && !hasClass(overlay, showClass)) {\n          overlay[offsetWidth]; // force reflow to enable trasition\n          overlayDelay = getTransitionDurationFromElement(overlay);\n          addClass(overlay, showClass);\n        }\n\n        setTimeout(function () {\n          modal[style].display = 'block';\n\n          checkScrollbar();\n          setScrollbar();\n\n          addClass(DOC[body], component + '-open');\n          addClass(modal, showClass);\n          modal[setAttribute](ariaHidden, false);\n\n          hasClass(modal, 'fade') ? emulateTransitionEnd(modal, triggerShow) : triggerShow();\n        }, supportTransitions && overlay && overlayDelay ? overlayDelay : 1);\n      }, 1);\n    };\n    this.hide = function () {\n      if (modal[isAnimating] || !hasClass(modal, showClass)) {\n        return\n      }\n\n      clearTimeout(modalTimer);\n      modalTimer = setTimeout(function () {\n        modal[isAnimating] = true;\n        bootstrapCustomEvent.call(modal, hideEvent, component);\n        overlay = queryElement('.' + modalBackdropString);\n        overlayDelay = overlay && getTransitionDurationFromElement(overlay);\n\n        removeClass(modal, showClass);\n        modal[setAttribute](ariaHidden, true);\n\n        setTimeout(function () {\n          hasClass(modal, 'fade') ? emulateTransitionEnd(modal, triggerHide) : triggerHide();\n        }, supportTransitions && overlay && overlayDelay ? overlayDelay : 2);\n      }, 2)\n    };\n    this.setContent = function (content) {\n      queryElement('.' + component + '-content', modal)[innerHTML] = content;\n    };\n    this.update = function () {\n      if (hasClass(modal, showClass)) {\n        checkScrollbar();\n        setScrollbar();\n      }\n    };\n\n    // init\n    // prevent adding event handlers over and over\n    // modal is independent of a triggering element\n    if (!!element && !(stringModal in element)) {\n      on(element, clickEvent, clickHandler);\n    }\n    if (!!self[content]) {\n      self.setContent(self[content]);\n    }\n    if (element) {\n      element[stringModal] = self;\n      modal[modalTrigger] = element;\n    } else {\n      modal[stringModal] = self;\n    }\n  };\n\n  // DATA API\n  supports[push]([stringModal, Modal, '[' + dataToggle + '=\"modal\"]']);\n\n  /* Native Javascript for Bootstrap 4 | Popover\n  ----------------------------------------------*/\n\n  // POPOVER DEFINITION\n  // ==================\n  var Popover = function (element, options) {\n\n    // initialization element\n    element = queryElement(element);\n\n    // set options\n    options = options || {};\n\n    // DATA API\n    var triggerData = element[getAttribute](dataTrigger), // click / hover / focus\n      animationData = element[getAttribute](dataAnimation), // true / false\n      placementData = element[getAttribute](dataPlacement),\n      dismissibleData = element[getAttribute](dataDismissible),\n      delayData = element[getAttribute](dataDelay),\n      containerData = element[getAttribute](dataContainer),\n\n      // internal strings\n      component = 'popover',\n      template = 'template',\n      trigger = 'trigger',\n      classString = 'class',\n      div = 'div',\n      fade = 'fade',\n      dataContent = 'data-content',\n      dismissible = 'dismissible',\n      closeBtn = '<button type=\"button\" class=\"close\">Ã</button>',\n\n      // check container\n      containerElement = queryElement(options[container]),\n      containerDataElement = queryElement(containerData),\n\n      // maybe the element is inside a modal\n      modal = getClosest(element, '.modal'),\n\n      // maybe the element is inside a fixed navbar\n      navbarFixedTop = getClosest(element, '.' + fixedTop),\n      navbarFixedBottom = getClosest(element, '.' + fixedBottom);\n\n    // set instance options\n    this[template] = options[template] ? options[template] : null; // JavaScript only\n    this[trigger] = options[trigger] ? options[trigger] : triggerData || hoverEvent;\n    this[animation] = options[animation] && options[animation] !== fade ? options[animation] : animationData || fade;\n    this[placement] = options[placement] ? options[placement] : placementData || top;\n    this[delay] = parseInt(options[delay] || delayData) || 200;\n    this[dismissible] = options[dismissible] || dismissibleData === 'true' ? true : false;\n    this[container] = containerElement ? containerElement :\n      containerDataElement ? containerDataElement :\n      navbarFixedTop ? navbarFixedTop :\n      navbarFixedBottom ? navbarFixedBottom :\n      modal ? modal : DOC[body];\n\n    // bind, content\n    var self = this,\n      titleString = options.title || element[getAttribute](dataTitle) || null,\n      contentString = options.content || element[getAttribute](dataContent) || null;\n\n    if (!contentString && !this[template]) return; // invalidate\n\n    // constants, vars\n    var popover = null,\n      timer = 0,\n      placementSetting = this[placement],\n\n      // handlers\n      dismissibleHandler = function (e) {\n        if (popover !== null && e[target] === queryElement('.close', popover)) {\n          self.hide();\n        }\n      },\n\n      // private methods\n      removePopover = function () {\n        self[container].removeChild(popover);\n        timer = null;\n        popover = null;\n      },\n      createPopover = function () {\n        titleString = options.title || element[getAttribute](dataTitle);\n        contentString = options.content || element[getAttribute](dataContent);\n        // fixing https://github.com/thednp/bootstrap.native/issues/233\n        contentString = !!contentString ? contentString.trim() : null;\n\n        popover = DOC[createElement](div);\n\n        // popover arrow\n        var popoverArrow = DOC[createElement](div);\n        popoverArrow[setAttribute](classString, 'arrow');\n        popover[appendChild](popoverArrow);\n\n        if (contentString !== null && self[template] === null) { //create the popover from data attributes\n\n          popover[setAttribute]('role', 'tooltip');\n\n          if (titleString !== null) {\n            var popoverTitle = DOC[createElement]('h3');\n            popoverTitle[setAttribute](classString, component + '-header');\n\n            popoverTitle[innerHTML] = self[dismissible] ? titleString + closeBtn : titleString;\n            popover[appendChild](popoverTitle);\n          }\n\n          //set popover content\n          var popoverContent = DOC[createElement](div);\n          popoverContent[setAttribute](classString, component + '-body');\n          popoverContent[innerHTML] = self[dismissible] && titleString === null ? contentString + closeBtn : contentString;\n          popover[appendChild](popoverContent);\n\n        } else { // or create the popover from template\n          var popoverTemplate = DOC[createElement](div);\n          self[template] = self[template].trim();\n          popoverTemplate[innerHTML] = self[template];\n          popover[innerHTML] = popoverTemplate.firstChild[innerHTML];\n        }\n\n        //append to the container\n        self[container][appendChild](popover);\n        popover[style].display = 'block';\n        popover[setAttribute](classString, component + ' bs-' + component + '-' + placementSetting + ' ' + self[animation]);\n      },\n      showPopover = function () {\n        !hasClass(popover, showClass) && (addClass(popover, showClass));\n      },\n      updatePopover = function () {\n        styleTip(element, popover, placementSetting, self[container]);\n      },\n\n      // event toggle\n      dismissHandlerToggle = function (type) {\n        if (clickEvent == self[trigger] || 'focus' == self[trigger]) {\n          !self[dismissible] && type(element, 'blur', self.hide);\n        }\n        self[dismissible] && type(DOC, clickEvent, dismissibleHandler);\n        type(globalObject, resizeEvent, self.hide, passiveHandler);\n      },\n\n      // triggers\n      showTrigger = function () {\n        dismissHandlerToggle(on);\n        bootstrapCustomEvent.call(element, shownEvent, component);\n      },\n      hideTrigger = function () {\n        dismissHandlerToggle(off);\n        removePopover();\n        bootstrapCustomEvent.call(element, hiddenEvent, component);\n      };\n\n    // public methods / handlers\n    this.toggle = function () {\n      if (popover === null) {\n        self.show();\n      } else {\n        self.hide();\n      }\n    };\n    this.show = function () {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        if (popover === null) {\n          placementSetting = self[placement]; // we reset placement in all cases\n          createPopover();\n          updatePopover();\n          showPopover();\n          bootstrapCustomEvent.call(element, showEvent, component);\n          !!self[animation] ? emulateTransitionEnd(popover, showTrigger) : showTrigger();\n        }\n      }, 20);\n    };\n    this.hide = function () {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        if (popover && popover !== null && hasClass(popover, showClass)) {\n          bootstrapCustomEvent.call(element, hideEvent, component);\n          removeClass(popover, showClass);\n          !!self[animation] ? emulateTransitionEnd(popover, hideTrigger) : hideTrigger();\n        }\n      }, self[delay]);\n    };\n\n    // init\n    if (!(stringPopover in element)) { // prevent adding event handlers twice\n      if (self[trigger] === hoverEvent) {\n        on(element, mouseHover[0], self.show);\n        if (!self[dismissible]) {\n          on(element, mouseHover[1], self.hide);\n        }\n      } else if (clickEvent == self[trigger] || 'focus' == self[trigger]) {\n        on(element, self[trigger], self.toggle);\n      }\n    }\n    element[stringPopover] = self;\n  };\n\n  // POPOVER DATA API\n  // ================\n  supports[push]([stringPopover, Popover, '[' + dataToggle + '=\"popover\"]']);\n\n\n  /* Native Javascript for Bootstrap 4 | ScrollSpy\n  -----------------------------------------------*/\n\n  // SCROLLSPY DEFINITION\n  // ====================\n  var ScrollSpy = function (element, options) {\n\n    // initialization element, the element we spy on\n    element = queryElement(element);\n\n    // DATA API\n    var targetData = queryElement(element[getAttribute](dataTarget)),\n      offsetData = element[getAttribute]('data-offset');\n\n    // set options\n    options = options || {};\n\n    // invalidate\n    if (!options[target] && !targetData) {\n      return;\n    }\n\n    // event targets, constants\n    var self = this,\n      spyTarget = options[target] && queryElement(options[target]) || targetData,\n      links = spyTarget && spyTarget[getElementsByTagName]('A'),\n      offset = parseInt(options['offset'] || offsetData) || 10,\n      items = [],\n      targetItems = [],\n      scrollOffset,\n      scrollTarget = element[offsetHeight] < element[scrollHeight] ? element : globalObject, // determine which is the real scrollTarget\n      isWindow = scrollTarget === globalObject;\n\n    // populate items and targets\n    for (var i = 0, il = links[length]; i < il; i++) {\n      var href = links[i][getAttribute]('href'),\n        targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#' && queryElement(href);\n      if (!!targetItem) {\n        items[push](links[i]);\n        targetItems[push](targetItem);\n      }\n    }\n\n    // private methods\n    var updateItem = function (index) {\n        var item = items[index],\n          targetItem = targetItems[index], // the menu item targets this element\n          dropdown = item[parentNode][parentNode],\n          dropdownLink = hasClass(dropdown, 'dropdown') && dropdown[getElementsByTagName]('A')[0],\n          targetRect = isWindow && targetItem[getBoundingClientRect](),\n\n          isActive = hasClass(item, active) || false,\n\n          topEdge = (isWindow ? targetRect[top] + scrollOffset : targetItem[offsetTop]) - offset,\n          bottomEdge = isWindow ? targetRect[bottom] + scrollOffset - offset : targetItems[index + 1] ? targetItems[index + 1][offsetTop] - offset : element[scrollHeight],\n\n          inside = scrollOffset >= topEdge && bottomEdge > scrollOffset;\n\n        if (!isActive && inside) {\n          if (!hasClass(item, active)) {\n            addClass(item, active);\n            if (dropdownLink && !hasClass(dropdownLink, active)) {\n              addClass(dropdownLink, active);\n            }\n            bootstrapCustomEvent.call(element, 'activate', 'scrollspy', items[index]);\n          }\n        } else if (!inside) {\n          if (hasClass(item, active)) {\n            removeClass(item, active);\n            if (dropdownLink && hasClass(dropdownLink, active) && !getElementsByClassName(item[parentNode], active).length) {\n              removeClass(dropdownLink, active);\n            }\n          }\n        } else if (!inside && !isActive || isActive && inside) {\n          return;\n        }\n      },\n      updateItems = function () {\n        scrollOffset = isWindow ? getScroll().y : element[scrollTop];\n        for (var index = 0, itl = items[length]; index < itl; index++) {\n          updateItem(index)\n        }\n      };\n\n    // public method\n    this.refresh = function () {\n      updateItems();\n    }\n\n    // init\n    if (!(stringScrollSpy in element)) { // prevent adding event handlers twice\n      on(scrollTarget, scrollEvent, self.refresh, passiveHandler);\n      on(globalObject, resizeEvent, self.refresh, passiveHandler);\n    }\n    self.refresh();\n    element[stringScrollSpy] = self;\n  };\n\n  // SCROLLSPY DATA API\n  // ==================\n  supports[push]([stringScrollSpy, ScrollSpy, '[' + dataSpy + '=\"scroll\"]']);\n\n\n  /* Native Javascript for Bootstrap 4 | Tab\n  -----------------------------------------*/\n\n  // TAB DEFINITION\n  // ==============\n  var Tab = function (element, options) {\n\n    // initialization element\n    element = queryElement(element);\n\n    // DATA API\n    var heightData = element[getAttribute](dataHeight),\n\n      // strings\n      component = 'tab',\n      height = 'height',\n      float = 'float',\n      isAnimating = 'isAnimating';\n\n    // set options\n    options = options || {};\n    this[height] = supportTransitions ? (options[height] || heightData === 'true') : false;\n\n    // bind, event targets\n    var self = this,\n      next,\n      tabs = getClosest(element, '.nav'),\n      tabsContentContainer = false,\n      dropdown = tabs && queryElement('.dropdown-toggle', tabs),\n      activeTab, activeContent, nextContent, containerHeight, equalContents, nextHeight,\n\n      // trigger\n      triggerEnd = function () {\n        tabsContentContainer[style][height] = '';\n        removeClass(tabsContentContainer, collapsing);\n        tabs[isAnimating] = false;\n      },\n      triggerShow = function () {\n        if (tabsContentContainer) { // height animation\n          if (equalContents) {\n            triggerEnd();\n          } else {\n            setTimeout(function () { // enables height animation\n              tabsContentContainer[style][height] = nextHeight + 'px'; // height animation\n              tabsContentContainer[offsetWidth];\n              emulateTransitionEnd(tabsContentContainer, triggerEnd);\n            }, 50);\n          }\n        } else {\n          tabs[isAnimating] = false;\n        }\n        bootstrapCustomEvent.call(next, shownEvent, component, activeTab);\n      },\n      triggerHide = function () {\n        if (tabsContentContainer) {\n          activeContent[style][float] = left;\n          nextContent[style][float] = left;\n          containerHeight = activeContent[scrollHeight];\n        }\n\n        addClass(nextContent, active);\n        bootstrapCustomEvent.call(next, showEvent, component, activeTab);\n\n        removeClass(activeContent, active);\n        bootstrapCustomEvent.call(activeTab, hiddenEvent, component, next);\n\n        if (tabsContentContainer) {\n          nextHeight = nextContent[scrollHeight];\n          equalContents = nextHeight === containerHeight;\n          addClass(tabsContentContainer, collapsing);\n          tabsContentContainer[style][height] = containerHeight + 'px'; // height animation\n          tabsContentContainer[offsetHeight];\n          activeContent[style][float] = '';\n          nextContent[style][float] = '';\n        }\n\n        if (hasClass(nextContent, 'fade')) {\n          setTimeout(function () {\n            addClass(nextContent, showClass);\n            emulateTransitionEnd(nextContent, triggerShow);\n          }, 20);\n        } else {\n          triggerShow();\n        }\n      };\n\n    if (!tabs) return; // invalidate\n\n    // set default animation state\n    tabs[isAnimating] = false;\n\n    // private methods\n    var getActiveTab = function () {\n        var activeTabs = getElementsByClassName(tabs, active),\n          activeTab;\n        if (activeTabs[length] === 1 && !hasClass(activeTabs[0][parentNode], 'dropdown')) {\n          activeTab = activeTabs[0];\n        } else if (activeTabs[length] > 1) {\n          activeTab = activeTabs[activeTabs[length] - 1];\n        }\n        return activeTab;\n      },\n      getActiveContent = function () {\n        return queryElement(getActiveTab()[getAttribute]('href'));\n      },\n      // handler \n      clickHandler = function (e) {\n        e[preventDefault]();\n        next = e[currentTarget];\n        !tabs[isAnimating] && !hasClass(next, active) && self.show();\n      };\n\n    // public method\n    this.show = function () { // the tab we clicked is now the next tab\n      next = next || element;\n      nextContent = queryElement(next[getAttribute]('href')); //this is the actual object, the next tab content to activate\n      activeTab = getActiveTab();\n      activeContent = getActiveContent();\n\n      tabs[isAnimating] = true;\n      removeClass(activeTab, active);\n      activeTab[setAttribute](ariaSelected, 'false');\n      addClass(next, active);\n      next[setAttribute](ariaSelected, 'true');\n\n      if (dropdown) {\n        if (!hasClass(element[parentNode], 'dropdown-menu')) {\n          if (hasClass(dropdown, active)) removeClass(dropdown, active);\n        } else {\n          if (!hasClass(dropdown, active)) addClass(dropdown, active);\n        }\n      }\n\n      bootstrapCustomEvent.call(activeTab, hideEvent, component, next);\n\n      if (hasClass(activeContent, 'fade')) {\n        removeClass(activeContent, showClass);\n        emulateTransitionEnd(activeContent, triggerHide);\n      } else {\n        triggerHide();\n      }\n    };\n\n    // init\n    if (!(stringTab in element)) { // prevent adding event handlers twice\n      on(element, clickEvent, clickHandler);\n    }\n    if (self[height]) {\n      tabsContentContainer = getActiveContent()[parentNode];\n    }\n    element[stringTab] = self;\n  };\n\n  // TAB DATA API\n  // ============\n  supports[push]([stringTab, Tab, '[' + dataToggle + '=\"tab\"]']);\n\n\n  /* Native Javascript for Bootstrap 4 | Toast\n  ---------------------------------------------*/\n\n  // TOAST DEFINITION\n  // ==================\n  var Toast = function (element, options) {\n\n    // initialization element\n    element = queryElement(element);\n\n    // set options\n    options = options || {};\n\n    // DATA API\n    var animationData = element[getAttribute](dataAnimation),\n      autohideData = element[getAttribute](dataAutohide),\n      delayData = element[getAttribute](dataDelay),\n\n      // strings\n      component = 'toast',\n      autohide = 'autohide',\n      animation = 'animation',\n      showing = 'showing',\n      hide = 'hide',\n      fade = 'fade';\n\n    // set instance options\n    this[animation] = options[animation] === false || animationData === 'false' ? 0 : 1; // true by default\n    this[autohide] = options[autohide] === false || autohideData === 'false' ? 0 : 1; // true by default\n    this[delay] = parseInt(options[delay] || delayData) || 500; // 500ms default\n\n    // bind,toast and timer\n    var self = this,\n      timer = 0,\n      // get the toast element\n      toast = getClosest(element, '.toast');\n\n    // private methods\n    // animation complete\n    var showComplete = function () {\n        removeClass(toast, showing);\n        addClass(toast, showClass);\n        bootstrapCustomEvent.call(toast, shownEvent, component);\n        if (self[autohide]) {\n          self.hide();\n        }\n      },\n      hideComplete = function () {\n        addClass(toast, hide);\n        bootstrapCustomEvent.call(toast, hiddenEvent, component);\n      },\n      close = function () {\n        removeClass(toast, showClass);\n        self[animation] ? emulateTransitionEnd(toast, hideComplete) : hideComplete();\n      },\n      disposeComplete = function () {\n        clearTimeout(timer);\n        timer = null;\n        addClass(toast, hide);\n        off(element, clickEvent, self.hide);\n        element[stringToast] = null;\n        element = null;\n        toast = null;\n      };\n\n    // public methods\n    this.show = function () {\n      if (toast) {\n        bootstrapCustomEvent.call(toast, showEvent, component);\n        self[animation] && addClass(toast, fade);\n        removeClass(toast, hide);\n        addClass(toast, showing);\n\n        self[animation] ? emulateTransitionEnd(toast, showComplete) : showComplete();\n      }\n    };\n    this.hide = function (noTimer) {\n      if (toast && hasClass(toast, showClass)) {\n        bootstrapCustomEvent.call(toast, hideEvent, component);\n\n        if (noTimer) {\n          close();\n        } else {\n          timer = setTimeout(close, self[delay]);\n        }\n      }\n    };\n    this.dispose = function () {\n      if (toast && hasClass(toast, showClass)) {\n        removeClass(toast, showClass);\n        self[animation] ? emulateTransitionEnd(toast, disposeComplete) : disposeComplete();\n      }\n    };\n\n    // init\n    if (!(stringToast in element)) { // prevent adding event handlers twice\n      on(element, clickEvent, self.hide);\n    }\n    element[stringToast] = self;\n  };\n\n  // TOAST DATA API\n  // =================\n  supports[push]([stringToast, Toast, '[' + dataDismiss + '=\"toast\"]']);\n\n\n  /* Native Javascript for Bootstrap 4 | Tooltip\n  ---------------------------------------------*/\n\n  // TOOLTIP DEFINITION\n  // ==================\n  var Tooltip = function (element, options) {\n\n    // initialization element\n    element = queryElement(element);\n\n    // set options\n    options = options || {};\n\n    // DATA API\n    var animationData = element[getAttribute](dataAnimation),\n      placementData = element[getAttribute](dataPlacement),\n      delayData = element[getAttribute](dataDelay),\n      containerData = element[getAttribute](dataContainer),\n\n      // strings\n      component = 'tooltip',\n      classString = 'class',\n      title = 'title',\n      fade = 'fade',\n      div = 'div',\n\n      // check container\n      containerElement = queryElement(options[container]),\n      containerDataElement = queryElement(containerData),\n\n      // maybe the element is inside a modal\n      modal = getClosest(element, '.modal'),\n\n      // maybe the element is inside a fixed navbar\n      navbarFixedTop = getClosest(element, '.' + fixedTop),\n      navbarFixedBottom = getClosest(element, '.' + fixedBottom);\n\n    // set instance options\n    this[animation] = options[animation] && options[animation] !== fade ? options[animation] : animationData || fade;\n    this[placement] = options[placement] ? options[placement] : placementData || top;\n    this[delay] = parseInt(options[delay] || delayData) || 200;\n    this[container] = containerElement ? containerElement :\n      containerDataElement ? containerDataElement :\n      navbarFixedTop ? navbarFixedTop :\n      navbarFixedBottom ? navbarFixedBottom :\n      modal ? modal : DOC[body];\n\n    // bind, event targets, title and constants\n    var self = this,\n      timer = 0,\n      placementSetting = this[placement],\n      tooltip = null,\n      titleString = element[getAttribute](title) || element[getAttribute](dataTitle) || element[getAttribute](dataOriginalTitle);\n\n    if (!titleString || titleString == \"\") return; // invalidate\n\n    // private methods\n    var removeToolTip = function () {\n        self[container].removeChild(tooltip);\n        tooltip = null;\n        timer = null;\n      },\n      createToolTip = function () {\n        titleString = element[getAttribute](title) || element[getAttribute](dataTitle) || element[getAttribute](dataOriginalTitle); // read the title again\n\n        if (titleString && titleString !== \"\") { // invalidate, maybe markup changed\n          tooltip = DOC[createElement](div);\n          tooltip[setAttribute]('role', component);\n          tooltip[style][left] = '0';\n          tooltip[style][top] = '0';\n\n          // tooltip arrow\n          var tooltipArrow = DOC[createElement](div);\n          tooltipArrow[setAttribute](classString, 'arrow');\n          tooltip[appendChild](tooltipArrow);\n\n          var tooltipInner = DOC[createElement](div);\n          tooltipInner[setAttribute](classString, component + '-inner');\n          tooltip[appendChild](tooltipInner);\n          tooltipInner[innerHTML] = titleString;\n\n          self[container][appendChild](tooltip);\n          tooltip[setAttribute](classString, component + ' bs-' + component + '-' + placementSetting + ' ' + self[animation]);\n        }\n      },\n      updateTooltip = function () {\n        styleTip(element, tooltip, placementSetting, self[container]);\n      },\n      showTooltip = function () {\n        !hasClass(tooltip, showClass) && (addClass(tooltip, showClass));\n      },\n      // triggers\n      showTrigger = function () {\n        on(globalObject, resizeEvent, self.hide, passiveHandler);\n        bootstrapCustomEvent.call(element, shownEvent, component);\n      },\n      hideTrigger = function () {\n        off(globalObject, resizeEvent, self.hide, passiveHandler);\n        removeToolTip();\n        bootstrapCustomEvent.call(element, hiddenEvent, component);\n      };\n\n    // public methods\n    this.show = function () {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        if (tooltip === null) {\n          placementSetting = self[placement]; // we reset placement in all cases\n          // if(createToolTip() == false) return;\n          if (createToolTip() !== false) {\n            updateTooltip();\n            showTooltip();\n            bootstrapCustomEvent.call(element, showEvent, component);\n            !!self[animation] ? emulateTransitionEnd(tooltip, showTrigger) : showTrigger();\n          }\n        }\n      }, 20);\n    };\n    this.hide = function () {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        if (tooltip && hasClass(tooltip, showClass)) {\n          bootstrapCustomEvent.call(element, hideEvent, component);\n          removeClass(tooltip, showClass);\n          !!self[animation] ? emulateTransitionEnd(tooltip, hideTrigger) : hideTrigger();\n        }\n      }, self[delay]);\n    };\n    this.toggle = function () {\n      if (!tooltip) {\n        self.show();\n      } else {\n        self.hide();\n      }\n    };\n\n    // init\n    if (!(stringTooltip in element)) { // prevent adding event handlers twice\n      element[setAttribute](dataOriginalTitle, titleString);\n      element.removeAttribute(title);\n      on(element, mouseHover[0], self.show);\n      on(element, mouseHover[1], self.hide);\n    }\n    element[stringTooltip] = self;\n  };\n\n  // TOOLTIP DATA API\n  // =================\n  supports[push]([stringTooltip, Tooltip, '[' + dataToggle + '=\"tooltip\"]']);\n\n\n\n  /* Native Javascript for Bootstrap | Initialize Data API\n  --------------------------------------------------------*/\n  var initializeDataAPI = function (constructor, collection) {\n      for (var i = 0, l = collection[length]; i < l; i++) {\n        new constructor(collection[i]);\n      }\n    },\n    initCallback = BSN.initCallback = function (lookUp) {\n      lookUp = lookUp || DOC;\n      for (var i = 0, l = supports[length]; i < l; i++) {\n        initializeDataAPI(supports[i][1], lookUp[querySelectorAll](supports[i][2]));\n      }\n    };\n\n  // bulk initialize all components\n  DOC[body] ? initCallback() : on(DOC, 'DOMContentLoaded', function () {\n    initCallback();\n  });\n\n  return {\n    Alert: Alert,\n    Button: Button,\n    Carousel: Carousel,\n    Collapse: Collapse,\n    Dropdown: Dropdown,\n    Modal: Modal,\n    Popover: Popover,\n    ScrollSpy: ScrollSpy,\n    Tab: Tab,\n    Toast: Toast,\n    Tooltip: Tooltip\n  };\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLm5hdGl2ZS9kaXN0L2Jvb3RzdHJhcC1uYXRpdmUtdjQuanM/MzE4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sRUFBRSxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQ3ZCLEdBQUcsTUFBTSxZQWlCTjtBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnRUFBZ0U7O0FBRWhFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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QUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC5uYXRpdmUvZGlzdC9ib290c3RyYXAtbmF0aXZlLXY0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHYyLjAuMjcgfCDCqSBkbnBfdGhlbWUgfCBNSVQtTGljZW5zZVxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQgc3VwcG9ydDpcbiAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgLy8gQ29tbW9uSlMtbGlrZTpcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgIHZhciBic24gPSBmYWN0b3J5KCk7XG4gICAgcm9vdC5BbGVydCA9IGJzbi5BbGVydDtcbiAgICByb290LkJ1dHRvbiA9IGJzbi5CdXR0b247XG4gICAgcm9vdC5DYXJvdXNlbCA9IGJzbi5DYXJvdXNlbDtcbiAgICByb290LkNvbGxhcHNlID0gYnNuLkNvbGxhcHNlO1xuICAgIHJvb3QuRHJvcGRvd24gPSBic24uRHJvcGRvd247XG4gICAgcm9vdC5Nb2RhbCA9IGJzbi5Nb2RhbDtcbiAgICByb290LlBvcG92ZXIgPSBic24uUG9wb3ZlcjtcbiAgICByb290LlNjcm9sbFNweSA9IGJzbi5TY3JvbGxTcHk7XG4gICAgcm9vdC5UYWIgPSBic24uVGFiO1xuICAgIHJvb3QuVG9hc3QgPSBic24uVG9hc3Q7XG4gICAgcm9vdC5Ub29sdGlwID0gYnNuLlRvb2x0aXA7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IEludGVybmFsIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvLyBnbG9iYWxzXG4gIHZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHRoaXMgfHwgd2luZG93LFxuICAgIERPQyA9IGRvY3VtZW50LFxuICAgIEhUTUwgPSBET0MuZG9jdW1lbnRFbGVtZW50LFxuICAgIGJvZHkgPSAnYm9keScsIC8vIGFsbG93IHRoZSBsaWJyYXJ5IHRvIGJlIHVzZWQgaW4gPGhlYWQ+XG5cbiAgICAvLyBOYXRpdmUgSmF2YXNjcmlwdCBmb3IgQm9vdHN0cmFwIEdsb2JhbCBPYmplY3RcbiAgICBCU04gPSBnbG9iYWxPYmplY3QuQlNOID0ge30sXG4gICAgc3VwcG9ydHMgPSBCU04uc3VwcG9ydHMgPSBbXSxcblxuICAgIC8vIGZ1bmN0aW9uIHRvZ2dsZSBhdHRyaWJ1dGVzXG4gICAgZGF0YVRvZ2dsZSA9ICdkYXRhLXRvZ2dsZScsXG4gICAgZGF0YURpc21pc3MgPSAnZGF0YS1kaXNtaXNzJyxcbiAgICBkYXRhU3B5ID0gJ2RhdGEtc3B5JyxcbiAgICBkYXRhUmlkZSA9ICdkYXRhLXJpZGUnLFxuXG4gICAgLy8gY29tcG9uZW50c1xuICAgIHN0cmluZ0FsZXJ0ID0gJ0FsZXJ0JyxcbiAgICBzdHJpbmdCdXR0b24gPSAnQnV0dG9uJyxcbiAgICBzdHJpbmdDYXJvdXNlbCA9ICdDYXJvdXNlbCcsXG4gICAgc3RyaW5nQ29sbGFwc2UgPSAnQ29sbGFwc2UnLFxuICAgIHN0cmluZ0Ryb3Bkb3duID0gJ0Ryb3Bkb3duJyxcbiAgICBzdHJpbmdNb2RhbCA9ICdNb2RhbCcsXG4gICAgc3RyaW5nUG9wb3ZlciA9ICdQb3BvdmVyJyxcbiAgICBzdHJpbmdTY3JvbGxTcHkgPSAnU2Nyb2xsU3B5JyxcbiAgICBzdHJpbmdUYWIgPSAnVGFiJyxcbiAgICBzdHJpbmdUb29sdGlwID0gJ1Rvb2x0aXAnLFxuICAgIHN0cmluZ1RvYXN0ID0gJ1RvYXN0JyxcblxuICAgIC8vIG9wdGlvbnMgREFUQSBBUElcbiAgICBkYXRhQXV0b2hpZGUgPSAnZGF0YS1hdXRvaGlkZScsXG4gICAgZGF0YWJhY2tkcm9wID0gJ2RhdGEtYmFja2Ryb3AnLFxuICAgIGRhdGFLZXlib2FyZCA9ICdkYXRhLWtleWJvYXJkJyxcbiAgICBkYXRhVGFyZ2V0ID0gJ2RhdGEtdGFyZ2V0JyxcbiAgICBkYXRhSW50ZXJ2YWwgPSAnZGF0YS1pbnRlcnZhbCcsXG4gICAgZGF0YUhlaWdodCA9ICdkYXRhLWhlaWdodCcsXG4gICAgZGF0YVBhdXNlID0gJ2RhdGEtcGF1c2UnLFxuICAgIGRhdGFUaXRsZSA9ICdkYXRhLXRpdGxlJyxcbiAgICBkYXRhT3JpZ2luYWxUaXRsZSA9ICdkYXRhLW9yaWdpbmFsLXRpdGxlJyxcbiAgICBkYXRhRGlzbWlzc2libGUgPSAnZGF0YS1kaXNtaXNzaWJsZScsXG4gICAgZGF0YVRyaWdnZXIgPSAnZGF0YS10cmlnZ2VyJyxcbiAgICBkYXRhQW5pbWF0aW9uID0gJ2RhdGEtYW5pbWF0aW9uJyxcbiAgICBkYXRhQ29udGFpbmVyID0gJ2RhdGEtY29udGFpbmVyJyxcbiAgICBkYXRhUGxhY2VtZW50ID0gJ2RhdGEtcGxhY2VtZW50JyxcbiAgICBkYXRhRGVsYXkgPSAnZGF0YS1kZWxheScsXG5cbiAgICAvLyBvcHRpb24ga2V5c1xuICAgIGJhY2tkcm9wID0gJ2JhY2tkcm9wJyxcbiAgICBrZXlib2FyZCA9ICdrZXlib2FyZCcsXG4gICAgZGVsYXkgPSAnZGVsYXknLFxuICAgIGNvbnRlbnQgPSAnY29udGVudCcsXG4gICAgdGFyZ2V0ID0gJ3RhcmdldCcsXG4gICAgY3VycmVudFRhcmdldCA9ICdjdXJyZW50VGFyZ2V0JyxcbiAgICBpbnRlcnZhbCA9ICdpbnRlcnZhbCcsXG4gICAgcGF1c2UgPSAncGF1c2UnLFxuICAgIGFuaW1hdGlvbiA9ICdhbmltYXRpb24nLFxuICAgIHBsYWNlbWVudCA9ICdwbGFjZW1lbnQnLFxuICAgIGNvbnRhaW5lciA9ICdjb250YWluZXInLFxuXG4gICAgLy8gYm94IG1vZGVsXG4gICAgb2Zmc2V0VG9wID0gJ29mZnNldFRvcCcsXG4gICAgb2Zmc2V0Qm90dG9tID0gJ29mZnNldEJvdHRvbScsXG4gICAgb2Zmc2V0TGVmdCA9ICdvZmZzZXRMZWZ0JyxcbiAgICBzY3JvbGxUb3AgPSAnc2Nyb2xsVG9wJyxcbiAgICBzY3JvbGxMZWZ0ID0gJ3Njcm9sbExlZnQnLFxuICAgIGNsaWVudFdpZHRoID0gJ2NsaWVudFdpZHRoJyxcbiAgICBjbGllbnRIZWlnaHQgPSAnY2xpZW50SGVpZ2h0JyxcbiAgICBvZmZzZXRXaWR0aCA9ICdvZmZzZXRXaWR0aCcsXG4gICAgb2Zmc2V0SGVpZ2h0ID0gJ29mZnNldEhlaWdodCcsXG4gICAgaW5uZXJXaWR0aCA9ICdpbm5lcldpZHRoJyxcbiAgICBpbm5lckhlaWdodCA9ICdpbm5lckhlaWdodCcsXG4gICAgc2Nyb2xsSGVpZ2h0ID0gJ3Njcm9sbEhlaWdodCcsXG4gICAgc2Nyb2xsV2lkdGggPSAnc2Nyb2xsV2lkdGgnLFxuICAgIGhlaWdodCA9ICdoZWlnaHQnLFxuXG4gICAgLy8gYXJpYVxuICAgIGFyaWFFeHBhbmRlZCA9ICdhcmlhLWV4cGFuZGVkJyxcbiAgICBhcmlhSGlkZGVuID0gJ2FyaWEtaGlkZGVuJyxcbiAgICBhcmlhU2VsZWN0ZWQgPSAnYXJpYS1zZWxlY3RlZCcsXG5cbiAgICAvLyBldmVudCBuYW1lc1xuICAgIGNsaWNrRXZlbnQgPSAnY2xpY2snLFxuICAgIGZvY3VzRXZlbnQgPSAnZm9jdXMnLFxuICAgIGhvdmVyRXZlbnQgPSAnaG92ZXInLFxuICAgIGtleWRvd25FdmVudCA9ICdrZXlkb3duJyxcbiAgICBrZXl1cEV2ZW50ID0gJ2tleXVwJyxcbiAgICByZXNpemVFdmVudCA9ICdyZXNpemUnLCAvLyBwYXNzaXZlXG4gICAgc2Nyb2xsRXZlbnQgPSAnc2Nyb2xsJywgLy8gcGFzc2l2ZVxuICAgIG1vdXNlSG92ZXIgPSAoJ29ubW91c2VsZWF2ZScgaW4gRE9DKSA/IFsnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJ10gOiBbJ21vdXNlb3ZlcicsICdtb3VzZW91dCddLFxuICAgIC8vIHRvdWNoIHNpbmNlIDIuMC4yNlxuICAgIHRvdWNoRXZlbnRzID0ge1xuICAgICAgc3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgICAgIGVuZDogJ3RvdWNoZW5kJyxcbiAgICAgIG1vdmU6ICd0b3VjaG1vdmUnXG4gICAgfSwgLy8gcGFzc2l2ZVxuICAgIC8vIG9yaWdpbmFsRXZlbnRzXG4gICAgc2hvd0V2ZW50ID0gJ3Nob3cnLFxuICAgIHNob3duRXZlbnQgPSAnc2hvd24nLFxuICAgIGhpZGVFdmVudCA9ICdoaWRlJyxcbiAgICBoaWRkZW5FdmVudCA9ICdoaWRkZW4nLFxuICAgIGNsb3NlRXZlbnQgPSAnY2xvc2UnLFxuICAgIGNsb3NlZEV2ZW50ID0gJ2Nsb3NlZCcsXG4gICAgc2xpZEV2ZW50ID0gJ3NsaWQnLFxuICAgIHNsaWRlRXZlbnQgPSAnc2xpZGUnLFxuICAgIGNoYW5nZUV2ZW50ID0gJ2NoYW5nZScsXG5cbiAgICAvLyBvdGhlclxuICAgIGdldEF0dHJpYnV0ZSA9ICdnZXRBdHRyaWJ1dGUnLFxuICAgIHNldEF0dHJpYnV0ZSA9ICdzZXRBdHRyaWJ1dGUnLFxuICAgIGhhc0F0dHJpYnV0ZSA9ICdoYXNBdHRyaWJ1dGUnLFxuICAgIGNyZWF0ZUVsZW1lbnQgPSAnY3JlYXRlRWxlbWVudCcsXG4gICAgYXBwZW5kQ2hpbGQgPSAnYXBwZW5kQ2hpbGQnLFxuICAgIGlubmVySFRNTCA9ICdpbm5lckhUTUwnLFxuICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lID0gJ2dldEVsZW1lbnRzQnlUYWdOYW1lJyxcbiAgICBwcmV2ZW50RGVmYXVsdCA9ICdwcmV2ZW50RGVmYXVsdCcsXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCcsXG4gICAgcXVlcnlTZWxlY3RvckFsbCA9ICdxdWVyeVNlbGVjdG9yQWxsJyxcbiAgICBnZXRFbGVtZW50c0J5Q0xBU1NOQU1FID0gJ2dldEVsZW1lbnRzQnlDbGFzc05hbWUnLFxuICAgIGdldENvbXB1dGVkU3R5bGUgPSAnZ2V0Q29tcHV0ZWRTdHlsZScsXG5cbiAgICBpbmRleE9mID0gJ2luZGV4T2YnLFxuICAgIHBhcmVudE5vZGUgPSAncGFyZW50Tm9kZScsXG4gICAgbGVuZ3RoID0gJ2xlbmd0aCcsXG4gICAgdG9Mb3dlckNhc2UgPSAndG9Mb3dlckNhc2UnLFxuICAgIFRyYW5zaXRpb24gPSAnVHJhbnNpdGlvbicsXG4gICAgRHVyYXRpb24gPSAnRHVyYXRpb24nLFxuICAgIFdlYmtpdCA9ICdXZWJraXQnLFxuICAgIHN0eWxlID0gJ3N0eWxlJyxcbiAgICBwdXNoID0gJ3B1c2gnLFxuICAgIHRhYmluZGV4ID0gJ3RhYmluZGV4JyxcbiAgICBjb250YWlucyA9ICdjb250YWlucycsXG5cbiAgICBhY3RpdmUgPSAnYWN0aXZlJyxcbiAgICBzaG93Q2xhc3MgPSAnc2hvdycsXG4gICAgY29sbGFwc2luZyA9ICdjb2xsYXBzaW5nJyxcbiAgICBkaXNhYmxlZCA9ICdkaXNhYmxlZCcsXG4gICAgbG9hZGluZyA9ICdsb2FkaW5nJyxcbiAgICBsZWZ0ID0gJ2xlZnQnLFxuICAgIHJpZ2h0ID0gJ3JpZ2h0JyxcbiAgICB0b3AgPSAndG9wJyxcbiAgICBib3R0b20gPSAnYm90dG9tJyxcblxuICAgIC8vIHRvb2x0aXAgLyBwb3BvdmVyXG4gICAgdGlwUG9zaXRpb25zID0gL1xcYih0b3B8Ym90dG9tfGxlZnR8cmlnaHQpKy8sXG5cbiAgICAvLyBtb2RhbFxuICAgIG1vZGFsT3ZlcmxheSA9IDAsXG4gICAgZml4ZWRUb3AgPSAnZml4ZWQtdG9wJyxcbiAgICBmaXhlZEJvdHRvbSA9ICdmaXhlZC1ib3R0b20nLFxuXG4gICAgLy8gdHJhbnNpdGlvbkVuZCBzaW5jZSAyLjAuNFxuICAgIHN1cHBvcnRUcmFuc2l0aW9ucyA9IFdlYmtpdCArIFRyYW5zaXRpb24gaW4gSFRNTFtzdHlsZV0gfHwgVHJhbnNpdGlvblt0b0xvd2VyQ2FzZV0oKSBpbiBIVE1MW3N0eWxlXSxcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSBXZWJraXQgKyBUcmFuc2l0aW9uIGluIEhUTUxbc3R5bGVdID8gV2Via2l0W3RvTG93ZXJDYXNlXSgpICsgVHJhbnNpdGlvbiArICdFbmQnIDogVHJhbnNpdGlvblt0b0xvd2VyQ2FzZV0oKSArICdlbmQnLFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IFdlYmtpdCArIER1cmF0aW9uIGluIEhUTUxbc3R5bGVdID8gV2Via2l0W3RvTG93ZXJDYXNlXSgpICsgVHJhbnNpdGlvbiArIER1cmF0aW9uIDogVHJhbnNpdGlvblt0b0xvd2VyQ2FzZV0oKSArIER1cmF0aW9uLFxuXG4gICAgLy8gc2V0IG5ldyBmb2N1cyBlbGVtZW50IHNpbmNlIDIuMC4zXG4gICAgc2V0Rm9jdXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5mb2N1cyA/IGVsZW1lbnQuZm9jdXMoKSA6IGVsZW1lbnQuc2V0QWN0aXZlKCk7XG4gICAgfSxcblxuICAgIC8vIGNsYXNzIG1hbmlwdWxhdGlvbiwgc2luY2UgMi4wLjAgcmVxdWlyZXMgcG9seWZpbGwuanNcbiAgICBhZGRDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05BTUUpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05BTUUpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOQU1FKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOQU1FKTtcbiAgICB9LFxuICAgIGhhc0NsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTkFNRSkgeyAvLyBzaW5jZSAyLjAuMFxuICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0W2NvbnRhaW5zXShjbGFzc05BTUUpO1xuICAgIH0sXG5cbiAgICAvLyBzZWxlY3Rpb24gbWV0aG9kc1xuICAgIGdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOQU1FKSB7IC8vIHJldHVybnMgQXJyYXlcbiAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGVsZW1lbnRbZ2V0RWxlbWVudHNCeUNMQVNTTkFNRV0oY2xhc3NOQU1FKSk7XG4gICAgfSxcbiAgICBxdWVyeUVsZW1lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHBhcmVudCkge1xuICAgICAgdmFyIGxvb2tVcCA9IHBhcmVudCA/IHBhcmVudCA6IERPQztcbiAgICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdvYmplY3QnID8gc2VsZWN0b3IgOiBsb29rVXAucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgfSxcbiAgICBnZXRDbG9zZXN0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHNlbGVjdG9yKSB7IC8vZWxlbWVudCBpcyB0aGUgZWxlbWVudCBhbmQgc2VsZWN0b3IgaXMgZm9yIHRoZSBjbG9zZXN0IHBhcmVudCBlbGVtZW50IHRvIGZpbmRcbiAgICAgIC8vIHNvdXJjZSBodHRwOi8vZ29tYWtldGhpbmdzLmNvbS9jbGltYmluZy11cC1hbmQtZG93bi10aGUtZG9tLXRyZWUtd2l0aC12YW5pbGxhLWphdmFzY3JpcHQvXG4gICAgICB2YXIgZmlyc3RDaGFyID0gc2VsZWN0b3IuY2hhckF0KDApLFxuICAgICAgICBzZWxlY3RvclN1YnN0cmluZyA9IHNlbGVjdG9yLnN1YnN0cigxKTtcbiAgICAgIGlmIChmaXJzdENoYXIgPT09ICcuJykgeyAvLyBJZiBzZWxlY3RvciBpcyBhIGNsYXNzXG4gICAgICAgIGZvciAoOyBlbGVtZW50ICYmIGVsZW1lbnQgIT09IERPQzsgZWxlbWVudCA9IGVsZW1lbnRbcGFyZW50Tm9kZV0pIHsgLy8gR2V0IGNsb3Nlc3QgbWF0Y2hcbiAgICAgICAgICBpZiAocXVlcnlFbGVtZW50KHNlbGVjdG9yLCBlbGVtZW50W3BhcmVudE5vZGVdKSAhPT0gbnVsbCAmJiBoYXNDbGFzcyhlbGVtZW50LCBzZWxlY3RvclN1YnN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmaXJzdENoYXIgPT09ICcjJykgeyAvLyBJZiBzZWxlY3RvciBpcyBhbiBJRFxuICAgICAgICBmb3IgKDsgZWxlbWVudCAmJiBlbGVtZW50ICE9PSBET0M7IGVsZW1lbnQgPSBlbGVtZW50W3BhcmVudE5vZGVdKSB7IC8vIEdldCBjbG9zZXN0IG1hdGNoXG4gICAgICAgICAgaWYgKGVsZW1lbnQuaWQgPT09IHNlbGVjdG9yU3Vic3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gZXZlbnQgYXR0YWNoIGpRdWVyeSBzdHlsZSAvIHRyaWdnZXIgIHNpbmNlIDEuMi4wXG4gICAgb24gPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IGZhbHNlO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIG9mZiA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZmFsc2U7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgb25lID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7IC8vIG9uZSBzaW5jZSAyLjAuNFxuICAgICAgb24oZWxlbWVudCwgZXZlbnQsIGZ1bmN0aW9uIGhhbmRsZXJXcmFwcGVyKGUpIHtcbiAgICAgICAgaGFuZGxlcihlKTtcbiAgICAgICAgb2ZmKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyV3JhcHBlciwgb3B0aW9ucyk7XG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIC8vIGRldGVybWluZSBzdXBwb3J0IGZvciBwYXNzaXZlIGV2ZW50c1xuICAgIHN1cHBvcnRQYXNzaXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRlc3QgdmlhIGEgZ2V0dGVyIGluIHRoZSBvcHRpb25zIG9iamVjdCB0byBzZWUgaWYgdGhlIHBhc3NpdmUgcHJvcGVydHkgaXMgYWNjZXNzZWRcbiAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb25lKGdsb2JhbE9iamVjdCwgJ3Rlc3RQYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0oKSksXG4gICAgLy8gZXZlbnQgb3B0aW9uc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kI2ZlYXR1cmUtZGV0ZWN0aW9uXG4gICAgcGFzc2l2ZUhhbmRsZXIgPSBzdXBwb3J0UGFzc2l2ZSA/IHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9IDogZmFsc2UsXG4gICAgLy8gdHJhbnNpdGlvbnNcbiAgICBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSBzdXBwb3J0VHJhbnNpdGlvbnMgPyBnbG9iYWxPYmplY3RbZ2V0Q29tcHV0ZWRTdHlsZV0oZWxlbWVudClbdHJhbnNpdGlvbkR1cmF0aW9uXSA6IDA7XG4gICAgICBkdXJhdGlvbiA9IHBhcnNlRmxvYXQoZHVyYXRpb24pO1xuICAgICAgZHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInICYmICFpc05hTihkdXJhdGlvbikgPyBkdXJhdGlvbiAqIDEwMDAgOiAwO1xuICAgICAgcmV0dXJuIGR1cmF0aW9uOyAvLyB3ZSB0YWtlIGEgc2hvcnQgb2Zmc2V0IHRvIG1ha2Ugc3VyZSB3ZSBmaXJlIG9uIHRoZSBuZXh0IGZyYW1lIGFmdGVyIGFuaW1hdGlvblxuICAgIH0sXG4gICAgZW11bGF0ZVRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoZWxlbWVudCwgaGFuZGxlcikgeyAvLyBlbXVsYXRlVHJhbnNpdGlvbkVuZCBzaW5jZSAyLjAuNFxuICAgICAgdmFyIGNhbGxlZCA9IDAsXG4gICAgICAgIGR1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICBkdXJhdGlvbiA/IG9uZShlbGVtZW50LCB0cmFuc2l0aW9uRW5kRXZlbnQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgIWNhbGxlZCAmJiBoYW5kbGVyKGUpLCBjYWxsZWQgPSAxO1xuICAgICAgICB9KSA6XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICFjYWxsZWQgJiYgaGFuZGxlcigpLCBjYWxsZWQgPSAxO1xuICAgICAgICB9LCAxNyk7XG4gICAgfSxcbiAgICBib290c3RyYXBDdXN0b21FdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNvbXBvbmVudE5hbWUsIHJlbGF0ZWQpIHtcbiAgICAgIHZhciBPcmlnaW5hbEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSArICcuYnMuJyArIGNvbXBvbmVudE5hbWUpO1xuICAgICAgT3JpZ2luYWxDdXN0b21FdmVudC5yZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZDtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChPcmlnaW5hbEN1c3RvbUV2ZW50KTtcbiAgICB9LFxuXG4gICAgLy8gdG9vbHRpcCAvIHBvcG92ZXIgc3R1ZmZcbiAgICBnZXRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7IC8vIGFsc28gQWZmaXggYW5kIFNjcm9sbFNweSB1c2VzIGl0XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5OiBnbG9iYWxPYmplY3QucGFnZVlPZmZzZXQgfHwgSFRNTFtzY3JvbGxUb3BdLFxuICAgICAgICB4OiBnbG9iYWxPYmplY3QucGFnZVhPZmZzZXQgfHwgSFRNTFtzY3JvbGxMZWZ0XVxuICAgICAgfVxuICAgIH0sXG4gICAgc3R5bGVUaXAgPSBmdW5jdGlvbiAobGluaywgZWxlbWVudCwgcG9zaXRpb24sIHBhcmVudCkgeyAvLyBib3RoIHBvcG92ZXJzIGFuZCB0b29sdGlwcyAodGFyZ2V0LHRvb2x0aXAscGxhY2VtZW50LGVsZW1lbnRUb0FwcGVuZFRvKVxuICAgICAgdmFyIGVsZW1lbnREaW1lbnNpb25zID0ge1xuICAgICAgICAgIHc6IGVsZW1lbnRbb2Zmc2V0V2lkdGhdLFxuICAgICAgICAgIGg6IGVsZW1lbnRbb2Zmc2V0SGVpZ2h0XVxuICAgICAgICB9LFxuICAgICAgICB3aW5kb3dXaWR0aCA9IChIVE1MW2NsaWVudFdpZHRoXSB8fCBET0NbYm9keV1bY2xpZW50V2lkdGhdKSxcbiAgICAgICAgd2luZG93SGVpZ2h0ID0gKEhUTUxbY2xpZW50SGVpZ2h0XSB8fCBET0NbYm9keV1bY2xpZW50SGVpZ2h0XSksXG4gICAgICAgIHJlY3QgPSBsaW5rW2dldEJvdW5kaW5nQ2xpZW50UmVjdF0oKSxcbiAgICAgICAgc2Nyb2xsID0gcGFyZW50ID09PSBET0NbYm9keV0gPyBnZXRTY3JvbGwoKSA6IHtcbiAgICAgICAgICB4OiBwYXJlbnRbb2Zmc2V0TGVmdF0gKyBwYXJlbnRbc2Nyb2xsTGVmdF0sXG4gICAgICAgICAgeTogcGFyZW50W29mZnNldFRvcF0gKyBwYXJlbnRbc2Nyb2xsVG9wXVxuICAgICAgICB9LFxuICAgICAgICBsaW5rRGltZW5zaW9ucyA9IHtcbiAgICAgICAgICB3OiByZWN0W3JpZ2h0XSAtIHJlY3RbbGVmdF0sXG4gICAgICAgICAgaDogcmVjdFtib3R0b21dIC0gcmVjdFt0b3BdXG4gICAgICAgIH0sXG4gICAgICAgIGlzUG9wb3ZlciA9IGhhc0NsYXNzKGVsZW1lbnQsICdwb3BvdmVyJyksXG4gICAgICAgIHRvcFBvc2l0aW9uLCBsZWZ0UG9zaXRpb24sXG5cbiAgICAgICAgYXJyb3cgPSBxdWVyeUVsZW1lbnQoJy5hcnJvdycsIGVsZW1lbnQpLFxuICAgICAgICBhcnJvd1RvcCwgYXJyb3dMZWZ0LCBhcnJvd1dpZHRoLCBhcnJvd0hlaWdodCxcblxuICAgICAgICBoYWxmVG9wRXhjZWVkID0gcmVjdFt0b3BdICsgbGlua0RpbWVuc2lvbnMuaCAvIDIgLSBlbGVtZW50RGltZW5zaW9ucy5oIC8gMiA8IDAsXG4gICAgICAgIGhhbGZMZWZ0RXhjZWVkID0gcmVjdFtsZWZ0XSArIGxpbmtEaW1lbnNpb25zLncgLyAyIC0gZWxlbWVudERpbWVuc2lvbnMudyAvIDIgPCAwLFxuICAgICAgICBoYWxmUmlnaHRFeGNlZWQgPSByZWN0W2xlZnRdICsgZWxlbWVudERpbWVuc2lvbnMudyAvIDIgKyBsaW5rRGltZW5zaW9ucy53IC8gMiA+PSB3aW5kb3dXaWR0aCxcbiAgICAgICAgaGFsZkJvdHRvbUV4Y2VlZCA9IHJlY3RbdG9wXSArIGVsZW1lbnREaW1lbnNpb25zLmggLyAyICsgbGlua0RpbWVuc2lvbnMuaCAvIDIgPj0gd2luZG93SGVpZ2h0LFxuICAgICAgICB0b3BFeGNlZWQgPSByZWN0W3RvcF0gLSBlbGVtZW50RGltZW5zaW9ucy5oIDwgMCxcbiAgICAgICAgbGVmdEV4Y2VlZCA9IHJlY3RbbGVmdF0gLSBlbGVtZW50RGltZW5zaW9ucy53IDwgMCxcbiAgICAgICAgYm90dG9tRXhjZWVkID0gcmVjdFt0b3BdICsgZWxlbWVudERpbWVuc2lvbnMuaCArIGxpbmtEaW1lbnNpb25zLmggPj0gd2luZG93SGVpZ2h0LFxuICAgICAgICByaWdodEV4Y2VlZCA9IHJlY3RbbGVmdF0gKyBlbGVtZW50RGltZW5zaW9ucy53ICsgbGlua0RpbWVuc2lvbnMudyA+PSB3aW5kb3dXaWR0aDtcblxuICAgICAgLy8gcmVjb21wdXRlIHBvc2l0aW9uXG4gICAgICBwb3NpdGlvbiA9IChwb3NpdGlvbiA9PT0gbGVmdCB8fCBwb3NpdGlvbiA9PT0gcmlnaHQpICYmIGxlZnRFeGNlZWQgJiYgcmlnaHRFeGNlZWQgPyB0b3AgOiBwb3NpdGlvbjsgLy8gZmlyc3QsIHdoZW4gYm90aCBsZWZ0IGFuZCByaWdodCBsaW1pdHMgYXJlIGV4Y2VlZGVkLCB3ZSBmYWxsIGJhY2sgdG8gdG9wfGJvdHRvbVxuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdG9wICYmIHRvcEV4Y2VlZCA/IGJvdHRvbSA6IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gYm90dG9tICYmIGJvdHRvbUV4Y2VlZCA/IHRvcCA6IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gbGVmdCAmJiBsZWZ0RXhjZWVkID8gcmlnaHQgOiBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHJpZ2h0ICYmIHJpZ2h0RXhjZWVkID8gbGVmdCA6IHBvc2l0aW9uO1xuXG4gICAgICAvLyB1cGRhdGUgdG9vbHRpcC9wb3BvdmVyIGNsYXNzXG4gICAgICBlbGVtZW50LmNsYXNzTmFtZVtpbmRleE9mXShwb3NpdGlvbikgPT09IC0xICYmIChlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UodGlwUG9zaXRpb25zLCBwb3NpdGlvbikpO1xuXG4gICAgICAvLyB3ZSBjaGVjayB0aGUgY29tcHV0ZWQgd2lkdGggJiBoZWlnaHQgYW5kIHVwZGF0ZSBoZXJlXG4gICAgICBhcnJvd1dpZHRoID0gYXJyb3dbb2Zmc2V0V2lkdGhdO1xuICAgICAgYXJyb3dIZWlnaHQgPSBhcnJvd1tvZmZzZXRIZWlnaHRdO1xuXG4gICAgICAvLyBhcHBseSBzdHlsaW5nIHRvIHRvb2x0aXAgb3IgcG9wb3ZlclxuICAgICAgaWYgKHBvc2l0aW9uID09PSBsZWZ0IHx8IHBvc2l0aW9uID09PSByaWdodCkgeyAvLyBzZWNvbmRhcnl8c2lkZSBwb3NpdGlvbnNcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSBsZWZ0KSB7IC8vIExFRlRcbiAgICAgICAgICBsZWZ0UG9zaXRpb24gPSByZWN0W2xlZnRdICsgc2Nyb2xsLnggLSBlbGVtZW50RGltZW5zaW9ucy53IC0gKGlzUG9wb3ZlciA/IGFycm93V2lkdGggOiAwKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gUklHSFRcbiAgICAgICAgICBsZWZ0UG9zaXRpb24gPSByZWN0W2xlZnRdICsgc2Nyb2xsLnggKyBsaW5rRGltZW5zaW9ucy53O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRqdXN0IHRvcCBhbmQgYXJyb3dcbiAgICAgICAgaWYgKGhhbGZUb3BFeGNlZWQpIHtcbiAgICAgICAgICB0b3BQb3NpdGlvbiA9IHJlY3RbdG9wXSArIHNjcm9sbC55O1xuICAgICAgICAgIGFycm93VG9wID0gbGlua0RpbWVuc2lvbnMuaCAvIDIgLSBhcnJvd1dpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbGZCb3R0b21FeGNlZWQpIHtcbiAgICAgICAgICB0b3BQb3NpdGlvbiA9IHJlY3RbdG9wXSArIHNjcm9sbC55IC0gZWxlbWVudERpbWVuc2lvbnMuaCArIGxpbmtEaW1lbnNpb25zLmg7XG4gICAgICAgICAgYXJyb3dUb3AgPSBlbGVtZW50RGltZW5zaW9ucy5oIC0gbGlua0RpbWVuc2lvbnMuaCAvIDIgLSBhcnJvd1dpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcFBvc2l0aW9uID0gcmVjdFt0b3BdICsgc2Nyb2xsLnkgLSBlbGVtZW50RGltZW5zaW9ucy5oIC8gMiArIGxpbmtEaW1lbnNpb25zLmggLyAyO1xuICAgICAgICAgIGFycm93VG9wID0gZWxlbWVudERpbWVuc2lvbnMuaCAvIDIgLSAoaXNQb3BvdmVyID8gYXJyb3dIZWlnaHQgKiAwLjkgOiBhcnJvd0hlaWdodCAvIDIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSB0b3AgfHwgcG9zaXRpb24gPT09IGJvdHRvbSkgeyAvLyBwcmltYXJ5fHZlcnRpY2FsIHBvc2l0aW9uc1xuICAgICAgICBpZiAocG9zaXRpb24gPT09IHRvcCkgeyAvLyBUT1BcbiAgICAgICAgICB0b3BQb3NpdGlvbiA9IHJlY3RbdG9wXSArIHNjcm9sbC55IC0gZWxlbWVudERpbWVuc2lvbnMuaCAtIChpc1BvcG92ZXIgPyBhcnJvd0hlaWdodCA6IDApO1xuICAgICAgICB9IGVsc2UgeyAvLyBCT1RUT01cbiAgICAgICAgICB0b3BQb3NpdGlvbiA9IHJlY3RbdG9wXSArIHNjcm9sbC55ICsgbGlua0RpbWVuc2lvbnMuaDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGp1c3QgbGVmdCB8IHJpZ2h0IGFuZCBhbHNvIHRoZSBhcnJvd1xuICAgICAgICBpZiAoaGFsZkxlZnRFeGNlZWQpIHtcbiAgICAgICAgICBsZWZ0UG9zaXRpb24gPSAwO1xuICAgICAgICAgIGFycm93TGVmdCA9IHJlY3RbbGVmdF0gKyBsaW5rRGltZW5zaW9ucy53IC8gMiAtIGFycm93V2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFsZlJpZ2h0RXhjZWVkKSB7XG4gICAgICAgICAgbGVmdFBvc2l0aW9uID0gd2luZG93V2lkdGggLSBlbGVtZW50RGltZW5zaW9ucy53ICogMS4wMTtcbiAgICAgICAgICBhcnJvd0xlZnQgPSBlbGVtZW50RGltZW5zaW9ucy53IC0gKHdpbmRvd1dpZHRoIC0gcmVjdFtsZWZ0XSkgKyBsaW5rRGltZW5zaW9ucy53IC8gMiAtIGFycm93V2lkdGggLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlZnRQb3NpdGlvbiA9IHJlY3RbbGVmdF0gKyBzY3JvbGwueCAtIGVsZW1lbnREaW1lbnNpb25zLncgLyAyICsgbGlua0RpbWVuc2lvbnMudyAvIDI7XG4gICAgICAgICAgYXJyb3dMZWZ0ID0gZWxlbWVudERpbWVuc2lvbnMudyAvIDIgLSAoaXNQb3BvdmVyID8gYXJyb3dXaWR0aCA6IGFycm93V2lkdGggLyAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBzdHlsZSB0byB0b29sdGlwL3BvcG92ZXIgYW5kIGl0cyBhcnJvd1xuICAgICAgZWxlbWVudFtzdHlsZV1bdG9wXSA9IHRvcFBvc2l0aW9uICsgJ3B4JztcbiAgICAgIGVsZW1lbnRbc3R5bGVdW2xlZnRdID0gbGVmdFBvc2l0aW9uICsgJ3B4JztcblxuICAgICAgYXJyb3dUb3AgJiYgKGFycm93W3N0eWxlXVt0b3BdID0gYXJyb3dUb3AgKyAncHgnKTtcbiAgICAgIGFycm93TGVmdCAmJiAoYXJyb3dbc3R5bGVdW2xlZnRdID0gYXJyb3dMZWZ0ICsgJ3B4Jyk7XG4gICAgfTtcblxuICBCU04udmVyc2lvbiA9ICcyLjAuMjcnO1xuXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IEFsZXJ0XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEFMRVJUIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PVxuICB2YXIgQWxlcnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAvLyBiaW5kLCB0YXJnZXQgYWxlcnQsIGR1cmF0aW9uIGFuZCBzdHVmZlxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGNvbXBvbmVudCA9ICdhbGVydCcsXG4gICAgICBhbGVydCA9IGdldENsb3Nlc3QoZWxlbWVudCwgJy4nICsgY29tcG9uZW50KSxcbiAgICAgIHRyaWdnZXJIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBoYXNDbGFzcyhhbGVydCwgJ2ZhZGUnKSA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKGFsZXJ0LCB0cmFuc2l0aW9uRW5kSGFuZGxlcikgOiB0cmFuc2l0aW9uRW5kSGFuZGxlcigpO1xuICAgICAgfSxcbiAgICAgIC8vIGhhbmRsZXJzXG4gICAgICBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBhbGVydCA9IGdldENsb3Nlc3QoZVt0YXJnZXRdLCAnLicgKyBjb21wb25lbnQpO1xuICAgICAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KCdbJyArIGRhdGFEaXNtaXNzICsgJz1cIicgKyBjb21wb25lbnQgKyAnXCJdJywgYWxlcnQpO1xuICAgICAgICBlbGVtZW50ICYmIGFsZXJ0ICYmIChlbGVtZW50ID09PSBlW3RhcmdldF0gfHwgZWxlbWVudFtjb250YWluc10oZVt0YXJnZXRdKSkgJiYgc2VsZi5jbG9zZSgpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zaXRpb25FbmRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGFsZXJ0LCBjbG9zZWRFdmVudCwgY29tcG9uZW50KTtcbiAgICAgICAgb2ZmKGVsZW1lbnQsIGNsaWNrRXZlbnQsIGNsaWNrSGFuZGxlcik7IC8vIGRldGFjaCBpdCdzIGxpc3RlbmVyXG4gICAgICAgIGFsZXJ0W3BhcmVudE5vZGVdLnJlbW92ZUNoaWxkKGFsZXJ0KTtcbiAgICAgIH07XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kXG4gICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChhbGVydCAmJiBlbGVtZW50ICYmIGhhc0NsYXNzKGFsZXJ0LCBzaG93Q2xhc3MpKSB7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoYWxlcnQsIGNsb3NlRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIHJlbW92ZUNsYXNzKGFsZXJ0LCBzaG93Q2xhc3MpO1xuICAgICAgICBhbGVydCAmJiB0cmlnZ2VySGFuZGxlcigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBpbml0XG4gICAgaWYgKCEoc3RyaW5nQWxlcnQgaW4gZWxlbWVudCkpIHsgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICAgIG9uKGVsZW1lbnQsIGNsaWNrRXZlbnQsIGNsaWNrSGFuZGxlcik7XG4gICAgfVxuICAgIGVsZW1lbnRbc3RyaW5nQWxlcnRdID0gc2VsZjtcbiAgfTtcblxuICAvLyBBTEVSVCBEQVRBIEFQSVxuICAvLyA9PT09PT09PT09PT09PVxuICBzdXBwb3J0c1twdXNoXShbc3RyaW5nQWxlcnQsIEFsZXJ0LCAnWycgKyBkYXRhRGlzbWlzcyArICc9XCJhbGVydFwiXSddKTtcblxuXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IEJ1dHRvblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEJVVFRPTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT1cbiAgdmFyIEJ1dHRvbiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcblxuICAgIC8vIGNvbnN0YW50XG4gICAgdmFyIHRvZ2dsZWQgPSBmYWxzZSwgLy8gdG9nZ2xlZCBtYWtlcyBzdXJlIHRvIHByZXZlbnQgdHJpZ2dlcmluZyB0d2ljZSB0aGUgY2hhbmdlLmJzLmJ1dHRvbiBldmVudHNcblxuICAgICAgLy8gc3RyaW5nc1xuICAgICAgY29tcG9uZW50ID0gJ2J1dHRvbicsXG4gICAgICBjaGVja2VkID0gJ2NoZWNrZWQnLFxuICAgICAgTEFCRUwgPSAnTEFCRUwnLFxuICAgICAgSU5QVVQgPSAnSU5QVVQnLFxuXG4gICAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICAgIGtleUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAgICAgIGtleSA9PT0gMzIgJiYgZVt0YXJnZXRdID09PSBET0MuYWN0aXZlRWxlbWVudCAmJiB0b2dnbGUoZSk7XG4gICAgICB9LFxuICAgICAgcHJldmVudFNjcm9sbCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBrZXkgPSBlLndoaWNoIHx8IGUua2V5Q29kZTtcbiAgICAgICAga2V5ID09PSAzMiAmJiBlW3ByZXZlbnREZWZhdWx0XSgpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGVbdGFyZ2V0XS50YWdOYW1lID09PSBMQUJFTCA/IGVbdGFyZ2V0XSA6IGVbdGFyZ2V0XVtwYXJlbnROb2RlXS50YWdOYW1lID09PSBMQUJFTCA/IGVbdGFyZ2V0XVtwYXJlbnROb2RlXSA6IG51bGw7IC8vIHRoZSAuYnRuIGxhYmVsXG5cbiAgICAgICAgaWYgKCFsYWJlbCkgcmV0dXJuOyAvL3JlYWN0IGlmIGEgbGFiZWwgb3IgaXRzIGltbWVkaWF0ZSBjaGlsZCBpcyBjbGlja2VkXG5cbiAgICAgICAgdmFyIGxhYmVscyA9IGdldEVsZW1lbnRzQnlDbGFzc05hbWUobGFiZWxbcGFyZW50Tm9kZV0sICdidG4nKSwgLy8gYWxsIHRoZSBidXR0b24gZ3JvdXAgYnV0dG9uc1xuICAgICAgICAgIGlucHV0ID0gbGFiZWxbZ2V0RWxlbWVudHNCeVRhZ05hbWVdKElOUFVUKVswXTtcblxuICAgICAgICBpZiAoIWlucHV0KSByZXR1cm47IC8vIHJldHVybiBpZiBubyBpbnB1dCBmb3VuZFxuXG4gICAgICAgIC8vIG1hbmFnZSB0aGUgZG9tIG1hbmlwdWxhdGlvblxuICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ2NoZWNrYm94JykgeyAvL2NoZWNrYm94ZXNcbiAgICAgICAgICBpZiAoIWlucHV0W2NoZWNrZWRdKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhsYWJlbCwgYWN0aXZlKTtcbiAgICAgICAgICAgIGlucHV0W2dldEF0dHJpYnV0ZV0oY2hlY2tlZCk7XG4gICAgICAgICAgICBpbnB1dFtzZXRBdHRyaWJ1dGVdKGNoZWNrZWQsIGNoZWNrZWQpO1xuICAgICAgICAgICAgaW5wdXRbY2hlY2tlZF0gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhsYWJlbCwgYWN0aXZlKTtcbiAgICAgICAgICAgIGlucHV0W2dldEF0dHJpYnV0ZV0oY2hlY2tlZCk7XG4gICAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoY2hlY2tlZCk7XG4gICAgICAgICAgICBpbnB1dFtjaGVja2VkXSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdG9nZ2xlZCkgeyAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgdGhlIGV2ZW50IHR3aWNlXG4gICAgICAgICAgICB0b2dnbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoaW5wdXQsIGNoYW5nZUV2ZW50LCBjb21wb25lbnQpOyAvL3RyaWdnZXIgdGhlIGNoYW5nZSBmb3IgdGhlIGlucHV0XG4gICAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGNoYW5nZUV2ZW50LCBjb21wb25lbnQpOyAvL3RyaWdnZXIgdGhlIGNoYW5nZSBmb3IgdGhlIGJ0bi1ncm91cFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dC50eXBlID09PSAncmFkaW8nICYmICF0b2dnbGVkKSB7IC8vIHJhZGlvIGJ1dHRvbnNcbiAgICAgICAgICAvLyBkb24ndCB0cmlnZ2VyIGlmIGFscmVhZHkgYWN0aXZlICh0aGUgT1IgY29uZGl0aW9uIGlzIGEgaGFjayB0byBjaGVjayBpZiB0aGUgYnV0dG9ucyB3ZXJlIHNlbGVjdGVkIHdpdGgga2V5IHByZXNzIGFuZCBOT1QgbW91c2UgY2xpY2spXG4gICAgICAgICAgaWYgKCFpbnB1dFtjaGVja2VkXSB8fCAoZS5zY3JlZW5YID09PSAwICYmIGUuc2NyZWVuWSA9PSAwKSkge1xuICAgICAgICAgICAgYWRkQ2xhc3MobGFiZWwsIGFjdGl2ZSk7XG4gICAgICAgICAgICBhZGRDbGFzcyhsYWJlbCwgZm9jdXNFdmVudCk7XG4gICAgICAgICAgICBpbnB1dFtzZXRBdHRyaWJ1dGVdKGNoZWNrZWQsIGNoZWNrZWQpO1xuICAgICAgICAgICAgaW5wdXRbY2hlY2tlZF0gPSB0cnVlO1xuICAgICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChpbnB1dCwgY2hhbmdlRXZlbnQsIGNvbXBvbmVudCk7IC8vdHJpZ2dlciB0aGUgY2hhbmdlIGZvciB0aGUgaW5wdXRcbiAgICAgICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgY2hhbmdlRXZlbnQsIGNvbXBvbmVudCk7IC8vdHJpZ2dlciB0aGUgY2hhbmdlIGZvciB0aGUgYnRuLWdyb3VwXG5cbiAgICAgICAgICAgIHRvZ2dsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxsID0gbGFiZWxzW2xlbmd0aF07IGkgPCBsbDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBvdGhlckxhYmVsID0gbGFiZWxzW2ldLFxuICAgICAgICAgICAgICAgIG90aGVySW5wdXQgPSBvdGhlckxhYmVsW2dldEVsZW1lbnRzQnlUYWdOYW1lXShJTlBVVClbMF07XG4gICAgICAgICAgICAgIGlmIChvdGhlckxhYmVsICE9PSBsYWJlbCAmJiBoYXNDbGFzcyhvdGhlckxhYmVsLCBhY3RpdmUpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Mob3RoZXJMYWJlbCwgYWN0aXZlKTtcbiAgICAgICAgICAgICAgICBvdGhlcklucHV0LnJlbW92ZUF0dHJpYnV0ZShjaGVja2VkKTtcbiAgICAgICAgICAgICAgICBvdGhlcklucHV0W2NoZWNrZWRdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChvdGhlcklucHV0LCBjaGFuZ2VFdmVudCwgY29tcG9uZW50KTsgLy8gdHJpZ2dlciB0aGUgY2hhbmdlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdG9nZ2xlZCA9IGZhbHNlO1xuICAgICAgICB9LCA1MCk7XG4gICAgICB9LFxuICAgICAgZm9jdXNIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgYWRkQ2xhc3MoZVt0YXJnZXRdW3BhcmVudE5vZGVdLCBmb2N1c0V2ZW50KTtcbiAgICAgIH0sXG4gICAgICBibHVySGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGVbdGFyZ2V0XVtwYXJlbnROb2RlXSwgZm9jdXNFdmVudCk7XG4gICAgICB9O1xuXG4gICAgLy8gaW5pdFxuICAgIGlmICghKHN0cmluZ0J1dHRvbiBpbiBlbGVtZW50KSkgeyAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgICAgb24oZWxlbWVudCwgY2xpY2tFdmVudCwgdG9nZ2xlKTtcbiAgICAgIG9uKGVsZW1lbnQsIGtleXVwRXZlbnQsIGtleUhhbmRsZXIpLCBvbihlbGVtZW50LCBrZXlkb3duRXZlbnQsIHByZXZlbnRTY3JvbGwpO1xuXG4gICAgICB2YXIgYWxsQnRucyA9IGdldEVsZW1lbnRzQnlDbGFzc05hbWUoZWxlbWVudCwgJ2J0bicpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxCdG5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGFsbEJ0bnNbaV1bZ2V0RWxlbWVudHNCeVRhZ05hbWVdKElOUFVUKVswXTtcbiAgICAgICAgb24oaW5wdXQsIGZvY3VzRXZlbnQsIGZvY3VzSGFuZGxlciksIG9uKGlucHV0LCAnYmx1cicsIGJsdXJIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhY3RpdmF0ZSBpdGVtcyBvbiBsb2FkXG4gICAgdmFyIGxhYmVsc1RvQUN0aXZhdGUgPSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGVsZW1lbnQsICdidG4nKSxcbiAgICAgIGxibGwgPSBsYWJlbHNUb0FDdGl2YXRlW2xlbmd0aF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYmxsOyBpKyspIHtcbiAgICAgICFoYXNDbGFzcyhsYWJlbHNUb0FDdGl2YXRlW2ldLCBhY3RpdmUpICYmIHF1ZXJ5RWxlbWVudCgnaW5wdXQ6Y2hlY2tlZCcsIGxhYmVsc1RvQUN0aXZhdGVbaV0pICYmXG4gICAgICAgIGFkZENsYXNzKGxhYmVsc1RvQUN0aXZhdGVbaV0sIGFjdGl2ZSk7XG4gICAgfVxuICAgIGVsZW1lbnRbc3RyaW5nQnV0dG9uXSA9IHRoaXM7XG4gIH07XG5cbiAgLy8gQlVUVE9OIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKFtzdHJpbmdCdXR0b24sIEJ1dHRvbiwgJ1snICsgZGF0YVRvZ2dsZSArICc9XCJidXR0b25zXCJdJ10pO1xuXG5cbiAgLyogTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgQ2Fyb3VzZWxcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gQ0FST1VTRUwgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09XG4gIHZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG5cbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcblxuICAgIC8vIHNldCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciBpbnRlcnZhbEF0dHJpYnV0ZSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhSW50ZXJ2YWwpLFxuICAgICAgaW50ZXJ2YWxPcHRpb24gPSBvcHRpb25zW2ludGVydmFsXSxcbiAgICAgIGludGVydmFsRGF0YSA9IGludGVydmFsQXR0cmlidXRlID09PSAnZmFsc2UnID8gMCA6IHBhcnNlSW50KGludGVydmFsQXR0cmlidXRlKSxcbiAgICAgIHBhdXNlRGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhUGF1c2UpID09PSBob3ZlckV2ZW50IHx8IGZhbHNlLFxuICAgICAga2V5Ym9hcmREYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFLZXlib2FyZCkgPT09ICd0cnVlJyB8fCBmYWxzZSxcblxuICAgICAgLy8gc3RyaW5nc1xuICAgICAgY29tcG9uZW50ID0gJ2Nhcm91c2VsJyxcbiAgICAgIHBhdXNlZCA9ICdwYXVzZWQnLFxuICAgICAgZGlyZWN0aW9uID0gJ2RpcmVjdGlvbicsXG4gICAgICBjYXJvdXNlbEl0ZW0gPSAnY2Fyb3VzZWwtaXRlbScsXG4gICAgICBkYXRhU2xpZGVUbyA9ICdkYXRhLXNsaWRlLXRvJztcblxuICAgIHRoaXNba2V5Ym9hcmRdID0gb3B0aW9uc1trZXlib2FyZF0gPT09IHRydWUgfHwga2V5Ym9hcmREYXRhO1xuICAgIHRoaXNbcGF1c2VdID0gKG9wdGlvbnNbcGF1c2VdID09PSBob3ZlckV2ZW50IHx8IHBhdXNlRGF0YSkgPyBob3ZlckV2ZW50IDogZmFsc2U7IC8vIGZhbHNlIC8gaG92ZXJcblxuICAgIHRoaXNbaW50ZXJ2YWxdID0gdHlwZW9mIGludGVydmFsT3B0aW9uID09PSAnbnVtYmVyJyA/IGludGVydmFsT3B0aW9uIDpcbiAgICAgIGludGVydmFsT3B0aW9uID09PSBmYWxzZSB8fCBpbnRlcnZhbERhdGEgPT09IDAgfHwgaW50ZXJ2YWxEYXRhID09PSBmYWxzZSA/IDAgOlxuICAgICAgaXNOYU4oaW50ZXJ2YWxEYXRhKSA/IDUwMDAgLy8gYm9vdHN0cmFwIGNhcm91c2VsIGRlZmF1bHQgaW50ZXJ2YWxcbiAgICAgIDpcbiAgICAgIGludGVydmFsRGF0YTtcblxuICAgIC8vIGJpbmQsIGV2ZW50IHRhcmdldHNcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBpbmRleCA9IGVsZW1lbnQuaW5kZXggPSAwLFxuICAgICAgdGltZXIgPSBlbGVtZW50LnRpbWVyID0gMCxcbiAgICAgIGlzU2xpZGluZyA9IGZhbHNlLCAvLyBpc1NsaWRpbmcgcHJldmVudHMgY2xpY2sgZXZlbnQgaGFuZGxlcnMgd2hlbiBhbmltYXRpb24gaXMgcnVubmluZ1xuICAgICAgaXNUb3VjaCA9IGZhbHNlLFxuICAgICAgc3RhcnRYUG9zaXRpb24gPSBudWxsLFxuICAgICAgY3VycmVudFhQb3NpdGlvbiA9IG51bGwsXG4gICAgICBlbmRYUG9zaXRpb24gPSBudWxsLCAvLyB0b3VjaCBhbmQgZXZlbnQgY29vcmRpbmF0ZXNcbiAgICAgIHNsaWRlcyA9IGdldEVsZW1lbnRzQnlDbGFzc05hbWUoZWxlbWVudCwgY2Fyb3VzZWxJdGVtKSxcbiAgICAgIHRvdGFsID0gc2xpZGVzW2xlbmd0aF0sXG4gICAgICBzbGlkZURpcmVjdGlvbiA9IHRoaXNbZGlyZWN0aW9uXSA9IGxlZnQsXG4gICAgICBsZWZ0QXJyb3cgPSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGVsZW1lbnQsIGNvbXBvbmVudCArICctY29udHJvbC1wcmV2JylbMF0sXG4gICAgICByaWdodEFycm93ID0gZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShlbGVtZW50LCBjb21wb25lbnQgKyAnLWNvbnRyb2wtbmV4dCcpWzBdLFxuICAgICAgaW5kaWNhdG9yID0gcXVlcnlFbGVtZW50KCcuJyArIGNvbXBvbmVudCArICctaW5kaWNhdG9ycycsIGVsZW1lbnQpLFxuICAgICAgaW5kaWNhdG9ycyA9IGluZGljYXRvciAmJiBpbmRpY2F0b3JbZ2V0RWxlbWVudHNCeVRhZ05hbWVdKFwiTElcIikgfHwgW107XG5cbiAgICAvLyBpbnZhbGlkYXRlIHdoZW4gbm90IGVub3VnaCBpdGVtc1xuICAgIGlmICh0b3RhbCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGVyc1xuICAgIHZhciBwYXVzZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmW2ludGVydmFsXSAhPT0gZmFsc2UgJiYgIWhhc0NsYXNzKGVsZW1lbnQsIHBhdXNlZCkpIHtcbiAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBwYXVzZWQpO1xuICAgICAgICAgICFpc1NsaWRpbmcgJiYgKGNsZWFySW50ZXJ2YWwodGltZXIpLCB0aW1lciA9IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzdW1lSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGZbaW50ZXJ2YWxdICE9PSBmYWxzZSAmJiBoYXNDbGFzcyhlbGVtZW50LCBwYXVzZWQpKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgcGF1c2VkKTtcbiAgICAgICAgICAhaXNTbGlkaW5nICYmIChjbGVhckludGVydmFsKHRpbWVyKSwgdGltZXIgPSBudWxsKTtcbiAgICAgICAgICAhaXNTbGlkaW5nICYmIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluZGljYXRvckhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlW3ByZXZlbnREZWZhdWx0XSgpO1xuICAgICAgICBpZiAoaXNTbGlkaW5nKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZVt0YXJnZXRdOyAvLyBldmVudCB0YXJnZXQgfCB0aGUgY3VycmVudCBhY3RpdmUgaXRlbVxuXG4gICAgICAgIGlmIChldmVudFRhcmdldCAmJiAhaGFzQ2xhc3MoZXZlbnRUYXJnZXQsIGFjdGl2ZSkgJiYgZXZlbnRUYXJnZXRbZ2V0QXR0cmlidXRlXShkYXRhU2xpZGVUbykpIHtcbiAgICAgICAgICBpbmRleCA9IHBhcnNlSW50KGV2ZW50VGFyZ2V0W2dldEF0dHJpYnV0ZV0oZGF0YVNsaWRlVG8pLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zbGlkZVRvKGluZGV4KTsgLy9EbyB0aGUgc2xpZGVcbiAgICAgIH0sXG4gICAgICBjb250cm9sc0hhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlW3ByZXZlbnREZWZhdWx0XSgpO1xuICAgICAgICBpZiAoaXNTbGlkaW5nKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblxuICAgICAgICBpZiAoZXZlbnRUYXJnZXQgPT09IHJpZ2h0QXJyb3cpIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VGFyZ2V0ID09PSBsZWZ0QXJyb3cpIHtcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zbGlkZVRvKGluZGV4KTsgLy9EbyB0aGUgc2xpZGVcbiAgICAgIH0sXG4gICAgICBrZXlIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGlzU2xpZGluZykgcmV0dXJuO1xuICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnNsaWRlVG8oaW5kZXgpOyAvL0RvIHRoZSBzbGlkZVxuICAgICAgfSxcbiAgICAgIC8vIHRvdWNoIGV2ZW50c1xuICAgICAgdG9nZ2xlVG91Y2hFdmVudHMgPSBmdW5jdGlvbiAodG9nZ2xlKSB7XG4gICAgICAgIHRvZ2dsZShlbGVtZW50LCB0b3VjaEV2ZW50cy5tb3ZlLCB0b3VjaE1vdmVIYW5kbGVyLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgICAgIHRvZ2dsZShlbGVtZW50LCB0b3VjaEV2ZW50cy5lbmQsIHRvdWNoRW5kSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIHRvdWNoRG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0WFBvc2l0aW9uID0gcGFyc2VJbnQoZS50b3VjaGVzWzBdLnBhZ2VYKTtcblxuICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhlW3RhcmdldF0pKSB7XG4gICAgICAgICAgaXNUb3VjaCA9IHRydWU7XG4gICAgICAgICAgdG9nZ2xlVG91Y2hFdmVudHMob24pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG91Y2hNb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghaXNUb3VjaCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50WFBvc2l0aW9uID0gcGFyc2VJbnQoZS50b3VjaGVzWzBdLnBhZ2VYKTtcblxuICAgICAgICAvL2NhbmNlbCB0b3VjaCBpZiBtb3JlIHRoYW4gb25lIHRvdWNoZXMgZGV0ZWN0ZWRcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNobW92ZScgJiYgZS50b3VjaGVzW2xlbmd0aF0gPiAxKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvdWNoRW5kSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghaXNUb3VjaCB8fCBpc1NsaWRpbmcpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGVuZFhQb3NpdGlvbiA9IGN1cnJlbnRYUG9zaXRpb24gfHwgcGFyc2VJbnQoZS50b3VjaGVzWzBdLnBhZ2VYKTtcblxuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgIGlmICgoIWVsZW1lbnQuY29udGFpbnMoZVt0YXJnZXRdKSB8fCAhZWxlbWVudC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSAmJiBNYXRoLmFicyhzdGFydFhQb3NpdGlvbiAtIGVuZFhQb3NpdGlvbikgPCA3NSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFhQb3NpdGlvbiA8IHN0YXJ0WFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRYUG9zaXRpb24gPiBzdGFydFhQb3NpdGlvbikge1xuICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNUb3VjaCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5zbGlkZVRvKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9nZ2xlVG91Y2hFdmVudHMob2ZmKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgICBpc0VsZW1lbnRJblNjcm9sbFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVjdCA9IGVsZW1lbnRbZ2V0Qm91bmRpbmdDbGllbnRSZWN0XSgpLFxuICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0ID0gZ2xvYmFsT2JqZWN0W2lubmVySGVpZ2h0XSB8fCBIVE1MW2NsaWVudEhlaWdodF1cbiAgICAgICAgcmV0dXJuIHJlY3RbdG9wXSA8PSB2aWV3cG9ydEhlaWdodCAmJiByZWN0W2JvdHRvbV0gPj0gMDsgLy8gYm90dG9tICYmIHRvcFxuICAgICAgfSxcbiAgICAgIHNldEFjdGl2ZVBhZ2UgPSBmdW5jdGlvbiAocGFnZUluZGV4KSB7IC8vaW5kaWNhdG9yc1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWNsID0gaW5kaWNhdG9yc1tsZW5ndGhdOyBpIDwgaWNsOyBpKyspIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyhpbmRpY2F0b3JzW2ldLCBhY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRpY2F0b3JzW3BhZ2VJbmRleF0pIGFkZENsYXNzKGluZGljYXRvcnNbcGFnZUluZGV4XSwgYWN0aXZlKTtcbiAgICAgIH07XG5cblxuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgdGhpcy5jeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aW1lcikge1xuICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNFbGVtZW50SW5TY3JvbGxSYW5nZSgpICYmIChpbmRleCsrLCBzZWxmLnNsaWRlVG8oaW5kZXgpKTtcbiAgICAgIH0sIHRoaXNbaW50ZXJ2YWxdKTtcbiAgICB9O1xuICAgIHRoaXMuc2xpZGVUbyA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICBpZiAoaXNTbGlkaW5nKSByZXR1cm47IC8vIHdoZW4gY29udHJvbGVkIHZpYSBtZXRob2RzLCBtYWtlIHN1cmUgdG8gY2hlY2sgYWdhaW4gICAgICBcblxuICAgICAgdmFyIGFjdGl2ZUl0ZW0gPSB0aGlzLmdldEFjdGl2ZUluZGV4KCksIC8vIHRoZSBjdXJyZW50IGFjdGl2ZVxuICAgICAgICBvcmllbnRhdGlvbjtcblxuICAgICAgLy8gZmlyc3QgcmV0dXJuIGlmIHdlJ3JlIG9uIHRoZSBzYW1lIGl0ZW0gIzIyN1xuICAgICAgaWYgKGFjdGl2ZUl0ZW0gPT09IG5leHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBvciBkZXRlcm1pbmUgc2xpZGVEaXJlY3Rpb25cbiAgICAgIH0gZWxzZSBpZiAoKGFjdGl2ZUl0ZW0gPCBuZXh0KSB8fCAoYWN0aXZlSXRlbSA9PT0gMCAmJiBuZXh0ID09PSB0b3RhbCAtIDEpKSB7XG4gICAgICAgIHNsaWRlRGlyZWN0aW9uID0gc2VsZltkaXJlY3Rpb25dID0gbGVmdDsgLy8gbmV4dFxuICAgICAgfSBlbHNlIGlmICgoYWN0aXZlSXRlbSA+IG5leHQpIHx8IChhY3RpdmVJdGVtID09PSB0b3RhbCAtIDEgJiYgbmV4dCA9PT0gMCkpIHtcbiAgICAgICAgc2xpZGVEaXJlY3Rpb24gPSBzZWxmW2RpcmVjdGlvbl0gPSByaWdodDsgLy8gcHJldlxuICAgICAgfVxuXG4gICAgICAvLyBmaW5kIHRoZSByaWdodCBuZXh0IGluZGV4IFxuICAgICAgaWYgKG5leHQgPCAwKSB7XG4gICAgICAgIG5leHQgPSB0b3RhbCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKG5leHQgPj0gdG90YWwpIHtcbiAgICAgICAgbmV4dCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSBpbmRleFxuICAgICAgaW5kZXggPSBuZXh0O1xuXG4gICAgICBvcmllbnRhdGlvbiA9IHNsaWRlRGlyZWN0aW9uID09PSBsZWZ0ID8gJ25leHQnIDogJ3ByZXYnOyAvL2RldGVybWluZSB0eXBlXG4gICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNsaWRlRXZlbnQsIGNvbXBvbmVudCwgc2xpZGVzW25leHRdKTsgLy8gaGVyZSB3ZSBnbyB3aXRoIHRoZSBzbGlkZVxuXG4gICAgICBpc1NsaWRpbmcgPSB0cnVlO1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgICBzZXRBY3RpdmVQYWdlKG5leHQpO1xuXG4gICAgICBpZiAoc3VwcG9ydFRyYW5zaXRpb25zICYmIGhhc0NsYXNzKGVsZW1lbnQsICdzbGlkZScpKSB7XG5cbiAgICAgICAgYWRkQ2xhc3Moc2xpZGVzW25leHRdLCBjYXJvdXNlbEl0ZW0gKyAnLScgKyBvcmllbnRhdGlvbik7XG4gICAgICAgIHNsaWRlc1tuZXh0XVtvZmZzZXRXaWR0aF07XG4gICAgICAgIGFkZENsYXNzKHNsaWRlc1tuZXh0XSwgY2Fyb3VzZWxJdGVtICsgJy0nICsgc2xpZGVEaXJlY3Rpb24pO1xuICAgICAgICBhZGRDbGFzcyhzbGlkZXNbYWN0aXZlSXRlbV0sIGNhcm91c2VsSXRlbSArICctJyArIHNsaWRlRGlyZWN0aW9uKTtcblxuICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChzbGlkZXNbbmV4dF0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHRpbWVvdXQgPSBlICYmIGVbdGFyZ2V0XSAhPT0gc2xpZGVzW25leHRdID8gZS5lbGFwc2VkVGltZSAqIDEwMDAgKyAxMDAgOiAyMDtcblxuICAgICAgICAgIGlzU2xpZGluZyAmJiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlzU2xpZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBhZGRDbGFzcyhzbGlkZXNbbmV4dF0sIGFjdGl2ZSk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhzbGlkZXNbYWN0aXZlSXRlbV0sIGFjdGl2ZSk7XG5cbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNsaWRlc1tuZXh0XSwgY2Fyb3VzZWxJdGVtICsgJy0nICsgb3JpZW50YXRpb24pO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2xpZGVzW25leHRdLCBjYXJvdXNlbEl0ZW0gKyAnLScgKyBzbGlkZURpcmVjdGlvbik7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhzbGlkZXNbYWN0aXZlSXRlbV0sIGNhcm91c2VsSXRlbSArICctJyArIHNsaWRlRGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkRXZlbnQsIGNvbXBvbmVudCwgc2xpZGVzW25leHRdKTtcblxuICAgICAgICAgICAgaWYgKCFET0MuaGlkZGVuICYmIHNlbGZbaW50ZXJ2YWxdICYmICFoYXNDbGFzcyhlbGVtZW50LCBwYXVzZWQpKSB7XG4gICAgICAgICAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZENsYXNzKHNsaWRlc1tuZXh0XSwgYWN0aXZlKTtcbiAgICAgICAgc2xpZGVzW25leHRdW29mZnNldFdpZHRoXTtcbiAgICAgICAgcmVtb3ZlQ2xhc3Moc2xpZGVzW2FjdGl2ZUl0ZW1dLCBhY3RpdmUpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoc2VsZltpbnRlcnZhbF0gJiYgIWhhc0NsYXNzKGVsZW1lbnQsIHBhdXNlZCkpIHtcbiAgICAgICAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzbGlkRXZlbnQsIGNvbXBvbmVudCwgc2xpZGVzW25leHRdKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0QWN0aXZlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2xpZGVzW2luZGV4T2ZdKGdldEVsZW1lbnRzQnlDbGFzc05hbWUoZWxlbWVudCwgY2Fyb3VzZWxJdGVtICsgJyBhY3RpdmUnKVswXSkgfHwgMDtcbiAgICB9O1xuXG4gICAgLy8gaW5pdFxuICAgIGlmICghKHN0cmluZ0Nhcm91c2VsIGluIGVsZW1lbnQpKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG5cbiAgICAgIGlmIChzZWxmW3BhdXNlXSAmJiBzZWxmW2ludGVydmFsXSkge1xuICAgICAgICBvbihlbGVtZW50LCBtb3VzZUhvdmVyWzBdLCBwYXVzZUhhbmRsZXIpO1xuICAgICAgICBvbihlbGVtZW50LCBtb3VzZUhvdmVyWzFdLCByZXN1bWVIYW5kbGVyKTtcbiAgICAgICAgb24oZWxlbWVudCwgdG91Y2hFdmVudHMuc3RhcnQsIHBhdXNlSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgICAgICBvbihlbGVtZW50LCB0b3VjaEV2ZW50cy5lbmQsIHJlc3VtZUhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgc2xpZGVzW2xlbmd0aF0gPiAxICYmIG9uKGVsZW1lbnQsIHRvdWNoRXZlbnRzLnN0YXJ0LCB0b3VjaERvd25IYW5kbGVyLCBwYXNzaXZlSGFuZGxlcik7XG5cbiAgICAgIHJpZ2h0QXJyb3cgJiYgb24ocmlnaHRBcnJvdywgY2xpY2tFdmVudCwgY29udHJvbHNIYW5kbGVyKTtcbiAgICAgIGxlZnRBcnJvdyAmJiBvbihsZWZ0QXJyb3csIGNsaWNrRXZlbnQsIGNvbnRyb2xzSGFuZGxlcik7XG5cbiAgICAgIGluZGljYXRvciAmJiBvbihpbmRpY2F0b3IsIGNsaWNrRXZlbnQsIGluZGljYXRvckhhbmRsZXIpO1xuICAgICAgc2VsZltrZXlib2FyZF0gJiYgb24oZ2xvYmFsT2JqZWN0LCBrZXlkb3duRXZlbnQsIGtleUhhbmRsZXIpO1xuXG4gICAgfVxuICAgIGlmIChzZWxmLmdldEFjdGl2ZUluZGV4KCkgPCAwKSB7XG4gICAgICBzbGlkZXNbbGVuZ3RoXSAmJiBhZGRDbGFzcyhzbGlkZXNbMF0sIGFjdGl2ZSk7XG4gICAgICBpbmRpY2F0b3JzW2xlbmd0aF0gJiYgc2V0QWN0aXZlUGFnZSgwKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZltpbnRlcnZhbF0pIHtcbiAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICB9XG4gICAgZWxlbWVudFtzdHJpbmdDYXJvdXNlbF0gPSBzZWxmO1xuICB9O1xuXG4gIC8vIENBUk9VU0VMIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKFtzdHJpbmdDYXJvdXNlbCwgQ2Fyb3VzZWwsICdbJyArIGRhdGFSaWRlICsgJz1cImNhcm91c2VsXCJdJ10pO1xuXG5cbiAgLyogTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgQ29sbGFwc2VcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIENPTExBUFNFIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuICB2YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gZXZlbnQgdGFyZ2V0cyBhbmQgY29uc3RhbnRzXG4gICAgdmFyIGFjY29yZGlvbiA9IG51bGwsXG4gICAgICBjb2xsYXBzZSA9IG51bGwsXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIGFjY29yZGlvbkRhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oJ2RhdGEtcGFyZW50JyksXG4gICAgICBhY3RpdmVDb2xsYXBzZSwgYWN0aXZlRWxlbWVudCxcblxuICAgICAgLy8gY29tcG9uZW50IHN0cmluZ3NcbiAgICAgIGNvbXBvbmVudCA9ICdjb2xsYXBzZScsXG4gICAgICBjb2xsYXBzZWQgPSAnY29sbGFwc2VkJyxcbiAgICAgIGlzQW5pbWF0aW5nID0gJ2lzQW5pbWF0aW5nJyxcblxuICAgICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgICBvcGVuQWN0aW9uID0gZnVuY3Rpb24gKGNvbGxhcHNlRWxlbWVudCwgdG9nZ2xlKSB7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBzaG93RXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIGNvbGxhcHNlRWxlbWVudFtpc0FuaW1hdGluZ10gPSB0cnVlO1xuICAgICAgICBhZGRDbGFzcyhjb2xsYXBzZUVsZW1lbnQsIGNvbGxhcHNpbmcpO1xuICAgICAgICByZW1vdmVDbGFzcyhjb2xsYXBzZUVsZW1lbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIGNvbGxhcHNlRWxlbWVudFtzdHlsZV1baGVpZ2h0XSA9IGNvbGxhcHNlRWxlbWVudFtzY3JvbGxIZWlnaHRdICsgJ3B4JztcblxuICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChjb2xsYXBzZUVsZW1lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb2xsYXBzZUVsZW1lbnRbaXNBbmltYXRpbmddID0gZmFsc2U7XG4gICAgICAgICAgY29sbGFwc2VFbGVtZW50W3NldEF0dHJpYnV0ZV0oYXJpYUV4cGFuZGVkLCAndHJ1ZScpO1xuICAgICAgICAgIHRvZ2dsZVtzZXRBdHRyaWJ1dGVdKGFyaWFFeHBhbmRlZCwgJ3RydWUnKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyhjb2xsYXBzZUVsZW1lbnQsIGNvbGxhcHNpbmcpO1xuICAgICAgICAgIGFkZENsYXNzKGNvbGxhcHNlRWxlbWVudCwgY29tcG9uZW50KTtcbiAgICAgICAgICBhZGRDbGFzcyhjb2xsYXBzZUVsZW1lbnQsIHNob3dDbGFzcyk7XG4gICAgICAgICAgY29sbGFwc2VFbGVtZW50W3N0eWxlXVtoZWlnaHRdID0gJyc7XG4gICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChjb2xsYXBzZUVsZW1lbnQsIHNob3duRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNsb3NlQWN0aW9uID0gZnVuY3Rpb24gKGNvbGxhcHNlRWxlbWVudCwgdG9nZ2xlKSB7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBoaWRlRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIGNvbGxhcHNlRWxlbWVudFtpc0FuaW1hdGluZ10gPSB0cnVlO1xuICAgICAgICBjb2xsYXBzZUVsZW1lbnRbc3R5bGVdW2hlaWdodF0gPSBjb2xsYXBzZUVsZW1lbnRbc2Nyb2xsSGVpZ2h0XSArICdweCc7IC8vIHNldCBoZWlnaHQgZmlyc3RcbiAgICAgICAgcmVtb3ZlQ2xhc3MoY29sbGFwc2VFbGVtZW50LCBjb21wb25lbnQpO1xuICAgICAgICByZW1vdmVDbGFzcyhjb2xsYXBzZUVsZW1lbnQsIHNob3dDbGFzcyk7XG4gICAgICAgIGFkZENsYXNzKGNvbGxhcHNlRWxlbWVudCwgY29sbGFwc2luZyk7XG4gICAgICAgIGNvbGxhcHNlRWxlbWVudFtvZmZzZXRXaWR0aF07IC8vIGZvcmNlIHJlZmxvdyB0byBlbmFibGUgdHJhbnNpdGlvblxuICAgICAgICBjb2xsYXBzZUVsZW1lbnRbc3R5bGVdW2hlaWdodF0gPSAnMHB4JztcblxuICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChjb2xsYXBzZUVsZW1lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb2xsYXBzZUVsZW1lbnRbaXNBbmltYXRpbmddID0gZmFsc2U7XG4gICAgICAgICAgY29sbGFwc2VFbGVtZW50W3NldEF0dHJpYnV0ZV0oYXJpYUV4cGFuZGVkLCAnZmFsc2UnKTtcbiAgICAgICAgICB0b2dnbGVbc2V0QXR0cmlidXRlXShhcmlhRXhwYW5kZWQsICdmYWxzZScpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKGNvbGxhcHNlRWxlbWVudCwgY29sbGFwc2luZyk7XG4gICAgICAgICAgYWRkQ2xhc3MoY29sbGFwc2VFbGVtZW50LCBjb21wb25lbnQpO1xuICAgICAgICAgIGNvbGxhcHNlRWxlbWVudFtzdHlsZV1baGVpZ2h0XSA9ICcnO1xuICAgICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBoaWRkZW5FdmVudCwgY29tcG9uZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaHJlZiA9IGVsZW1lbnQuaHJlZiAmJiBlbGVtZW50W2dldEF0dHJpYnV0ZV0oJ2hyZWYnKSxcbiAgICAgICAgICBwYXJlbnQgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YVRhcmdldCksXG4gICAgICAgICAgaWQgPSBocmVmIHx8IChwYXJlbnQgJiYgcGFyZW50LmNoYXJBdCgwKSA9PT0gJyMnKSAmJiBwYXJlbnQ7XG4gICAgICAgIHJldHVybiBpZCAmJiBxdWVyeUVsZW1lbnQoaWQpO1xuICAgICAgfTtcblxuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgdGhpcy50b2dnbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZVtwcmV2ZW50RGVmYXVsdF0oKTtcbiAgICAgIGlmICghaGFzQ2xhc3MoY29sbGFwc2UsIHNob3dDbGFzcykpIHtcbiAgICAgICAgc2VsZi5zaG93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb2xsYXBzZVtpc0FuaW1hdGluZ10pIHJldHVybjtcbiAgICAgIGNsb3NlQWN0aW9uKGNvbGxhcHNlLCBlbGVtZW50KTtcbiAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGNvbGxhcHNlZCk7XG4gICAgfTtcbiAgICB0aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYWNjb3JkaW9uKSB7XG4gICAgICAgIGFjdGl2ZUNvbGxhcHNlID0gcXVlcnlFbGVtZW50KCcuJyArIGNvbXBvbmVudCArICcuJyArIHNob3dDbGFzcywgYWNjb3JkaW9uKTtcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUNvbGxhcHNlICYmIChxdWVyeUVsZW1lbnQoJ1snICsgZGF0YVRhcmdldCArICc9XCIjJyArIGFjdGl2ZUNvbGxhcHNlLmlkICsgJ1wiXScsIGFjY29yZGlvbikgfHxcbiAgICAgICAgICBxdWVyeUVsZW1lbnQoJ1tocmVmPVwiIycgKyBhY3RpdmVDb2xsYXBzZS5pZCArICdcIl0nLCBhY2NvcmRpb24pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb2xsYXBzZVtpc0FuaW1hdGluZ10gfHwgYWN0aXZlQ29sbGFwc2UgJiYgIWFjdGl2ZUNvbGxhcHNlW2lzQW5pbWF0aW5nXSkge1xuICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVDb2xsYXBzZSAhPT0gY29sbGFwc2UpIHtcbiAgICAgICAgICBjbG9zZUFjdGlvbihhY3RpdmVDb2xsYXBzZSwgYWN0aXZlRWxlbWVudCk7XG4gICAgICAgICAgYWRkQ2xhc3MoYWN0aXZlRWxlbWVudCwgY29sbGFwc2VkKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVuQWN0aW9uKGNvbGxhcHNlLCBlbGVtZW50KTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY29sbGFwc2VkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gaW5pdFxuICAgIGlmICghKHN0cmluZ0NvbGxhcHNlIGluIGVsZW1lbnQpKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgICBvbihlbGVtZW50LCBjbGlja0V2ZW50LCBzZWxmLnRvZ2dsZSk7XG4gICAgfVxuICAgIGNvbGxhcHNlID0gZ2V0VGFyZ2V0KCk7XG4gICAgY29sbGFwc2VbaXNBbmltYXRpbmddID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBpdCB3aWxsIHByZXZlbnQgY2xpY2sgaGFuZGxlcnMgIFxuICAgIGFjY29yZGlvbiA9IHF1ZXJ5RWxlbWVudChvcHRpb25zLnBhcmVudCkgfHwgYWNjb3JkaW9uRGF0YSAmJiBnZXRDbG9zZXN0KGVsZW1lbnQsIGFjY29yZGlvbkRhdGEpO1xuICAgIGVsZW1lbnRbc3RyaW5nQ29sbGFwc2VdID0gc2VsZjtcbiAgfTtcblxuICAvLyBDT0xMQVBTRSBEQVRBIEFQSVxuICAvLyA9PT09PT09PT09PT09PT09PVxuICBzdXBwb3J0c1twdXNoXShbc3RyaW5nQ29sbGFwc2UsIENvbGxhcHNlLCAnWycgKyBkYXRhVG9nZ2xlICsgJz1cImNvbGxhcHNlXCJdJ10pO1xuXG5cbiAgLyogTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgRHJvcGRvd25cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRFJPUERPV04gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09XG4gIHZhciBEcm9wZG93biA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb24pIHtcblxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgLy8gc2V0IG9wdGlvblxuICAgIHRoaXMucGVyc2lzdCA9IG9wdGlvbiA9PT0gdHJ1ZSB8fCBlbGVtZW50W2dldEF0dHJpYnV0ZV0oJ2RhdGEtcGVyc2lzdCcpID09PSAndHJ1ZScgfHwgZmFsc2U7XG5cbiAgICAvLyBjb25zdGFudHMsIGV2ZW50IHRhcmdldHMsIHN0cmluZ3NcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBjaGlsZHJlbiA9ICdjaGlsZHJlbicsXG4gICAgICBwYXJlbnQgPSBlbGVtZW50W3BhcmVudE5vZGVdLFxuICAgICAgY29tcG9uZW50ID0gJ2Ryb3Bkb3duJyxcbiAgICAgIG9wZW4gPSAnb3BlbicsXG4gICAgICByZWxhdGVkVGFyZ2V0ID0gbnVsbCxcbiAgICAgIG1lbnUgPSBxdWVyeUVsZW1lbnQoJy5kcm9wZG93bi1tZW51JywgcGFyZW50KSxcbiAgICAgIG1lbnVJdGVtcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZXQgPSBtZW51W2NoaWxkcmVuXSxcbiAgICAgICAgICBuZXdTZXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRbbGVuZ3RoXTsgaSsrKSB7XG4gICAgICAgICAgc2V0W2ldW2NoaWxkcmVuXVtsZW5ndGhdICYmIChzZXRbaV1bY2hpbGRyZW5dWzBdLnRhZ05hbWUgPT09ICdBJyAmJiBuZXdTZXRbcHVzaF0oc2V0W2ldW2NoaWxkcmVuXVswXSkpO1xuICAgICAgICAgIHNldFtpXS50YWdOYW1lID09PSAnQScgJiYgbmV3U2V0W3B1c2hdKHNldFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NldDtcbiAgICAgIH0pKCksXG5cbiAgICAgIC8vIHByZXZlbnREZWZhdWx0IG9uIGVtcHR5IGFuY2hvciBsaW5rc1xuICAgICAgcHJldmVudEVtcHR5QW5jaG9yID0gZnVuY3Rpb24gKGFuY2hvcikge1xuICAgICAgICAoYW5jaG9yLmhyZWYgJiYgYW5jaG9yLmhyZWYuc2xpY2UoLTEpID09PSAnIycgfHwgYW5jaG9yW3BhcmVudE5vZGVdICYmIGFuY2hvcltwYXJlbnROb2RlXS5ocmVmICYmXG4gICAgICAgICAgYW5jaG9yW3BhcmVudE5vZGVdLmhyZWYuc2xpY2UoLTEpID09PSAnIycpICYmIHRoaXNbcHJldmVudERlZmF1bHRdKCk7XG4gICAgICB9LFxuXG4gICAgICAvLyB0b2dnbGUgZGlzbWlzc2libGUgZXZlbnRzXG4gICAgICB0b2dnbGVEaXNtaXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHlwZSA9IGVsZW1lbnRbb3Blbl0gPyBvbiA6IG9mZjtcbiAgICAgICAgdHlwZShET0MsIGNsaWNrRXZlbnQsIGRpc21pc3NIYW5kbGVyKTtcbiAgICAgICAgdHlwZShET0MsIGtleWRvd25FdmVudCwgcHJldmVudFNjcm9sbCk7XG4gICAgICAgIHR5cGUoRE9DLCBrZXl1cEV2ZW50LCBrZXlIYW5kbGVyKTtcbiAgICAgICAgdHlwZShET0MsIGZvY3VzRXZlbnQsIGRpc21pc3NIYW5kbGVyLCB0cnVlKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIGhhbmRsZXJzXG4gICAgICBkaXNtaXNzSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBldmVudFRhcmdldCA9IGVbdGFyZ2V0XSxcbiAgICAgICAgICBoYXNEYXRhID0gZXZlbnRUYXJnZXQgJiYgKGV2ZW50VGFyZ2V0W2dldEF0dHJpYnV0ZV0oZGF0YVRvZ2dsZSkgfHxcbiAgICAgICAgICAgIGV2ZW50VGFyZ2V0W3BhcmVudE5vZGVdICYmIGdldEF0dHJpYnV0ZSBpbiBldmVudFRhcmdldFtwYXJlbnROb2RlXSAmJlxuICAgICAgICAgICAgZXZlbnRUYXJnZXRbcGFyZW50Tm9kZV1bZ2V0QXR0cmlidXRlXShkYXRhVG9nZ2xlKSk7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IGZvY3VzRXZlbnQgJiYgKGV2ZW50VGFyZ2V0ID09PSBlbGVtZW50IHx8IGV2ZW50VGFyZ2V0ID09PSBtZW51IHx8IG1lbnVbY29udGFpbnNdKGV2ZW50VGFyZ2V0KSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChldmVudFRhcmdldCA9PT0gbWVudSB8fCBtZW51W2NvbnRhaW5zXShldmVudFRhcmdldCkpICYmIChzZWxmLnBlcnNpc3QgfHwgaGFzRGF0YSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldCA9IGV2ZW50VGFyZ2V0ID09PSBlbGVtZW50IHx8IGVsZW1lbnRbY29udGFpbnNdKGV2ZW50VGFyZ2V0KSA/IGVsZW1lbnQgOiBudWxsO1xuICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ZW50RW1wdHlBbmNob3IuY2FsbChlLCBldmVudFRhcmdldCk7XG4gICAgICB9LFxuICAgICAgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICAgIHNob3coKTtcbiAgICAgICAgcHJldmVudEVtcHR5QW5jaG9yLmNhbGwoZSwgZVt0YXJnZXRdKTtcbiAgICAgIH0sXG4gICAgICBwcmV2ZW50U2Nyb2xsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGtleSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlO1xuICAgICAgICBpZiAoa2V5ID09PSAzOCB8fCBrZXkgPT09IDQwKSB7XG4gICAgICAgICAgZVtwcmV2ZW50RGVmYXVsdF0oKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGtleUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGUsXG4gICAgICAgICAgYWN0aXZlSXRlbSA9IERPQy5hY3RpdmVFbGVtZW50LFxuICAgICAgICAgIGlkeCA9IG1lbnVJdGVtc1tpbmRleE9mXShhY3RpdmVJdGVtKSxcbiAgICAgICAgICBpc1NhbWVFbGVtZW50ID0gYWN0aXZlSXRlbSA9PT0gZWxlbWVudCxcbiAgICAgICAgICBpc0luc2lkZU1lbnUgPSBtZW51W2NvbnRhaW5zXShhY3RpdmVJdGVtKSxcbiAgICAgICAgICBpc01lbnVJdGVtID0gYWN0aXZlSXRlbVtwYXJlbnROb2RlXSA9PT0gbWVudSB8fCBhY3RpdmVJdGVtW3BhcmVudE5vZGVdW3BhcmVudE5vZGVdID09PSBtZW51O1xuXG4gICAgICAgIGlmIChpc01lbnVJdGVtKSB7IC8vIG5hdmlnYXRlIHVwIHwgZG93blxuICAgICAgICAgIGlkeCA9IGlzU2FtZUVsZW1lbnQgPyAwIDpcbiAgICAgICAgICAgIGtleSA9PT0gMzggPyAoaWR4ID4gMSA/IGlkeCAtIDEgOiAwKSA6XG4gICAgICAgICAgICBrZXkgPT09IDQwID8gKGlkeCA8IG1lbnVJdGVtc1tsZW5ndGhdIC0gMSA/IGlkeCArIDEgOiBpZHgpIDogaWR4O1xuICAgICAgICAgIG1lbnVJdGVtc1tpZHhdICYmIHNldEZvY3VzKG1lbnVJdGVtc1tpZHhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1lbnVJdGVtc1tsZW5ndGhdICYmIGlzTWVudUl0ZW0gLy8gbWVudSBoYXMgaXRlbXNcbiAgICAgICAgICAgIHx8XG4gICAgICAgICAgICAhbWVudUl0ZW1zW2xlbmd0aF0gJiYgKGlzSW5zaWRlTWVudSB8fCBpc1NhbWVFbGVtZW50KSAvLyBtZW51IG1pZ2h0IGJlIGEgZm9ybVxuICAgICAgICAgICAgfHxcbiAgICAgICAgICAgICFpc0luc2lkZU1lbnUpIC8vIG9yIHRoZSBmb2N1c2VkIGVsZW1lbnQgaXMgbm90IGluIHRoZSBtZW51IGF0IGFsbFxuICAgICAgICAgICYmXG4gICAgICAgICAgZWxlbWVudFtvcGVuXSAmJiBrZXkgPT09IDI3IC8vIG1lbnUgbXVzdCBiZSBvcGVuXG4gICAgICAgICkge1xuICAgICAgICAgIHNlbGYudG9nZ2xlKCk7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgICAgc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIHNob3dFdmVudCwgY29tcG9uZW50LCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgYWRkQ2xhc3MobWVudSwgc2hvd0NsYXNzKTtcbiAgICAgICAgYWRkQ2xhc3MocGFyZW50LCBzaG93Q2xhc3MpO1xuICAgICAgICBlbGVtZW50W3NldEF0dHJpYnV0ZV0oYXJpYUV4cGFuZGVkLCB0cnVlKTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIHNob3duRXZlbnQsIGNvbXBvbmVudCwgcmVsYXRlZFRhcmdldCk7XG4gICAgICAgIGVsZW1lbnRbb3Blbl0gPSB0cnVlO1xuICAgICAgICBvZmYoZWxlbWVudCwgY2xpY2tFdmVudCwgY2xpY2tIYW5kbGVyKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2V0Rm9jdXMobWVudVtnZXRFbGVtZW50c0J5VGFnTmFtZV0oJ0lOUFVUJylbMF0gfHwgZWxlbWVudCk7IC8vIGZvY3VzIHRoZSBmaXJzdCBpbnB1dCBpdGVtIHwgZWxlbWVudFxuICAgICAgICAgIHRvZ2dsZURpc21pc3MoKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICB9LFxuICAgICAgaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChwYXJlbnQsIGhpZGVFdmVudCwgY29tcG9uZW50LCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MobWVudSwgc2hvd0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MocGFyZW50LCBzaG93Q2xhc3MpO1xuICAgICAgICBlbGVtZW50W3NldEF0dHJpYnV0ZV0oYXJpYUV4cGFuZGVkLCBmYWxzZSk7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwocGFyZW50LCBoaWRkZW5FdmVudCwgY29tcG9uZW50LCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgZWxlbWVudFtvcGVuXSA9IGZhbHNlO1xuICAgICAgICB0b2dnbGVEaXNtaXNzKCk7XG4gICAgICAgIHNldEZvY3VzKGVsZW1lbnQpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvbihlbGVtZW50LCBjbGlja0V2ZW50LCBjbGlja0hhbmRsZXIpO1xuICAgICAgICB9LCAxKTtcbiAgICAgIH07XG5cbiAgICAvLyBzZXQgaW5pdGlhbCBzdGF0ZSB0byBjbG9zZWRcbiAgICBlbGVtZW50W29wZW5dID0gZmFsc2U7XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kc1xuICAgIHRoaXMudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGhhc0NsYXNzKHBhcmVudCwgc2hvd0NsYXNzKSAmJiBlbGVtZW50W29wZW5dKSB7XG4gICAgICAgIGhpZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gaW5pdFxuICAgIGlmICghKHN0cmluZ0Ryb3Bkb3duIGluIGVsZW1lbnQpKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgICAhdGFiaW5kZXggaW4gbWVudSAmJiBtZW51W3NldEF0dHJpYnV0ZV0odGFiaW5kZXgsICcwJyk7IC8vIEZpeCBvbmJsdXIgb24gQ2hyb21lIHwgU2FmYXJpXG4gICAgICBvbihlbGVtZW50LCBjbGlja0V2ZW50LCBjbGlja0hhbmRsZXIpO1xuICAgIH1cblxuICAgIGVsZW1lbnRbc3RyaW5nRHJvcGRvd25dID0gc2VsZjtcbiAgfTtcblxuICAvLyBEUk9QRE9XTiBEQVRBIEFQSVxuICAvLyA9PT09PT09PT09PT09PT09PVxuICBzdXBwb3J0c1twdXNoXShbc3RyaW5nRHJvcGRvd24sIERyb3Bkb3duLCAnWycgKyBkYXRhVG9nZ2xlICsgJz1cImRyb3Bkb3duXCJdJ10pO1xuXG5cbiAgLyogTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgTW9kYWxcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gTU9EQUwgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT1cbiAgdmFyIE1vZGFsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHsgLy8gZWxlbWVudCBjYW4gYmUgdGhlIG1vZGFsL3RyaWdnZXJpbmcgYnV0dG9uXG5cbiAgICAvLyB0aGUgbW9kYWwgKGJvdGggSmF2YVNjcmlwdCAvIERBVEEgQVBJIGluaXQpIC8gdHJpZ2dlcmluZyBidXR0b24gZWxlbWVudCAoREFUQSBBUEkpXG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcblxuICAgIC8vIHN0cmluZ3NcbiAgICB2YXIgY29tcG9uZW50ID0gJ21vZGFsJyxcbiAgICAgIHN0YXRpY1N0cmluZyA9ICdzdGF0aWMnLFxuICAgICAgbW9kYWxUcmlnZ2VyID0gJ21vZGFsVHJpZ2dlcicsXG4gICAgICBwYWRkaW5nUmlnaHQgPSAncGFkZGluZ1JpZ2h0JyxcbiAgICAgIG1vZGFsQmFja2Ryb3BTdHJpbmcgPSAnbW9kYWwtYmFja2Ryb3AnLFxuICAgICAgaXNBbmltYXRpbmcgPSAnaXNBbmltYXRpbmcnLFxuICAgICAgLy8gZGV0ZXJtaW5lIG1vZGFsLCB0cmlnZ2VyaW5nIGVsZW1lbnRcbiAgICAgIGJ0bkNoZWNrID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFUYXJnZXQpIHx8IGVsZW1lbnRbZ2V0QXR0cmlidXRlXSgnaHJlZicpLFxuICAgICAgY2hlY2tNb2RhbCA9IHF1ZXJ5RWxlbWVudChidG5DaGVjayksXG4gICAgICBtb2RhbCA9IGhhc0NsYXNzKGVsZW1lbnQsIGNvbXBvbmVudCkgPyBlbGVtZW50IDogY2hlY2tNb2RhbDtcblxuICAgIGlmIChoYXNDbGFzcyhlbGVtZW50LCBjb21wb25lbnQpKSB7XG4gICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICB9IC8vIG1vZGFsIGlzIG5vdyBpbmRlcGVuZGVudCBvZiBpdCdzIHRyaWdnZXJpbmcgZWxlbWVudFxuXG4gICAgaWYgKCFtb2RhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaW52YWxpZGF0ZVxuXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXNba2V5Ym9hcmRdID0gb3B0aW9uc1trZXlib2FyZF0gPT09IGZhbHNlIHx8IG1vZGFsW2dldEF0dHJpYnV0ZV0oZGF0YUtleWJvYXJkKSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdHJ1ZTtcbiAgICB0aGlzW2JhY2tkcm9wXSA9IG9wdGlvbnNbYmFja2Ryb3BdID09PSBzdGF0aWNTdHJpbmcgfHwgbW9kYWxbZ2V0QXR0cmlidXRlXShkYXRhYmFja2Ryb3ApID09PSBzdGF0aWNTdHJpbmcgPyBzdGF0aWNTdHJpbmcgOiB0cnVlO1xuICAgIHRoaXNbYmFja2Ryb3BdID0gb3B0aW9uc1tiYWNrZHJvcF0gPT09IGZhbHNlIHx8IG1vZGFsW2dldEF0dHJpYnV0ZV0oZGF0YWJhY2tkcm9wKSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdGhpc1tiYWNrZHJvcF07XG4gICAgdGhpc1thbmltYXRpb25dID0gaGFzQ2xhc3MobW9kYWwsICdmYWRlJykgPyB0cnVlIDogZmFsc2U7XG4gICAgdGhpc1tjb250ZW50XSA9IG9wdGlvbnNbY29udGVudF07IC8vIEphdmFTY3JpcHQgb25seVxuXG4gICAgLy8gc2V0IGFuIGluaXRpYWwgc3RhdGUgb2YgdGhlIG1vZGFsXG4gICAgbW9kYWxbaXNBbmltYXRpbmddID0gZmFsc2U7XG5cbiAgICAvLyBiaW5kLCBjb25zdGFudHMsIGV2ZW50IHRhcmdldHMgYW5kIG90aGVyIHZhcnNcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICByZWxhdGVkVGFyZ2V0ID0gbnVsbCxcbiAgICAgIGJvZHlJc092ZXJmbG93aW5nLCBzY3JvbGxCYXJXaWR0aCwgb3ZlcmxheSwgb3ZlcmxheURlbGF5LCBtb2RhbFRpbWVyLFxuXG4gICAgICAvLyBhbHNvIGZpbmQgZml4ZWQtdG9wIC8gZml4ZWQtYm90dG9tIGl0ZW1zXG4gICAgICBmaXhlZEl0ZW1zID0gZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShIVE1MLCBmaXhlZFRvcCkuY29uY2F0KGdldEVsZW1lbnRzQnlDbGFzc05hbWUoSFRNTCwgZml4ZWRCb3R0b20pKSxcblxuICAgICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgICBnZXRXaW5kb3dXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGh0bWxSZWN0ID0gSFRNTFtnZXRCb3VuZGluZ0NsaWVudFJlY3RdKCk7XG4gICAgICAgIHJldHVybiBnbG9iYWxPYmplY3RbaW5uZXJXaWR0aF0gfHwgKGh0bWxSZWN0W3JpZ2h0XSAtIE1hdGguYWJzKGh0bWxSZWN0W2xlZnRdKSk7XG4gICAgICB9LFxuICAgICAgc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9keVN0eWxlID0gZ2xvYmFsT2JqZWN0W2dldENvbXB1dGVkU3R5bGVdKERPQ1tib2R5XSksXG4gICAgICAgICAgYm9keVBhZCA9IHBhcnNlSW50KChib2R5U3R5bGVbcGFkZGluZ1JpZ2h0XSksIDEwKSxcbiAgICAgICAgICBpdGVtUGFkO1xuICAgICAgICBpZiAoYm9keUlzT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgICBET0NbYm9keV1bc3R5bGVdW3BhZGRpbmdSaWdodF0gPSAoYm9keVBhZCArIHNjcm9sbEJhcldpZHRoKSArICdweCc7XG4gICAgICAgICAgbW9kYWxbc3R5bGVdW3BhZGRpbmdSaWdodF0gPSBzY3JvbGxCYXJXaWR0aCArICdweCc7XG4gICAgICAgICAgaWYgKGZpeGVkSXRlbXNbbGVuZ3RoXSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXhlZEl0ZW1zW2xlbmd0aF07IGkrKykge1xuICAgICAgICAgICAgICBpdGVtUGFkID0gZ2xvYmFsT2JqZWN0W2dldENvbXB1dGVkU3R5bGVdKGZpeGVkSXRlbXNbaV0pW3BhZGRpbmdSaWdodF07XG4gICAgICAgICAgICAgIGZpeGVkSXRlbXNbaV1bc3R5bGVdW3BhZGRpbmdSaWdodF0gPSAocGFyc2VJbnQoaXRlbVBhZCkgKyBzY3JvbGxCYXJXaWR0aCkgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBET0NbYm9keV1bc3R5bGVdW3BhZGRpbmdSaWdodF0gPSAnJztcbiAgICAgICAgbW9kYWxbc3R5bGVdW3BhZGRpbmdSaWdodF0gPSAnJztcbiAgICAgICAgaWYgKGZpeGVkSXRlbXNbbGVuZ3RoXSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZml4ZWRJdGVtc1tsZW5ndGhdOyBpKyspIHtcbiAgICAgICAgICAgIGZpeGVkSXRlbXNbaV1bc3R5bGVdW3BhZGRpbmdSaWdodF0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZWFzdXJlU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkgeyAvLyB0aHggd2Fsc2hcbiAgICAgICAgdmFyIHNjcm9sbERpdiA9IERPQ1tjcmVhdGVFbGVtZW50XSgnZGl2JyksXG4gICAgICAgICAgd2lkdGhWYWx1ZTtcbiAgICAgICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9IGNvbXBvbmVudCArICctc2Nyb2xsYmFyLW1lYXN1cmUnOyAvLyB0aGlzIGlzIGhlcmUgdG8gc3RheVxuICAgICAgICBET0NbYm9keV1bYXBwZW5kQ2hpbGRdKHNjcm9sbERpdik7XG4gICAgICAgIHdpZHRoVmFsdWUgPSBzY3JvbGxEaXZbb2Zmc2V0V2lkdGhdIC0gc2Nyb2xsRGl2W2NsaWVudFdpZHRoXTtcbiAgICAgICAgRE9DW2JvZHldLnJlbW92ZUNoaWxkKHNjcm9sbERpdik7XG4gICAgICAgIHJldHVybiB3aWR0aFZhbHVlO1xuICAgICAgfSxcbiAgICAgIGNoZWNrU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBib2R5SXNPdmVyZmxvd2luZyA9IERPQ1tib2R5XVtjbGllbnRXaWR0aF0gPCBnZXRXaW5kb3dXaWR0aCgpO1xuICAgICAgICBzY3JvbGxCYXJXaWR0aCA9IG1lYXN1cmVTY3JvbGxiYXIoKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3T3ZlcmxheSA9IERPQ1tjcmVhdGVFbGVtZW50XSgnZGl2Jyk7XG4gICAgICAgIG92ZXJsYXkgPSBxdWVyeUVsZW1lbnQoJy4nICsgbW9kYWxCYWNrZHJvcFN0cmluZyk7XG5cbiAgICAgICAgaWYgKG92ZXJsYXkgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdPdmVybGF5W3NldEF0dHJpYnV0ZV0oJ2NsYXNzJywgbW9kYWxCYWNrZHJvcFN0cmluZyArIChzZWxmW2FuaW1hdGlvbl0gPyAnIGZhZGUnIDogJycpKTtcbiAgICAgICAgICBvdmVybGF5ID0gbmV3T3ZlcmxheTtcbiAgICAgICAgICBET0NbYm9keV1bYXBwZW5kQ2hpbGRdKG92ZXJsYXkpO1xuICAgICAgICB9XG4gICAgICAgIG1vZGFsT3ZlcmxheSA9IDE7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb3ZlcmxheSA9IHF1ZXJ5RWxlbWVudCgnLicgKyBtb2RhbEJhY2tkcm9wU3RyaW5nKTtcbiAgICAgICAgaWYgKG92ZXJsYXkgJiYgb3ZlcmxheSAhPT0gbnVsbCAmJiB0eXBlb2Ygb3ZlcmxheSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBtb2RhbE92ZXJsYXkgPSAwO1xuICAgICAgICAgIERPQ1tib2R5XS5yZW1vdmVDaGlsZChvdmVybGF5KTtcbiAgICAgICAgICBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIHRyaWdnZXJzXG4gICAgICB0cmlnZ2VyU2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0Rm9jdXMobW9kYWwpO1xuICAgICAgICBtb2RhbFtpc0FuaW1hdGluZ10gPSBmYWxzZTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChtb2RhbCwgc2hvd25FdmVudCwgY29tcG9uZW50LCByZWxhdGVkVGFyZ2V0KTtcblxuICAgICAgICBvbihnbG9iYWxPYmplY3QsIHJlc2l6ZUV2ZW50LCBzZWxmLnVwZGF0ZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgICAgICBvbihtb2RhbCwgY2xpY2tFdmVudCwgZGlzbWlzc0hhbmRsZXIpO1xuICAgICAgICBvbihET0MsIGtleWRvd25FdmVudCwga2V5SGFuZGxlcik7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlckhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1vZGFsW3N0eWxlXS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIGVsZW1lbnQgJiYgKHNldEZvY3VzKGVsZW1lbnQpKTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChtb2RhbCwgaGlkZGVuRXZlbnQsIGNvbXBvbmVudCk7XG5cbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWdldEVsZW1lbnRzQnlDbGFzc05hbWUoRE9DLCBjb21wb25lbnQgKyAnICcgKyBzaG93Q2xhc3MpWzBdKSB7XG4gICAgICAgICAgICByZXNldFNjcm9sbGJhcigpO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoRE9DW2JvZHldLCBjb21wb25lbnQgKyAnLW9wZW4nKTtcbiAgICAgICAgICAgIG92ZXJsYXkgJiYgaGFzQ2xhc3Mob3ZlcmxheSwgJ2ZhZGUnKSA/IChyZW1vdmVDbGFzcyhvdmVybGF5LCBzaG93Q2xhc3MpLCBlbXVsYXRlVHJhbnNpdGlvbkVuZChvdmVybGF5LCByZW1vdmVPdmVybGF5KSkgOlxuICAgICAgICAgICAgICByZW1vdmVPdmVybGF5KCk7XG5cbiAgICAgICAgICAgIG9mZihnbG9iYWxPYmplY3QsIHJlc2l6ZUV2ZW50LCBzZWxmLnVwZGF0ZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgICAgICAgICAgb2ZmKG1vZGFsLCBjbGlja0V2ZW50LCBkaXNtaXNzSGFuZGxlcik7XG4gICAgICAgICAgICBvZmYoRE9DLCBrZXlkb3duRXZlbnQsIGtleUhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSgpKTtcbiAgICAgICAgbW9kYWxbaXNBbmltYXRpbmddID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgLy8gaGFuZGxlcnNcbiAgICAgIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChtb2RhbFtpc0FuaW1hdGluZ10pIHJldHVybjtcblxuICAgICAgICB2YXIgY2xpY2tUYXJnZXQgPSBlW3RhcmdldF07XG4gICAgICAgIGNsaWNrVGFyZ2V0ID0gY2xpY2tUYXJnZXRbaGFzQXR0cmlidXRlXShkYXRhVGFyZ2V0KSB8fCBjbGlja1RhcmdldFtoYXNBdHRyaWJ1dGVdKCdocmVmJykgPyBjbGlja1RhcmdldCA6IGNsaWNrVGFyZ2V0W3BhcmVudE5vZGVdO1xuICAgICAgICBpZiAoY2xpY2tUYXJnZXQgPT09IGVsZW1lbnQgJiYgIWhhc0NsYXNzKG1vZGFsLCBzaG93Q2xhc3MpKSB7XG4gICAgICAgICAgbW9kYWxbbW9kYWxUcmlnZ2VyXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICAgICAgc2VsZi5zaG93KCk7XG4gICAgICAgICAgZVtwcmV2ZW50RGVmYXVsdF0oKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGtleUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAobW9kYWxbaXNBbmltYXRpbmddKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHNlbGZba2V5Ym9hcmRdICYmIGUud2hpY2ggPT0gMjcgJiYgaGFzQ2xhc3MobW9kYWwsIHNob3dDbGFzcykpIHtcbiAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc21pc3NIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKG1vZGFsW2lzQW5pbWF0aW5nXSkgcmV0dXJuO1xuICAgICAgICB2YXIgY2xpY2tUYXJnZXQgPSBlW3RhcmdldF07XG5cbiAgICAgICAgaWYgKGhhc0NsYXNzKG1vZGFsLCBzaG93Q2xhc3MpICYmIChjbGlja1RhcmdldFtwYXJlbnROb2RlXVtnZXRBdHRyaWJ1dGVdKGRhdGFEaXNtaXNzKSA9PT0gY29tcG9uZW50IHx8XG4gICAgICAgICAgICBjbGlja1RhcmdldFtnZXRBdHRyaWJ1dGVdKGRhdGFEaXNtaXNzKSA9PT0gY29tcG9uZW50IHx8XG4gICAgICAgICAgICBjbGlja1RhcmdldCA9PT0gbW9kYWwgJiYgc2VsZltiYWNrZHJvcF0gIT09IHN0YXRpY1N0cmluZykpIHtcbiAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICBlW3ByZXZlbnREZWZhdWx0XSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICB0aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChoYXNDbGFzcyhtb2RhbCwgc2hvd0NsYXNzKSkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGhhc0NsYXNzKG1vZGFsLCBzaG93Q2xhc3MpIHx8IG1vZGFsW2lzQW5pbWF0aW5nXSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KG1vZGFsVGltZXIpO1xuICAgICAgbW9kYWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBtb2RhbFtpc0FuaW1hdGluZ10gPSB0cnVlO1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKG1vZGFsLCBzaG93RXZlbnQsIGNvbXBvbmVudCwgcmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICAgLy8gd2UgZWxlZ2FudGx5IGhpZGUgYW55IG9wZW5lZCBtb2RhbFxuICAgICAgICB2YXIgY3VycmVudE9wZW4gPSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lKERPQywgY29tcG9uZW50ICsgJyAnICsgc2hvd0NsYXNzKVswXTtcbiAgICAgICAgaWYgKGN1cnJlbnRPcGVuICYmIGN1cnJlbnRPcGVuICE9PSBtb2RhbCkge1xuICAgICAgICAgIG1vZGFsVHJpZ2dlciBpbiBjdXJyZW50T3BlbiAmJiBjdXJyZW50T3Blblttb2RhbFRyaWdnZXJdW3N0cmluZ01vZGFsXS5oaWRlKCk7XG4gICAgICAgICAgc3RyaW5nTW9kYWwgaW4gY3VycmVudE9wZW4gJiYgY3VycmVudE9wZW5bc3RyaW5nTW9kYWxdLmhpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmW2JhY2tkcm9wXSkge1xuICAgICAgICAgICFtb2RhbE92ZXJsYXkgJiYgIW92ZXJsYXkgJiYgY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJsYXkgJiYgIWhhc0NsYXNzKG92ZXJsYXksIHNob3dDbGFzcykpIHtcbiAgICAgICAgICBvdmVybGF5W29mZnNldFdpZHRoXTsgLy8gZm9yY2UgcmVmbG93IHRvIGVuYWJsZSB0cmFzaXRpb25cbiAgICAgICAgICBvdmVybGF5RGVsYXkgPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChvdmVybGF5KTtcbiAgICAgICAgICBhZGRDbGFzcyhvdmVybGF5LCBzaG93Q2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbW9kYWxbc3R5bGVdLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgICAgY2hlY2tTY3JvbGxiYXIoKTtcbiAgICAgICAgICBzZXRTY3JvbGxiYXIoKTtcblxuICAgICAgICAgIGFkZENsYXNzKERPQ1tib2R5XSwgY29tcG9uZW50ICsgJy1vcGVuJyk7XG4gICAgICAgICAgYWRkQ2xhc3MobW9kYWwsIHNob3dDbGFzcyk7XG4gICAgICAgICAgbW9kYWxbc2V0QXR0cmlidXRlXShhcmlhSGlkZGVuLCBmYWxzZSk7XG5cbiAgICAgICAgICBoYXNDbGFzcyhtb2RhbCwgJ2ZhZGUnKSA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKG1vZGFsLCB0cmlnZ2VyU2hvdykgOiB0cmlnZ2VyU2hvdygpO1xuICAgICAgICB9LCBzdXBwb3J0VHJhbnNpdGlvbnMgJiYgb3ZlcmxheSAmJiBvdmVybGF5RGVsYXkgPyBvdmVybGF5RGVsYXkgOiAxKTtcbiAgICAgIH0sIDEpO1xuICAgIH07XG4gICAgdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1vZGFsW2lzQW5pbWF0aW5nXSB8fCAhaGFzQ2xhc3MobW9kYWwsIHNob3dDbGFzcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNsZWFyVGltZW91dChtb2RhbFRpbWVyKTtcbiAgICAgIG1vZGFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbW9kYWxbaXNBbmltYXRpbmddID0gdHJ1ZTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChtb2RhbCwgaGlkZUV2ZW50LCBjb21wb25lbnQpO1xuICAgICAgICBvdmVybGF5ID0gcXVlcnlFbGVtZW50KCcuJyArIG1vZGFsQmFja2Ryb3BTdHJpbmcpO1xuICAgICAgICBvdmVybGF5RGVsYXkgPSBvdmVybGF5ICYmIGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KG92ZXJsYXkpO1xuXG4gICAgICAgIHJlbW92ZUNsYXNzKG1vZGFsLCBzaG93Q2xhc3MpO1xuICAgICAgICBtb2RhbFtzZXRBdHRyaWJ1dGVdKGFyaWFIaWRkZW4sIHRydWUpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGhhc0NsYXNzKG1vZGFsLCAnZmFkZScpID8gZW11bGF0ZVRyYW5zaXRpb25FbmQobW9kYWwsIHRyaWdnZXJIaWRlKSA6IHRyaWdnZXJIaWRlKCk7XG4gICAgICAgIH0sIHN1cHBvcnRUcmFuc2l0aW9ucyAmJiBvdmVybGF5ICYmIG92ZXJsYXlEZWxheSA/IG92ZXJsYXlEZWxheSA6IDIpO1xuICAgICAgfSwgMilcbiAgICB9O1xuICAgIHRoaXMuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICBxdWVyeUVsZW1lbnQoJy4nICsgY29tcG9uZW50ICsgJy1jb250ZW50JywgbW9kYWwpW2lubmVySFRNTF0gPSBjb250ZW50O1xuICAgIH07XG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaGFzQ2xhc3MobW9kYWwsIHNob3dDbGFzcykpIHtcbiAgICAgICAgY2hlY2tTY3JvbGxiYXIoKTtcbiAgICAgICAgc2V0U2Nyb2xsYmFyKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGluaXRcbiAgICAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyBvdmVyIGFuZCBvdmVyXG4gICAgLy8gbW9kYWwgaXMgaW5kZXBlbmRlbnQgb2YgYSB0cmlnZ2VyaW5nIGVsZW1lbnRcbiAgICBpZiAoISFlbGVtZW50ICYmICEoc3RyaW5nTW9kYWwgaW4gZWxlbWVudCkpIHtcbiAgICAgIG9uKGVsZW1lbnQsIGNsaWNrRXZlbnQsIGNsaWNrSGFuZGxlcik7XG4gICAgfVxuICAgIGlmICghIXNlbGZbY29udGVudF0pIHtcbiAgICAgIHNlbGYuc2V0Q29udGVudChzZWxmW2NvbnRlbnRdKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnRbc3RyaW5nTW9kYWxdID0gc2VsZjtcbiAgICAgIG1vZGFsW21vZGFsVHJpZ2dlcl0gPSBlbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RhbFtzdHJpbmdNb2RhbF0gPSBzZWxmO1xuICAgIH1cbiAgfTtcblxuICAvLyBEQVRBIEFQSVxuICBzdXBwb3J0c1twdXNoXShbc3RyaW5nTW9kYWwsIE1vZGFsLCAnWycgKyBkYXRhVG9nZ2xlICsgJz1cIm1vZGFsXCJdJ10pO1xuXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IFBvcG92ZXJcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gUE9QT1ZFUiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PVxuICB2YXIgUG9wb3ZlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG5cbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcblxuICAgIC8vIHNldCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciB0cmlnZ2VyRGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhVHJpZ2dlciksIC8vIGNsaWNrIC8gaG92ZXIgLyBmb2N1c1xuICAgICAgYW5pbWF0aW9uRGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhQW5pbWF0aW9uKSwgLy8gdHJ1ZSAvIGZhbHNlXG4gICAgICBwbGFjZW1lbnREYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFQbGFjZW1lbnQpLFxuICAgICAgZGlzbWlzc2libGVEYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFEaXNtaXNzaWJsZSksXG4gICAgICBkZWxheURhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YURlbGF5KSxcbiAgICAgIGNvbnRhaW5lckRhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YUNvbnRhaW5lciksXG5cbiAgICAgIC8vIGludGVybmFsIHN0cmluZ3NcbiAgICAgIGNvbXBvbmVudCA9ICdwb3BvdmVyJyxcbiAgICAgIHRlbXBsYXRlID0gJ3RlbXBsYXRlJyxcbiAgICAgIHRyaWdnZXIgPSAndHJpZ2dlcicsXG4gICAgICBjbGFzc1N0cmluZyA9ICdjbGFzcycsXG4gICAgICBkaXYgPSAnZGl2JyxcbiAgICAgIGZhZGUgPSAnZmFkZScsXG4gICAgICBkYXRhQ29udGVudCA9ICdkYXRhLWNvbnRlbnQnLFxuICAgICAgZGlzbWlzc2libGUgPSAnZGlzbWlzc2libGUnLFxuICAgICAgY2xvc2VCdG4gPSAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiPsOXPC9idXR0b24+JyxcblxuICAgICAgLy8gY2hlY2sgY29udGFpbmVyXG4gICAgICBjb250YWluZXJFbGVtZW50ID0gcXVlcnlFbGVtZW50KG9wdGlvbnNbY29udGFpbmVyXSksXG4gICAgICBjb250YWluZXJEYXRhRWxlbWVudCA9IHF1ZXJ5RWxlbWVudChjb250YWluZXJEYXRhKSxcblxuICAgICAgLy8gbWF5YmUgdGhlIGVsZW1lbnQgaXMgaW5zaWRlIGEgbW9kYWxcbiAgICAgIG1vZGFsID0gZ2V0Q2xvc2VzdChlbGVtZW50LCAnLm1vZGFsJyksXG5cbiAgICAgIC8vIG1heWJlIHRoZSBlbGVtZW50IGlzIGluc2lkZSBhIGZpeGVkIG5hdmJhclxuICAgICAgbmF2YmFyRml4ZWRUb3AgPSBnZXRDbG9zZXN0KGVsZW1lbnQsICcuJyArIGZpeGVkVG9wKSxcbiAgICAgIG5hdmJhckZpeGVkQm90dG9tID0gZ2V0Q2xvc2VzdChlbGVtZW50LCAnLicgKyBmaXhlZEJvdHRvbSk7XG5cbiAgICAvLyBzZXQgaW5zdGFuY2Ugb3B0aW9uc1xuICAgIHRoaXNbdGVtcGxhdGVdID0gb3B0aW9uc1t0ZW1wbGF0ZV0gPyBvcHRpb25zW3RlbXBsYXRlXSA6IG51bGw7IC8vIEphdmFTY3JpcHQgb25seVxuICAgIHRoaXNbdHJpZ2dlcl0gPSBvcHRpb25zW3RyaWdnZXJdID8gb3B0aW9uc1t0cmlnZ2VyXSA6IHRyaWdnZXJEYXRhIHx8IGhvdmVyRXZlbnQ7XG4gICAgdGhpc1thbmltYXRpb25dID0gb3B0aW9uc1thbmltYXRpb25dICYmIG9wdGlvbnNbYW5pbWF0aW9uXSAhPT0gZmFkZSA/IG9wdGlvbnNbYW5pbWF0aW9uXSA6IGFuaW1hdGlvbkRhdGEgfHwgZmFkZTtcbiAgICB0aGlzW3BsYWNlbWVudF0gPSBvcHRpb25zW3BsYWNlbWVudF0gPyBvcHRpb25zW3BsYWNlbWVudF0gOiBwbGFjZW1lbnREYXRhIHx8IHRvcDtcbiAgICB0aGlzW2RlbGF5XSA9IHBhcnNlSW50KG9wdGlvbnNbZGVsYXldIHx8IGRlbGF5RGF0YSkgfHwgMjAwO1xuICAgIHRoaXNbZGlzbWlzc2libGVdID0gb3B0aW9uc1tkaXNtaXNzaWJsZV0gfHwgZGlzbWlzc2libGVEYXRhID09PSAndHJ1ZScgPyB0cnVlIDogZmFsc2U7XG4gICAgdGhpc1tjb250YWluZXJdID0gY29udGFpbmVyRWxlbWVudCA/IGNvbnRhaW5lckVsZW1lbnQgOlxuICAgICAgY29udGFpbmVyRGF0YUVsZW1lbnQgPyBjb250YWluZXJEYXRhRWxlbWVudCA6XG4gICAgICBuYXZiYXJGaXhlZFRvcCA/IG5hdmJhckZpeGVkVG9wIDpcbiAgICAgIG5hdmJhckZpeGVkQm90dG9tID8gbmF2YmFyRml4ZWRCb3R0b20gOlxuICAgICAgbW9kYWwgPyBtb2RhbCA6IERPQ1tib2R5XTtcblxuICAgIC8vIGJpbmQsIGNvbnRlbnRcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICB0aXRsZVN0cmluZyA9IG9wdGlvbnMudGl0bGUgfHwgZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFUaXRsZSkgfHwgbnVsbCxcbiAgICAgIGNvbnRlbnRTdHJpbmcgPSBvcHRpb25zLmNvbnRlbnQgfHwgZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFDb250ZW50KSB8fCBudWxsO1xuXG4gICAgaWYgKCFjb250ZW50U3RyaW5nICYmICF0aGlzW3RlbXBsYXRlXSkgcmV0dXJuOyAvLyBpbnZhbGlkYXRlXG5cbiAgICAvLyBjb25zdGFudHMsIHZhcnNcbiAgICB2YXIgcG9wb3ZlciA9IG51bGwsXG4gICAgICB0aW1lciA9IDAsXG4gICAgICBwbGFjZW1lbnRTZXR0aW5nID0gdGhpc1twbGFjZW1lbnRdLFxuXG4gICAgICAvLyBoYW5kbGVyc1xuICAgICAgZGlzbWlzc2libGVIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHBvcG92ZXIgIT09IG51bGwgJiYgZVt0YXJnZXRdID09PSBxdWVyeUVsZW1lbnQoJy5jbG9zZScsIHBvcG92ZXIpKSB7XG4gICAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgICAgcmVtb3ZlUG9wb3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZltjb250YWluZXJdLnJlbW92ZUNoaWxkKHBvcG92ZXIpO1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIHBvcG92ZXIgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVBvcG92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRpdGxlU3RyaW5nID0gb3B0aW9ucy50aXRsZSB8fCBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YVRpdGxlKTtcbiAgICAgICAgY29udGVudFN0cmluZyA9IG9wdGlvbnMuY29udGVudCB8fCBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YUNvbnRlbnQpO1xuICAgICAgICAvLyBmaXhpbmcgaHR0cHM6Ly9naXRodWIuY29tL3RoZWRucC9ib290c3RyYXAubmF0aXZlL2lzc3Vlcy8yMzNcbiAgICAgICAgY29udGVudFN0cmluZyA9ICEhY29udGVudFN0cmluZyA/IGNvbnRlbnRTdHJpbmcudHJpbSgpIDogbnVsbDtcblxuICAgICAgICBwb3BvdmVyID0gRE9DW2NyZWF0ZUVsZW1lbnRdKGRpdik7XG5cbiAgICAgICAgLy8gcG9wb3ZlciBhcnJvd1xuICAgICAgICB2YXIgcG9wb3ZlckFycm93ID0gRE9DW2NyZWF0ZUVsZW1lbnRdKGRpdik7XG4gICAgICAgIHBvcG92ZXJBcnJvd1tzZXRBdHRyaWJ1dGVdKGNsYXNzU3RyaW5nLCAnYXJyb3cnKTtcbiAgICAgICAgcG9wb3ZlclthcHBlbmRDaGlsZF0ocG9wb3ZlckFycm93KTtcblxuICAgICAgICBpZiAoY29udGVudFN0cmluZyAhPT0gbnVsbCAmJiBzZWxmW3RlbXBsYXRlXSA9PT0gbnVsbCkgeyAvL2NyZWF0ZSB0aGUgcG9wb3ZlciBmcm9tIGRhdGEgYXR0cmlidXRlc1xuXG4gICAgICAgICAgcG9wb3ZlcltzZXRBdHRyaWJ1dGVdKCdyb2xlJywgJ3Rvb2x0aXAnKTtcblxuICAgICAgICAgIGlmICh0aXRsZVN0cmluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBvcG92ZXJUaXRsZSA9IERPQ1tjcmVhdGVFbGVtZW50XSgnaDMnKTtcbiAgICAgICAgICAgIHBvcG92ZXJUaXRsZVtzZXRBdHRyaWJ1dGVdKGNsYXNzU3RyaW5nLCBjb21wb25lbnQgKyAnLWhlYWRlcicpO1xuXG4gICAgICAgICAgICBwb3BvdmVyVGl0bGVbaW5uZXJIVE1MXSA9IHNlbGZbZGlzbWlzc2libGVdID8gdGl0bGVTdHJpbmcgKyBjbG9zZUJ0biA6IHRpdGxlU3RyaW5nO1xuICAgICAgICAgICAgcG9wb3ZlclthcHBlbmRDaGlsZF0ocG9wb3ZlclRpdGxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL3NldCBwb3BvdmVyIGNvbnRlbnRcbiAgICAgICAgICB2YXIgcG9wb3ZlckNvbnRlbnQgPSBET0NbY3JlYXRlRWxlbWVudF0oZGl2KTtcbiAgICAgICAgICBwb3BvdmVyQ29udGVudFtzZXRBdHRyaWJ1dGVdKGNsYXNzU3RyaW5nLCBjb21wb25lbnQgKyAnLWJvZHknKTtcbiAgICAgICAgICBwb3BvdmVyQ29udGVudFtpbm5lckhUTUxdID0gc2VsZltkaXNtaXNzaWJsZV0gJiYgdGl0bGVTdHJpbmcgPT09IG51bGwgPyBjb250ZW50U3RyaW5nICsgY2xvc2VCdG4gOiBjb250ZW50U3RyaW5nO1xuICAgICAgICAgIHBvcG92ZXJbYXBwZW5kQ2hpbGRdKHBvcG92ZXJDb250ZW50KTtcblxuICAgICAgICB9IGVsc2UgeyAvLyBvciBjcmVhdGUgdGhlIHBvcG92ZXIgZnJvbSB0ZW1wbGF0ZVxuICAgICAgICAgIHZhciBwb3BvdmVyVGVtcGxhdGUgPSBET0NbY3JlYXRlRWxlbWVudF0oZGl2KTtcbiAgICAgICAgICBzZWxmW3RlbXBsYXRlXSA9IHNlbGZbdGVtcGxhdGVdLnRyaW0oKTtcbiAgICAgICAgICBwb3BvdmVyVGVtcGxhdGVbaW5uZXJIVE1MXSA9IHNlbGZbdGVtcGxhdGVdO1xuICAgICAgICAgIHBvcG92ZXJbaW5uZXJIVE1MXSA9IHBvcG92ZXJUZW1wbGF0ZS5maXJzdENoaWxkW2lubmVySFRNTF07XG4gICAgICAgIH1cblxuICAgICAgICAvL2FwcGVuZCB0byB0aGUgY29udGFpbmVyXG4gICAgICAgIHNlbGZbY29udGFpbmVyXVthcHBlbmRDaGlsZF0ocG9wb3Zlcik7XG4gICAgICAgIHBvcG92ZXJbc3R5bGVdLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBwb3BvdmVyW3NldEF0dHJpYnV0ZV0oY2xhc3NTdHJpbmcsIGNvbXBvbmVudCArICcgYnMtJyArIGNvbXBvbmVudCArICctJyArIHBsYWNlbWVudFNldHRpbmcgKyAnICcgKyBzZWxmW2FuaW1hdGlvbl0pO1xuICAgICAgfSxcbiAgICAgIHNob3dQb3BvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAhaGFzQ2xhc3MocG9wb3Zlciwgc2hvd0NsYXNzKSAmJiAoYWRkQ2xhc3MocG9wb3Zlciwgc2hvd0NsYXNzKSk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlUG9wb3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3R5bGVUaXAoZWxlbWVudCwgcG9wb3ZlciwgcGxhY2VtZW50U2V0dGluZywgc2VsZltjb250YWluZXJdKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIGV2ZW50IHRvZ2dsZVxuICAgICAgZGlzbWlzc0hhbmRsZXJUb2dnbGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoY2xpY2tFdmVudCA9PSBzZWxmW3RyaWdnZXJdIHx8ICdmb2N1cycgPT0gc2VsZlt0cmlnZ2VyXSkge1xuICAgICAgICAgICFzZWxmW2Rpc21pc3NpYmxlXSAmJiB0eXBlKGVsZW1lbnQsICdibHVyJywgc2VsZi5oaWRlKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmW2Rpc21pc3NpYmxlXSAmJiB0eXBlKERPQywgY2xpY2tFdmVudCwgZGlzbWlzc2libGVIYW5kbGVyKTtcbiAgICAgICAgdHlwZShnbG9iYWxPYmplY3QsIHJlc2l6ZUV2ZW50LCBzZWxmLmhpZGUsIHBhc3NpdmVIYW5kbGVyKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIHRyaWdnZXJzXG4gICAgICBzaG93VHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGlzbWlzc0hhbmRsZXJUb2dnbGUob24pO1xuICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNob3duRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICB9LFxuICAgICAgaGlkZVRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpc21pc3NIYW5kbGVyVG9nZ2xlKG9mZik7XG4gICAgICAgIHJlbW92ZVBvcG92ZXIoKTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBoaWRkZW5FdmVudCwgY29tcG9uZW50KTtcbiAgICAgIH07XG5cbiAgICAvLyBwdWJsaWMgbWV0aG9kcyAvIGhhbmRsZXJzXG4gICAgdGhpcy50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocG9wb3ZlciA9PT0gbnVsbCkge1xuICAgICAgICBzZWxmLnNob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwb3BvdmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcGxhY2VtZW50U2V0dGluZyA9IHNlbGZbcGxhY2VtZW50XTsgLy8gd2UgcmVzZXQgcGxhY2VtZW50IGluIGFsbCBjYXNlc1xuICAgICAgICAgIGNyZWF0ZVBvcG92ZXIoKTtcbiAgICAgICAgICB1cGRhdGVQb3BvdmVyKCk7XG4gICAgICAgICAgc2hvd1BvcG92ZXIoKTtcbiAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNob3dFdmVudCwgY29tcG9uZW50KTtcbiAgICAgICAgICAhIXNlbGZbYW5pbWF0aW9uXSA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKHBvcG92ZXIsIHNob3dUcmlnZ2VyKSA6IHNob3dUcmlnZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDIwKTtcbiAgICB9O1xuICAgIHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocG9wb3ZlciAmJiBwb3BvdmVyICE9PSBudWxsICYmIGhhc0NsYXNzKHBvcG92ZXIsIHNob3dDbGFzcykpIHtcbiAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGhpZGVFdmVudCwgY29tcG9uZW50KTtcbiAgICAgICAgICByZW1vdmVDbGFzcyhwb3BvdmVyLCBzaG93Q2xhc3MpO1xuICAgICAgICAgICEhc2VsZlthbmltYXRpb25dID8gZW11bGF0ZVRyYW5zaXRpb25FbmQocG9wb3ZlciwgaGlkZVRyaWdnZXIpIDogaGlkZVRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSwgc2VsZltkZWxheV0pO1xuICAgIH07XG5cbiAgICAvLyBpbml0XG4gICAgaWYgKCEoc3RyaW5nUG9wb3ZlciBpbiBlbGVtZW50KSkgeyAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgICAgaWYgKHNlbGZbdHJpZ2dlcl0gPT09IGhvdmVyRXZlbnQpIHtcbiAgICAgICAgb24oZWxlbWVudCwgbW91c2VIb3ZlclswXSwgc2VsZi5zaG93KTtcbiAgICAgICAgaWYgKCFzZWxmW2Rpc21pc3NpYmxlXSkge1xuICAgICAgICAgIG9uKGVsZW1lbnQsIG1vdXNlSG92ZXJbMV0sIHNlbGYuaGlkZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2xpY2tFdmVudCA9PSBzZWxmW3RyaWdnZXJdIHx8ICdmb2N1cycgPT0gc2VsZlt0cmlnZ2VyXSkge1xuICAgICAgICBvbihlbGVtZW50LCBzZWxmW3RyaWdnZXJdLCBzZWxmLnRvZ2dsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRbc3RyaW5nUG9wb3Zlcl0gPSBzZWxmO1xuICB9O1xuXG4gIC8vIFBPUE9WRVIgREFUQSBBUElcbiAgLy8gPT09PT09PT09PT09PT09PVxuICBzdXBwb3J0c1twdXNoXShbc3RyaW5nUG9wb3ZlciwgUG9wb3ZlciwgJ1snICsgZGF0YVRvZ2dsZSArICc9XCJwb3BvdmVyXCJdJ10pO1xuXG5cbiAgLyogTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgU2Nyb2xsU3B5XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBTQ1JPTExTUFkgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuICB2YXIgU2Nyb2xsU3B5ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcblxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnQsIHRoZSBlbGVtZW50IHdlIHNweSBvblxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciB0YXJnZXREYXRhID0gcXVlcnlFbGVtZW50KGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhVGFyZ2V0KSksXG4gICAgICBvZmZzZXREYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKCdkYXRhLW9mZnNldCcpO1xuXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIGludmFsaWRhdGVcbiAgICBpZiAoIW9wdGlvbnNbdGFyZ2V0XSAmJiAhdGFyZ2V0RGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV2ZW50IHRhcmdldHMsIGNvbnN0YW50c1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHNweVRhcmdldCA9IG9wdGlvbnNbdGFyZ2V0XSAmJiBxdWVyeUVsZW1lbnQob3B0aW9uc1t0YXJnZXRdKSB8fCB0YXJnZXREYXRhLFxuICAgICAgbGlua3MgPSBzcHlUYXJnZXQgJiYgc3B5VGFyZ2V0W2dldEVsZW1lbnRzQnlUYWdOYW1lXSgnQScpLFxuICAgICAgb2Zmc2V0ID0gcGFyc2VJbnQob3B0aW9uc1snb2Zmc2V0J10gfHwgb2Zmc2V0RGF0YSkgfHwgMTAsXG4gICAgICBpdGVtcyA9IFtdLFxuICAgICAgdGFyZ2V0SXRlbXMgPSBbXSxcbiAgICAgIHNjcm9sbE9mZnNldCxcbiAgICAgIHNjcm9sbFRhcmdldCA9IGVsZW1lbnRbb2Zmc2V0SGVpZ2h0XSA8IGVsZW1lbnRbc2Nyb2xsSGVpZ2h0XSA/IGVsZW1lbnQgOiBnbG9iYWxPYmplY3QsIC8vIGRldGVybWluZSB3aGljaCBpcyB0aGUgcmVhbCBzY3JvbGxUYXJnZXRcbiAgICAgIGlzV2luZG93ID0gc2Nyb2xsVGFyZ2V0ID09PSBnbG9iYWxPYmplY3Q7XG5cbiAgICAvLyBwb3B1bGF0ZSBpdGVtcyBhbmQgdGFyZ2V0c1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGxpbmtzW2xlbmd0aF07IGkgPCBpbDsgaSsrKSB7XG4gICAgICB2YXIgaHJlZiA9IGxpbmtzW2ldW2dldEF0dHJpYnV0ZV0oJ2hyZWYnKSxcbiAgICAgICAgdGFyZ2V0SXRlbSA9IGhyZWYgJiYgaHJlZi5jaGFyQXQoMCkgPT09ICcjJyAmJiBocmVmLnNsaWNlKC0xKSAhPT0gJyMnICYmIHF1ZXJ5RWxlbWVudChocmVmKTtcbiAgICAgIGlmICghIXRhcmdldEl0ZW0pIHtcbiAgICAgICAgaXRlbXNbcHVzaF0obGlua3NbaV0pO1xuICAgICAgICB0YXJnZXRJdGVtc1twdXNoXSh0YXJnZXRJdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICB2YXIgdXBkYXRlSXRlbSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2luZGV4XSxcbiAgICAgICAgICB0YXJnZXRJdGVtID0gdGFyZ2V0SXRlbXNbaW5kZXhdLCAvLyB0aGUgbWVudSBpdGVtIHRhcmdldHMgdGhpcyBlbGVtZW50XG4gICAgICAgICAgZHJvcGRvd24gPSBpdGVtW3BhcmVudE5vZGVdW3BhcmVudE5vZGVdLFxuICAgICAgICAgIGRyb3Bkb3duTGluayA9IGhhc0NsYXNzKGRyb3Bkb3duLCAnZHJvcGRvd24nKSAmJiBkcm9wZG93bltnZXRFbGVtZW50c0J5VGFnTmFtZV0oJ0EnKVswXSxcbiAgICAgICAgICB0YXJnZXRSZWN0ID0gaXNXaW5kb3cgJiYgdGFyZ2V0SXRlbVtnZXRCb3VuZGluZ0NsaWVudFJlY3RdKCksXG5cbiAgICAgICAgICBpc0FjdGl2ZSA9IGhhc0NsYXNzKGl0ZW0sIGFjdGl2ZSkgfHwgZmFsc2UsXG5cbiAgICAgICAgICB0b3BFZGdlID0gKGlzV2luZG93ID8gdGFyZ2V0UmVjdFt0b3BdICsgc2Nyb2xsT2Zmc2V0IDogdGFyZ2V0SXRlbVtvZmZzZXRUb3BdKSAtIG9mZnNldCxcbiAgICAgICAgICBib3R0b21FZGdlID0gaXNXaW5kb3cgPyB0YXJnZXRSZWN0W2JvdHRvbV0gKyBzY3JvbGxPZmZzZXQgLSBvZmZzZXQgOiB0YXJnZXRJdGVtc1tpbmRleCArIDFdID8gdGFyZ2V0SXRlbXNbaW5kZXggKyAxXVtvZmZzZXRUb3BdIC0gb2Zmc2V0IDogZWxlbWVudFtzY3JvbGxIZWlnaHRdLFxuXG4gICAgICAgICAgaW5zaWRlID0gc2Nyb2xsT2Zmc2V0ID49IHRvcEVkZ2UgJiYgYm90dG9tRWRnZSA+IHNjcm9sbE9mZnNldDtcblxuICAgICAgICBpZiAoIWlzQWN0aXZlICYmIGluc2lkZSkge1xuICAgICAgICAgIGlmICghaGFzQ2xhc3MoaXRlbSwgYWN0aXZlKSkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoaXRlbSwgYWN0aXZlKTtcbiAgICAgICAgICAgIGlmIChkcm9wZG93bkxpbmsgJiYgIWhhc0NsYXNzKGRyb3Bkb3duTGluaywgYWN0aXZlKSkge1xuICAgICAgICAgICAgICBhZGRDbGFzcyhkcm9wZG93bkxpbmssIGFjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsICdhY3RpdmF0ZScsICdzY3JvbGxzcHknLCBpdGVtc1tpbmRleF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaW5zaWRlKSB7XG4gICAgICAgICAgaWYgKGhhc0NsYXNzKGl0ZW0sIGFjdGl2ZSkpIHtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGl0ZW0sIGFjdGl2ZSk7XG4gICAgICAgICAgICBpZiAoZHJvcGRvd25MaW5rICYmIGhhc0NsYXNzKGRyb3Bkb3duTGluaywgYWN0aXZlKSAmJiAhZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShpdGVtW3BhcmVudE5vZGVdLCBhY3RpdmUpLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzcyhkcm9wZG93bkxpbmssIGFjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpbnNpZGUgJiYgIWlzQWN0aXZlIHx8IGlzQWN0aXZlICYmIGluc2lkZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZUl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzY3JvbGxPZmZzZXQgPSBpc1dpbmRvdyA/IGdldFNjcm9sbCgpLnkgOiBlbGVtZW50W3Njcm9sbFRvcF07XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgaXRsID0gaXRlbXNbbGVuZ3RoXTsgaW5kZXggPCBpdGw7IGluZGV4KyspIHtcbiAgICAgICAgICB1cGRhdGVJdGVtKGluZGV4KVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgLy8gcHVibGljIG1ldGhvZFxuICAgIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZUl0ZW1zKCk7XG4gICAgfVxuXG4gICAgLy8gaW5pdFxuICAgIGlmICghKHN0cmluZ1Njcm9sbFNweSBpbiBlbGVtZW50KSkgeyAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgICAgb24oc2Nyb2xsVGFyZ2V0LCBzY3JvbGxFdmVudCwgc2VsZi5yZWZyZXNoLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgICBvbihnbG9iYWxPYmplY3QsIHJlc2l6ZUV2ZW50LCBzZWxmLnJlZnJlc2gsIHBhc3NpdmVIYW5kbGVyKTtcbiAgICB9XG4gICAgc2VsZi5yZWZyZXNoKCk7XG4gICAgZWxlbWVudFtzdHJpbmdTY3JvbGxTcHldID0gc2VsZjtcbiAgfTtcblxuICAvLyBTQ1JPTExTUFkgREFUQSBBUElcbiAgLy8gPT09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKFtzdHJpbmdTY3JvbGxTcHksIFNjcm9sbFNweSwgJ1snICsgZGF0YVNweSArICc9XCJzY3JvbGxcIl0nXSk7XG5cblxuICAvKiBOYXRpdmUgSmF2YXNjcmlwdCBmb3IgQm9vdHN0cmFwIDQgfCBUYWJcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIFRBQiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09XG4gIHZhciBUYWIgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAvLyBEQVRBIEFQSVxuICAgIHZhciBoZWlnaHREYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFIZWlnaHQpLFxuXG4gICAgICAvLyBzdHJpbmdzXG4gICAgICBjb21wb25lbnQgPSAndGFiJyxcbiAgICAgIGhlaWdodCA9ICdoZWlnaHQnLFxuICAgICAgZmxvYXQgPSAnZmxvYXQnLFxuICAgICAgaXNBbmltYXRpbmcgPSAnaXNBbmltYXRpbmcnO1xuXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzW2hlaWdodF0gPSBzdXBwb3J0VHJhbnNpdGlvbnMgPyAob3B0aW9uc1toZWlnaHRdIHx8IGhlaWdodERhdGEgPT09ICd0cnVlJykgOiBmYWxzZTtcblxuICAgIC8vIGJpbmQsIGV2ZW50IHRhcmdldHNcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBuZXh0LFxuICAgICAgdGFicyA9IGdldENsb3Nlc3QoZWxlbWVudCwgJy5uYXYnKSxcbiAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyID0gZmFsc2UsXG4gICAgICBkcm9wZG93biA9IHRhYnMgJiYgcXVlcnlFbGVtZW50KCcuZHJvcGRvd24tdG9nZ2xlJywgdGFicyksXG4gICAgICBhY3RpdmVUYWIsIGFjdGl2ZUNvbnRlbnQsIG5leHRDb250ZW50LCBjb250YWluZXJIZWlnaHQsIGVxdWFsQ29udGVudHMsIG5leHRIZWlnaHQsXG5cbiAgICAgIC8vIHRyaWdnZXJcbiAgICAgIHRyaWdnZXJFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyW3N0eWxlXVtoZWlnaHRdID0gJyc7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRhYnNDb250ZW50Q29udGFpbmVyLCBjb2xsYXBzaW5nKTtcbiAgICAgICAgdGFic1tpc0FuaW1hdGluZ10gPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyU2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRhYnNDb250ZW50Q29udGFpbmVyKSB7IC8vIGhlaWdodCBhbmltYXRpb25cbiAgICAgICAgICBpZiAoZXF1YWxDb250ZW50cykge1xuICAgICAgICAgICAgdHJpZ2dlckVuZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgLy8gZW5hYmxlcyBoZWlnaHQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyW3N0eWxlXVtoZWlnaHRdID0gbmV4dEhlaWdodCArICdweCc7IC8vIGhlaWdodCBhbmltYXRpb25cbiAgICAgICAgICAgICAgdGFic0NvbnRlbnRDb250YWluZXJbb2Zmc2V0V2lkdGhdO1xuICAgICAgICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0YWJzQ29udGVudENvbnRhaW5lciwgdHJpZ2dlckVuZCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhYnNbaXNBbmltYXRpbmddID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChuZXh0LCBzaG93bkV2ZW50LCBjb21wb25lbnQsIGFjdGl2ZVRhYik7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlckhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0YWJzQ29udGVudENvbnRhaW5lcikge1xuICAgICAgICAgIGFjdGl2ZUNvbnRlbnRbc3R5bGVdW2Zsb2F0XSA9IGxlZnQ7XG4gICAgICAgICAgbmV4dENvbnRlbnRbc3R5bGVdW2Zsb2F0XSA9IGxlZnQ7XG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gYWN0aXZlQ29udGVudFtzY3JvbGxIZWlnaHRdO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkQ2xhc3MobmV4dENvbnRlbnQsIGFjdGl2ZSk7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwobmV4dCwgc2hvd0V2ZW50LCBjb21wb25lbnQsIGFjdGl2ZVRhYik7XG5cbiAgICAgICAgcmVtb3ZlQ2xhc3MoYWN0aXZlQ29udGVudCwgYWN0aXZlKTtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChhY3RpdmVUYWIsIGhpZGRlbkV2ZW50LCBjb21wb25lbnQsIG5leHQpO1xuXG4gICAgICAgIGlmICh0YWJzQ29udGVudENvbnRhaW5lcikge1xuICAgICAgICAgIG5leHRIZWlnaHQgPSBuZXh0Q29udGVudFtzY3JvbGxIZWlnaHRdO1xuICAgICAgICAgIGVxdWFsQ29udGVudHMgPSBuZXh0SGVpZ2h0ID09PSBjb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgYWRkQ2xhc3ModGFic0NvbnRlbnRDb250YWluZXIsIGNvbGxhcHNpbmcpO1xuICAgICAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyW3N0eWxlXVtoZWlnaHRdID0gY29udGFpbmVySGVpZ2h0ICsgJ3B4JzsgLy8gaGVpZ2h0IGFuaW1hdGlvblxuICAgICAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyW29mZnNldEhlaWdodF07XG4gICAgICAgICAgYWN0aXZlQ29udGVudFtzdHlsZV1bZmxvYXRdID0gJyc7XG4gICAgICAgICAgbmV4dENvbnRlbnRbc3R5bGVdW2Zsb2F0XSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0NsYXNzKG5leHRDb250ZW50LCAnZmFkZScpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhuZXh0Q29udGVudCwgc2hvd0NsYXNzKTtcbiAgICAgICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKG5leHRDb250ZW50LCB0cmlnZ2VyU2hvdyk7XG4gICAgICAgICAgfSwgMjApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyaWdnZXJTaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICBpZiAoIXRhYnMpIHJldHVybjsgLy8gaW52YWxpZGF0ZVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgYW5pbWF0aW9uIHN0YXRlXG4gICAgdGFic1tpc0FuaW1hdGluZ10gPSBmYWxzZTtcblxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIHZhciBnZXRBY3RpdmVUYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY3RpdmVUYWJzID0gZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSh0YWJzLCBhY3RpdmUpLFxuICAgICAgICAgIGFjdGl2ZVRhYjtcbiAgICAgICAgaWYgKGFjdGl2ZVRhYnNbbGVuZ3RoXSA9PT0gMSAmJiAhaGFzQ2xhc3MoYWN0aXZlVGFic1swXVtwYXJlbnROb2RlXSwgJ2Ryb3Bkb3duJykpIHtcbiAgICAgICAgICBhY3RpdmVUYWIgPSBhY3RpdmVUYWJzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGFjdGl2ZVRhYnNbbGVuZ3RoXSA+IDEpIHtcbiAgICAgICAgICBhY3RpdmVUYWIgPSBhY3RpdmVUYWJzW2FjdGl2ZVRhYnNbbGVuZ3RoXSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmVUYWI7XG4gICAgICB9LFxuICAgICAgZ2V0QWN0aXZlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5RWxlbWVudChnZXRBY3RpdmVUYWIoKVtnZXRBdHRyaWJ1dGVdKCdocmVmJykpO1xuICAgICAgfSxcbiAgICAgIC8vIGhhbmRsZXIgXG4gICAgICBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlW3ByZXZlbnREZWZhdWx0XSgpO1xuICAgICAgICBuZXh0ID0gZVtjdXJyZW50VGFyZ2V0XTtcbiAgICAgICAgIXRhYnNbaXNBbmltYXRpbmddICYmICFoYXNDbGFzcyhuZXh0LCBhY3RpdmUpICYmIHNlbGYuc2hvdygpO1xuICAgICAgfTtcblxuICAgIC8vIHB1YmxpYyBtZXRob2RcbiAgICB0aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7IC8vIHRoZSB0YWIgd2UgY2xpY2tlZCBpcyBub3cgdGhlIG5leHQgdGFiXG4gICAgICBuZXh0ID0gbmV4dCB8fCBlbGVtZW50O1xuICAgICAgbmV4dENvbnRlbnQgPSBxdWVyeUVsZW1lbnQobmV4dFtnZXRBdHRyaWJ1dGVdKCdocmVmJykpOyAvL3RoaXMgaXMgdGhlIGFjdHVhbCBvYmplY3QsIHRoZSBuZXh0IHRhYiBjb250ZW50IHRvIGFjdGl2YXRlXG4gICAgICBhY3RpdmVUYWIgPSBnZXRBY3RpdmVUYWIoKTtcbiAgICAgIGFjdGl2ZUNvbnRlbnQgPSBnZXRBY3RpdmVDb250ZW50KCk7XG5cbiAgICAgIHRhYnNbaXNBbmltYXRpbmddID0gdHJ1ZTtcbiAgICAgIHJlbW92ZUNsYXNzKGFjdGl2ZVRhYiwgYWN0aXZlKTtcbiAgICAgIGFjdGl2ZVRhYltzZXRBdHRyaWJ1dGVdKGFyaWFTZWxlY3RlZCwgJ2ZhbHNlJyk7XG4gICAgICBhZGRDbGFzcyhuZXh0LCBhY3RpdmUpO1xuICAgICAgbmV4dFtzZXRBdHRyaWJ1dGVdKGFyaWFTZWxlY3RlZCwgJ3RydWUnKTtcblxuICAgICAgaWYgKGRyb3Bkb3duKSB7XG4gICAgICAgIGlmICghaGFzQ2xhc3MoZWxlbWVudFtwYXJlbnROb2RlXSwgJ2Ryb3Bkb3duLW1lbnUnKSkge1xuICAgICAgICAgIGlmIChoYXNDbGFzcyhkcm9wZG93biwgYWN0aXZlKSkgcmVtb3ZlQ2xhc3MoZHJvcGRvd24sIGFjdGl2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFoYXNDbGFzcyhkcm9wZG93biwgYWN0aXZlKSkgYWRkQ2xhc3MoZHJvcGRvd24sIGFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChhY3RpdmVUYWIsIGhpZGVFdmVudCwgY29tcG9uZW50LCBuZXh0KTtcblxuICAgICAgaWYgKGhhc0NsYXNzKGFjdGl2ZUNvbnRlbnQsICdmYWRlJykpIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoYWN0aXZlQ29udGVudCwgc2hvd0NsYXNzKTtcbiAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoYWN0aXZlQ29udGVudCwgdHJpZ2dlckhpZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJpZ2dlckhpZGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gaW5pdFxuICAgIGlmICghKHN0cmluZ1RhYiBpbiBlbGVtZW50KSkgeyAvLyBwcmV2ZW50IGFkZGluZyBldmVudCBoYW5kbGVycyB0d2ljZVxuICAgICAgb24oZWxlbWVudCwgY2xpY2tFdmVudCwgY2xpY2tIYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKHNlbGZbaGVpZ2h0XSkge1xuICAgICAgdGFic0NvbnRlbnRDb250YWluZXIgPSBnZXRBY3RpdmVDb250ZW50KClbcGFyZW50Tm9kZV07XG4gICAgfVxuICAgIGVsZW1lbnRbc3RyaW5nVGFiXSA9IHNlbGY7XG4gIH07XG5cbiAgLy8gVEFCIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PVxuICBzdXBwb3J0c1twdXNoXShbc3RyaW5nVGFiLCBUYWIsICdbJyArIGRhdGFUb2dnbGUgKyAnPVwidGFiXCJdJ10pO1xuXG5cbiAgLyogTmF0aXZlIEphdmFzY3JpcHQgZm9yIEJvb3RzdHJhcCA0IHwgVG9hc3RcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBUT0FTVCBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PVxuICB2YXIgVG9hc3QgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAvLyBzZXQgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gREFUQSBBUElcbiAgICB2YXIgYW5pbWF0aW9uRGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhQW5pbWF0aW9uKSxcbiAgICAgIGF1dG9oaWRlRGF0YSA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXShkYXRhQXV0b2hpZGUpLFxuICAgICAgZGVsYXlEYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFEZWxheSksXG5cbiAgICAgIC8vIHN0cmluZ3NcbiAgICAgIGNvbXBvbmVudCA9ICd0b2FzdCcsXG4gICAgICBhdXRvaGlkZSA9ICdhdXRvaGlkZScsXG4gICAgICBhbmltYXRpb24gPSAnYW5pbWF0aW9uJyxcbiAgICAgIHNob3dpbmcgPSAnc2hvd2luZycsXG4gICAgICBoaWRlID0gJ2hpZGUnLFxuICAgICAgZmFkZSA9ICdmYWRlJztcblxuICAgIC8vIHNldCBpbnN0YW5jZSBvcHRpb25zXG4gICAgdGhpc1thbmltYXRpb25dID0gb3B0aW9uc1thbmltYXRpb25dID09PSBmYWxzZSB8fCBhbmltYXRpb25EYXRhID09PSAnZmFsc2UnID8gMCA6IDE7IC8vIHRydWUgYnkgZGVmYXVsdFxuICAgIHRoaXNbYXV0b2hpZGVdID0gb3B0aW9uc1thdXRvaGlkZV0gPT09IGZhbHNlIHx8IGF1dG9oaWRlRGF0YSA9PT0gJ2ZhbHNlJyA/IDAgOiAxOyAvLyB0cnVlIGJ5IGRlZmF1bHRcbiAgICB0aGlzW2RlbGF5XSA9IHBhcnNlSW50KG9wdGlvbnNbZGVsYXldIHx8IGRlbGF5RGF0YSkgfHwgNTAwOyAvLyA1MDBtcyBkZWZhdWx0XG5cbiAgICAvLyBiaW5kLHRvYXN0IGFuZCB0aW1lclxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHRpbWVyID0gMCxcbiAgICAgIC8vIGdldCB0aGUgdG9hc3QgZWxlbWVudFxuICAgICAgdG9hc3QgPSBnZXRDbG9zZXN0KGVsZW1lbnQsICcudG9hc3QnKTtcblxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuICAgIC8vIGFuaW1hdGlvbiBjb21wbGV0ZVxuICAgIHZhciBzaG93Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRvYXN0LCBzaG93aW5nKTtcbiAgICAgICAgYWRkQ2xhc3ModG9hc3QsIHNob3dDbGFzcyk7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwodG9hc3QsIHNob3duRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIGlmIChzZWxmW2F1dG9oaWRlXSkge1xuICAgICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGlkZUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRDbGFzcyh0b2FzdCwgaGlkZSk7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwodG9hc3QsIGhpZGRlbkV2ZW50LCBjb21wb25lbnQpO1xuICAgICAgfSxcbiAgICAgIGNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVDbGFzcyh0b2FzdCwgc2hvd0NsYXNzKTtcbiAgICAgICAgc2VsZlthbmltYXRpb25dID8gZW11bGF0ZVRyYW5zaXRpb25FbmQodG9hc3QsIGhpZGVDb21wbGV0ZSkgOiBoaWRlQ29tcGxldGUoKTtcbiAgICAgIH0sXG4gICAgICBkaXNwb3NlQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgYWRkQ2xhc3ModG9hc3QsIGhpZGUpO1xuICAgICAgICBvZmYoZWxlbWVudCwgY2xpY2tFdmVudCwgc2VsZi5oaWRlKTtcbiAgICAgICAgZWxlbWVudFtzdHJpbmdUb2FzdF0gPSBudWxsO1xuICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdG9hc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRvYXN0KSB7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwodG9hc3QsIHNob3dFdmVudCwgY29tcG9uZW50KTtcbiAgICAgICAgc2VsZlthbmltYXRpb25dICYmIGFkZENsYXNzKHRvYXN0LCBmYWRlKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3ModG9hc3QsIGhpZGUpO1xuICAgICAgICBhZGRDbGFzcyh0b2FzdCwgc2hvd2luZyk7XG5cbiAgICAgICAgc2VsZlthbmltYXRpb25dID8gZW11bGF0ZVRyYW5zaXRpb25FbmQodG9hc3QsIHNob3dDb21wbGV0ZSkgOiBzaG93Q29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGlkZSA9IGZ1bmN0aW9uIChub1RpbWVyKSB7XG4gICAgICBpZiAodG9hc3QgJiYgaGFzQ2xhc3ModG9hc3QsIHNob3dDbGFzcykpIHtcbiAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbCh0b2FzdCwgaGlkZUV2ZW50LCBjb21wb25lbnQpO1xuXG4gICAgICAgIGlmIChub1RpbWVyKSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2xvc2UsIHNlbGZbZGVsYXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRvYXN0ICYmIGhhc0NsYXNzKHRvYXN0LCBzaG93Q2xhc3MpKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRvYXN0LCBzaG93Q2xhc3MpO1xuICAgICAgICBzZWxmW2FuaW1hdGlvbl0gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b2FzdCwgZGlzcG9zZUNvbXBsZXRlKSA6IGRpc3Bvc2VDb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBpbml0XG4gICAgaWYgKCEoc3RyaW5nVG9hc3QgaW4gZWxlbWVudCkpIHsgLy8gcHJldmVudCBhZGRpbmcgZXZlbnQgaGFuZGxlcnMgdHdpY2VcbiAgICAgIG9uKGVsZW1lbnQsIGNsaWNrRXZlbnQsIHNlbGYuaGlkZSk7XG4gICAgfVxuICAgIGVsZW1lbnRbc3RyaW5nVG9hc3RdID0gc2VsZjtcbiAgfTtcblxuICAvLyBUT0FTVCBEQVRBIEFQSVxuICAvLyA9PT09PT09PT09PT09PT09PVxuICBzdXBwb3J0c1twdXNoXShbc3RyaW5nVG9hc3QsIFRvYXN0LCAnWycgKyBkYXRhRGlzbWlzcyArICc9XCJ0b2FzdFwiXSddKTtcblxuXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgNCB8IFRvb2x0aXBcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBUT09MVElQIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09XG4gIHZhciBUb29sdGlwID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcblxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgLy8gc2V0IG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIERBVEEgQVBJXG4gICAgdmFyIGFuaW1hdGlvbkRhdGEgPSBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YUFuaW1hdGlvbiksXG4gICAgICBwbGFjZW1lbnREYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFQbGFjZW1lbnQpLFxuICAgICAgZGVsYXlEYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFEZWxheSksXG4gICAgICBjb250YWluZXJEYXRhID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFDb250YWluZXIpLFxuXG4gICAgICAvLyBzdHJpbmdzXG4gICAgICBjb21wb25lbnQgPSAndG9vbHRpcCcsXG4gICAgICBjbGFzc1N0cmluZyA9ICdjbGFzcycsXG4gICAgICB0aXRsZSA9ICd0aXRsZScsXG4gICAgICBmYWRlID0gJ2ZhZGUnLFxuICAgICAgZGl2ID0gJ2RpdicsXG5cbiAgICAgIC8vIGNoZWNrIGNvbnRhaW5lclxuICAgICAgY29udGFpbmVyRWxlbWVudCA9IHF1ZXJ5RWxlbWVudChvcHRpb25zW2NvbnRhaW5lcl0pLFxuICAgICAgY29udGFpbmVyRGF0YUVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoY29udGFpbmVyRGF0YSksXG5cbiAgICAgIC8vIG1heWJlIHRoZSBlbGVtZW50IGlzIGluc2lkZSBhIG1vZGFsXG4gICAgICBtb2RhbCA9IGdldENsb3Nlc3QoZWxlbWVudCwgJy5tb2RhbCcpLFxuXG4gICAgICAvLyBtYXliZSB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYSBmaXhlZCBuYXZiYXJcbiAgICAgIG5hdmJhckZpeGVkVG9wID0gZ2V0Q2xvc2VzdChlbGVtZW50LCAnLicgKyBmaXhlZFRvcCksXG4gICAgICBuYXZiYXJGaXhlZEJvdHRvbSA9IGdldENsb3Nlc3QoZWxlbWVudCwgJy4nICsgZml4ZWRCb3R0b20pO1xuXG4gICAgLy8gc2V0IGluc3RhbmNlIG9wdGlvbnNcbiAgICB0aGlzW2FuaW1hdGlvbl0gPSBvcHRpb25zW2FuaW1hdGlvbl0gJiYgb3B0aW9uc1thbmltYXRpb25dICE9PSBmYWRlID8gb3B0aW9uc1thbmltYXRpb25dIDogYW5pbWF0aW9uRGF0YSB8fCBmYWRlO1xuICAgIHRoaXNbcGxhY2VtZW50XSA9IG9wdGlvbnNbcGxhY2VtZW50XSA/IG9wdGlvbnNbcGxhY2VtZW50XSA6IHBsYWNlbWVudERhdGEgfHwgdG9wO1xuICAgIHRoaXNbZGVsYXldID0gcGFyc2VJbnQob3B0aW9uc1tkZWxheV0gfHwgZGVsYXlEYXRhKSB8fCAyMDA7XG4gICAgdGhpc1tjb250YWluZXJdID0gY29udGFpbmVyRWxlbWVudCA/IGNvbnRhaW5lckVsZW1lbnQgOlxuICAgICAgY29udGFpbmVyRGF0YUVsZW1lbnQgPyBjb250YWluZXJEYXRhRWxlbWVudCA6XG4gICAgICBuYXZiYXJGaXhlZFRvcCA/IG5hdmJhckZpeGVkVG9wIDpcbiAgICAgIG5hdmJhckZpeGVkQm90dG9tID8gbmF2YmFyRml4ZWRCb3R0b20gOlxuICAgICAgbW9kYWwgPyBtb2RhbCA6IERPQ1tib2R5XTtcblxuICAgIC8vIGJpbmQsIGV2ZW50IHRhcmdldHMsIHRpdGxlIGFuZCBjb25zdGFudHNcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICB0aW1lciA9IDAsXG4gICAgICBwbGFjZW1lbnRTZXR0aW5nID0gdGhpc1twbGFjZW1lbnRdLFxuICAgICAgdG9vbHRpcCA9IG51bGwsXG4gICAgICB0aXRsZVN0cmluZyA9IGVsZW1lbnRbZ2V0QXR0cmlidXRlXSh0aXRsZSkgfHwgZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFUaXRsZSkgfHwgZWxlbWVudFtnZXRBdHRyaWJ1dGVdKGRhdGFPcmlnaW5hbFRpdGxlKTtcblxuICAgIGlmICghdGl0bGVTdHJpbmcgfHwgdGl0bGVTdHJpbmcgPT0gXCJcIikgcmV0dXJuOyAvLyBpbnZhbGlkYXRlXG5cbiAgICAvLyBwcml2YXRlIG1ldGhvZHNcbiAgICB2YXIgcmVtb3ZlVG9vbFRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZltjb250YWluZXJdLnJlbW92ZUNoaWxkKHRvb2x0aXApO1xuICAgICAgICB0b29sdGlwID0gbnVsbDtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVRvb2xUaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRpdGxlU3RyaW5nID0gZWxlbWVudFtnZXRBdHRyaWJ1dGVdKHRpdGxlKSB8fCBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YVRpdGxlKSB8fCBlbGVtZW50W2dldEF0dHJpYnV0ZV0oZGF0YU9yaWdpbmFsVGl0bGUpOyAvLyByZWFkIHRoZSB0aXRsZSBhZ2FpblxuXG4gICAgICAgIGlmICh0aXRsZVN0cmluZyAmJiB0aXRsZVN0cmluZyAhPT0gXCJcIikgeyAvLyBpbnZhbGlkYXRlLCBtYXliZSBtYXJrdXAgY2hhbmdlZFxuICAgICAgICAgIHRvb2x0aXAgPSBET0NbY3JlYXRlRWxlbWVudF0oZGl2KTtcbiAgICAgICAgICB0b29sdGlwW3NldEF0dHJpYnV0ZV0oJ3JvbGUnLCBjb21wb25lbnQpO1xuICAgICAgICAgIHRvb2x0aXBbc3R5bGVdW2xlZnRdID0gJzAnO1xuICAgICAgICAgIHRvb2x0aXBbc3R5bGVdW3RvcF0gPSAnMCc7XG5cbiAgICAgICAgICAvLyB0b29sdGlwIGFycm93XG4gICAgICAgICAgdmFyIHRvb2x0aXBBcnJvdyA9IERPQ1tjcmVhdGVFbGVtZW50XShkaXYpO1xuICAgICAgICAgIHRvb2x0aXBBcnJvd1tzZXRBdHRyaWJ1dGVdKGNsYXNzU3RyaW5nLCAnYXJyb3cnKTtcbiAgICAgICAgICB0b29sdGlwW2FwcGVuZENoaWxkXSh0b29sdGlwQXJyb3cpO1xuXG4gICAgICAgICAgdmFyIHRvb2x0aXBJbm5lciA9IERPQ1tjcmVhdGVFbGVtZW50XShkaXYpO1xuICAgICAgICAgIHRvb2x0aXBJbm5lcltzZXRBdHRyaWJ1dGVdKGNsYXNzU3RyaW5nLCBjb21wb25lbnQgKyAnLWlubmVyJyk7XG4gICAgICAgICAgdG9vbHRpcFthcHBlbmRDaGlsZF0odG9vbHRpcElubmVyKTtcbiAgICAgICAgICB0b29sdGlwSW5uZXJbaW5uZXJIVE1MXSA9IHRpdGxlU3RyaW5nO1xuXG4gICAgICAgICAgc2VsZltjb250YWluZXJdW2FwcGVuZENoaWxkXSh0b29sdGlwKTtcbiAgICAgICAgICB0b29sdGlwW3NldEF0dHJpYnV0ZV0oY2xhc3NTdHJpbmcsIGNvbXBvbmVudCArICcgYnMtJyArIGNvbXBvbmVudCArICctJyArIHBsYWNlbWVudFNldHRpbmcgKyAnICcgKyBzZWxmW2FuaW1hdGlvbl0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXBkYXRlVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3R5bGVUaXAoZWxlbWVudCwgdG9vbHRpcCwgcGxhY2VtZW50U2V0dGluZywgc2VsZltjb250YWluZXJdKTtcbiAgICAgIH0sXG4gICAgICBzaG93VG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIWhhc0NsYXNzKHRvb2x0aXAsIHNob3dDbGFzcykgJiYgKGFkZENsYXNzKHRvb2x0aXAsIHNob3dDbGFzcykpO1xuICAgICAgfSxcbiAgICAgIC8vIHRyaWdnZXJzXG4gICAgICBzaG93VHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb24oZ2xvYmFsT2JqZWN0LCByZXNpemVFdmVudCwgc2VsZi5oaWRlLCBwYXNzaXZlSGFuZGxlcik7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2hvd25FdmVudCwgY29tcG9uZW50KTtcbiAgICAgIH0sXG4gICAgICBoaWRlVHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmKGdsb2JhbE9iamVjdCwgcmVzaXplRXZlbnQsIHNlbGYuaGlkZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgICAgICByZW1vdmVUb29sVGlwKCk7XG4gICAgICAgIGJvb3RzdHJhcEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgaGlkZGVuRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICB9O1xuXG4gICAgLy8gcHVibGljIG1ldGhvZHNcbiAgICB0aGlzLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRvb2x0aXAgPT09IG51bGwpIHtcbiAgICAgICAgICBwbGFjZW1lbnRTZXR0aW5nID0gc2VsZltwbGFjZW1lbnRdOyAvLyB3ZSByZXNldCBwbGFjZW1lbnQgaW4gYWxsIGNhc2VzXG4gICAgICAgICAgLy8gaWYoY3JlYXRlVG9vbFRpcCgpID09IGZhbHNlKSByZXR1cm47XG4gICAgICAgICAgaWYgKGNyZWF0ZVRvb2xUaXAoKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIHNob3dUb29sdGlwKCk7XG4gICAgICAgICAgICBib290c3RyYXBDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNob3dFdmVudCwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICEhc2VsZlthbmltYXRpb25dID8gZW11bGF0ZVRyYW5zaXRpb25FbmQodG9vbHRpcCwgc2hvd1RyaWdnZXIpIDogc2hvd1RyaWdnZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDIwKTtcbiAgICB9O1xuICAgIHRoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodG9vbHRpcCAmJiBoYXNDbGFzcyh0b29sdGlwLCBzaG93Q2xhc3MpKSB7XG4gICAgICAgICAgYm9vdHN0cmFwQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBoaWRlRXZlbnQsIGNvbXBvbmVudCk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModG9vbHRpcCwgc2hvd0NsYXNzKTtcbiAgICAgICAgICAhIXNlbGZbYW5pbWF0aW9uXSA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRvb2x0aXAsIGhpZGVUcmlnZ2VyKSA6IGhpZGVUcmlnZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHNlbGZbZGVsYXldKTtcbiAgICB9O1xuICAgIHRoaXMudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0b29sdGlwKSB7XG4gICAgICAgIHNlbGYuc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGluaXRcbiAgICBpZiAoIShzdHJpbmdUb29sdGlwIGluIGVsZW1lbnQpKSB7IC8vIHByZXZlbnQgYWRkaW5nIGV2ZW50IGhhbmRsZXJzIHR3aWNlXG4gICAgICBlbGVtZW50W3NldEF0dHJpYnV0ZV0oZGF0YU9yaWdpbmFsVGl0bGUsIHRpdGxlU3RyaW5nKTtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHRpdGxlKTtcbiAgICAgIG9uKGVsZW1lbnQsIG1vdXNlSG92ZXJbMF0sIHNlbGYuc2hvdyk7XG4gICAgICBvbihlbGVtZW50LCBtb3VzZUhvdmVyWzFdLCBzZWxmLmhpZGUpO1xuICAgIH1cbiAgICBlbGVtZW50W3N0cmluZ1Rvb2x0aXBdID0gc2VsZjtcbiAgfTtcblxuICAvLyBUT09MVElQIERBVEEgQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG4gIHN1cHBvcnRzW3B1c2hdKFtzdHJpbmdUb29sdGlwLCBUb29sdGlwLCAnWycgKyBkYXRhVG9nZ2xlICsgJz1cInRvb2x0aXBcIl0nXSk7XG5cblxuXG4gIC8qIE5hdGl2ZSBKYXZhc2NyaXB0IGZvciBCb290c3RyYXAgfCBJbml0aWFsaXplIERhdGEgQVBJXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdmFyIGluaXRpYWxpemVEYXRhQVBJID0gZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCBjb2xsZWN0aW9uKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbGxlY3Rpb25bbGVuZ3RoXTsgaSA8IGw7IGkrKykge1xuICAgICAgICBuZXcgY29uc3RydWN0b3IoY29sbGVjdGlvbltpXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0Q2FsbGJhY2sgPSBCU04uaW5pdENhbGxiYWNrID0gZnVuY3Rpb24gKGxvb2tVcCkge1xuICAgICAgbG9va1VwID0gbG9va1VwIHx8IERPQztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3VwcG9ydHNbbGVuZ3RoXTsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbml0aWFsaXplRGF0YUFQSShzdXBwb3J0c1tpXVsxXSwgbG9va1VwW3F1ZXJ5U2VsZWN0b3JBbGxdKHN1cHBvcnRzW2ldWzJdKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvLyBidWxrIGluaXRpYWxpemUgYWxsIGNvbXBvbmVudHNcbiAgRE9DW2JvZHldID8gaW5pdENhbGxiYWNrKCkgOiBvbihET0MsICdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgIGluaXRDYWxsYmFjaygpO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIEFsZXJ0OiBBbGVydCxcbiAgICBCdXR0b246IEJ1dHRvbixcbiAgICBDYXJvdXNlbDogQ2Fyb3VzZWwsXG4gICAgQ29sbGFwc2U6IENvbGxhcHNlLFxuICAgIERyb3Bkb3duOiBEcm9wZG93bixcbiAgICBNb2RhbDogTW9kYWwsXG4gICAgUG9wb3ZlcjogUG9wb3ZlcixcbiAgICBTY3JvbGxTcHk6IFNjcm9sbFNweSxcbiAgICBUYWI6IFRhYixcbiAgICBUb2FzdDogVG9hc3QsXG4gICAgVG9vbHRpcDogVG9vbHRpcFxuICB9O1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bootstrap.native/dist/bootstrap-native-v4.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./resources/js/src/app.js":
/*!*********************************!*\
  !*** ./resources/js/src/app.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var bootstrap = __webpack_require__(/*! bootstrap.native/dist/bootstrap-native-v4 */ \"./node_modules/bootstrap.native/dist/bootstrap-native-v4.js\");\n\nvar messages = Array.prototype.slice.call(document.querySelectorAll('[data-dismiss=\"toast\"]'));\nmessages.forEach(function (message) {\n  message['Toast'].show();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvc3JjL2FwcC5qcz8wZWE3Il0sIm5hbWVzIjpbImJvb3RzdHJhcCIsInJlcXVpcmUiLCJtZXNzYWdlcyIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsIm1lc3NhZ2UiLCJzaG93Il0sIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxTQUFTLEdBQUdDLG1CQUFPLENBQUMsOEdBQUQsQ0FBdkI7O0FBRUEsSUFBSUMsUUFBUSxHQUFHQyxLQUFLLENBQUNDLFNBQU4sQ0FBZ0JDLEtBQWhCLENBQXNCQyxJQUF0QixDQUNYQyxRQUFRLENBQUNDLGdCQUFULENBQTBCLHdCQUExQixDQURXLENBQWY7QUFJQU4sUUFBUSxDQUFDTyxPQUFULENBQWlCLFVBQVVDLE9BQVYsRUFBbUI7QUFDaENBLFNBQU8sQ0FBQyxPQUFELENBQVAsQ0FBaUJDLElBQWpCO0FBQ0gsQ0FGRCIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9zcmMvYXBwLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGJvb3RzdHJhcCA9IHJlcXVpcmUoJ2Jvb3RzdHJhcC5uYXRpdmUvZGlzdC9ib290c3RyYXAtbmF0aXZlLXY0Jyk7XG5cbmxldCBtZXNzYWdlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWRpc21pc3M9XCJ0b2FzdFwiXScpXG4pO1xuXG5tZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgbWVzc2FnZVsnVG9hc3QnXS5zaG93KCk7XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/src/app.js\n");

/***/ }),

/***/ "./resources/js/src/polyfills.js":
/*!***************************************!*\
  !*** ./resources/js/src/polyfills.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Polyfill for matches()\n */\nif (!Element.prototype.matches) {\n  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n}\n\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function (s) {\n    var el = this;\n\n    do {\n      if (el.matches(s)) return el;\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1);\n\n    return null;\n  };\n}\n/**\n * Polyfill for closest()\n * - Relies on matches() above.\n */\n\n\nif (!Element.prototype.closest) {\n  Element.prototype.closest = function (s) {\n    var el = this;\n\n    do {\n      if (el.matches(s)) return el;\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1);\n\n    return null;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvc3JjL3BvbHlmaWxscy5qcz9kZWNmIl0sIm5hbWVzIjpbIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJtYXRjaGVzIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJjbG9zZXN0IiwicyIsImVsIiwicGFyZW50RWxlbWVudCIsInBhcmVudE5vZGUiLCJub2RlVHlwZSJdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBLElBQUksQ0FBQ0EsT0FBTyxDQUFDQyxTQUFSLENBQWtCQyxPQUF2QixFQUFnQztBQUM1QkYsU0FBTyxDQUFDQyxTQUFSLENBQWtCQyxPQUFsQixHQUE0QkYsT0FBTyxDQUFDQyxTQUFSLENBQWtCRSxpQkFBbEIsSUFDeEJILE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkcscUJBRHRCO0FBRUg7O0FBRUQsSUFBSSxDQUFDSixPQUFPLENBQUNDLFNBQVIsQ0FBa0JJLE9BQXZCLEVBQWdDO0FBQzVCTCxTQUFPLENBQUNDLFNBQVIsQ0FBa0JJLE9BQWxCLEdBQTRCLFVBQVVDLENBQVYsRUFBYTtBQUNyQyxRQUFJQyxFQUFFLEdBQUcsSUFBVDs7QUFFQSxPQUFHO0FBQ0MsVUFBSUEsRUFBRSxDQUFDTCxPQUFILENBQVdJLENBQVgsQ0FBSixFQUFtQixPQUFPQyxFQUFQO0FBQ25CQSxRQUFFLEdBQUdBLEVBQUUsQ0FBQ0MsYUFBSCxJQUFvQkQsRUFBRSxDQUFDRSxVQUE1QjtBQUNILEtBSEQsUUFHU0YsRUFBRSxLQUFLLElBQVAsSUFBZUEsRUFBRSxDQUFDRyxRQUFILEtBQWdCLENBSHhDOztBQUlBLFdBQU8sSUFBUDtBQUNILEdBUkQ7QUFTSDtBQUVEOzs7Ozs7QUFJQSxJQUFJLENBQUNWLE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkksT0FBdkIsRUFBZ0M7QUFDNUJMLFNBQU8sQ0FBQ0MsU0FBUixDQUFrQkksT0FBbEIsR0FBNEIsVUFBVUMsQ0FBVixFQUFhO0FBQ3JDLFFBQUlDLEVBQUUsR0FBRyxJQUFUOztBQUVBLE9BQUc7QUFDQyxVQUFJQSxFQUFFLENBQUNMLE9BQUgsQ0FBV0ksQ0FBWCxDQUFKLEVBQW1CLE9BQU9DLEVBQVA7QUFDbkJBLFFBQUUsR0FBR0EsRUFBRSxDQUFDQyxhQUFILElBQW9CRCxFQUFFLENBQUNFLFVBQTVCO0FBQ0gsS0FIRCxRQUdTRixFQUFFLEtBQUssSUFBUCxJQUFlQSxFQUFFLENBQUNHLFFBQUgsS0FBZ0IsQ0FIeEM7O0FBSUEsV0FBTyxJQUFQO0FBQ0gsR0FSRDtBQVNIIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL3NyYy9wb2x5ZmlsbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBvbHlmaWxsIGZvciBtYXRjaGVzKClcbiAqL1xuaWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG4gICAgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgIEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3Rvcjtcbn1cblxuaWYgKCFFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0KSB7XG4gICAgRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXM7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVsLm1hdGNoZXMocykpIHJldHVybiBlbDtcbiAgICAgICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlO1xuICAgICAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG5cbi8qKlxuICogUG9seWZpbGwgZm9yIGNsb3Nlc3QoKVxuICogLSBSZWxpZXMgb24gbWF0Y2hlcygpIGFib3ZlLlxuICovXG5pZiAoIUVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QpIHtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcztcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZWwubWF0Y2hlcyhzKSkgcmV0dXJuIGVsO1xuICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGU7XG4gICAgICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/src/polyfills.js\n");

/***/ }),

/***/ "./resources/scss/theme/login.scss":
/*!*****************************************!*\
  !*** ./resources/scss/theme/login.scss ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy90aGVtZS9sb2dpbi5zY3NzPzI0MjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiLi9yZXNvdXJjZXMvc2Nzcy90aGVtZS9sb2dpbi5zY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/scss/theme/login.scss\n");

/***/ }),

/***/ "./resources/scss/theme/theme.scss":
/*!*****************************************!*\
  !*** ./resources/scss/theme/theme.scss ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy90aGVtZS90aGVtZS5zY3NzPzg5OTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiLi9yZXNvdXJjZXMvc2Nzcy90aGVtZS90aGVtZS5zY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/scss/theme/theme.scss\n");

/***/ }),

/***/ 0:
/*!*******************************************************************************************************************************************!*\
  !*** multi ./resources/js/src/polyfills.js ./resources/js/src/app.js ./resources/scss/theme/theme.scss ./resources/scss/theme/login.scss ***!
  \*******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! /Users/ryanthompson/Sites/streams.local/vendor/anomaly/flow-theme/resources/js/src/polyfills.js */"./resources/js/src/polyfills.js");
__webpack_require__(/*! /Users/ryanthompson/Sites/streams.local/vendor/anomaly/flow-theme/resources/js/src/app.js */"./resources/js/src/app.js");
__webpack_require__(/*! /Users/ryanthompson/Sites/streams.local/vendor/anomaly/flow-theme/resources/scss/theme/theme.scss */"./resources/scss/theme/theme.scss");
module.exports = __webpack_require__(/*! /Users/ryanthompson/Sites/streams.local/vendor/anomaly/flow-theme/resources/scss/theme/login.scss */"./resources/scss/theme/login.scss");


/***/ })

/******/ });